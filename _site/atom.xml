<?xml version="1.0" encoding="iso-8859-1"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>The Life of a Radar</title>
 <link href="http://ryanbigg.com/atom.xml" rel="self"/>
 <link href="http://ryanbigg.com"/>
 <updated>2022-11-14T09:30:04+11:00</updated>
 <id>http://ryanbigg.com/</id>
 <author>
   <name>Ryan Bigg</name>
   <email>radarlistener@gmail.com</email>
 </author>

 
 <entry>
   <title>A replacement for strong parameters</title>
   <link href="http://ryanbigg.com/2022/11/a-replacement-for-strong-parameters"/>
   <updated>2022-11-09T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2022/11/a-replacement-for-strong-parameters</id>
   <content type="html"><![CDATA[<p>I’m not going to take <a href="https://dev.37signals.com/vanilla-rails-is-plenty">this week’s (very obvious) bait about how “Vanilla Rails is plenty”</a>.</p>

<p>In the past, I’ve spent effort watching DHH’s videos and <a href="https://ryanbigg.com/2018/03/on-writing-software-well-2-a-review">issuing a (time-stamped) rebuttal</a>, and writing up about <a href="https://ryanbigg.com/2017/06/current-considered-harmful">a new Rails feature I would consider harmful</a>.</p>

<p style="font-size: 125%"><strong>I even <a href="https://leanpub.com/maintain-rails/">wrote a book called Maintainable Rails</a> that offers my take on how to build a maintainable Rails application. A whole 30,000 words of it!</strong></p>

<p>I am not going to follow that pattern today, even though the vanilla Rails article is <em>concerning</em>.</p>

<p>You know, if their apps were <em>maintainable</em>, then they wouldn’t need to keep re-writing them completely, yeah?</p>

<p>I digress.</p>

<p>Today, I want to cover a <em>different</em> feature of Rails that I think could be improved: strong parameters.</p>

<p>The <a href="https://guides.rubyonrails.org/action_controller_overview.html#nested-parameters">documentation for strong_parameters</a> always makes me a little confused with all of its different kinds of brackets. It feels like someone discovered Lisp and then thought it would be good to have as many brackets in Ruby, only to abandon the idea half-way.</p>

<p>Here’s a complicated example from that documentation.</p>

<pre><code class="language-ruby">params.permit(:name, { emails: [] },
              friends: [ :name,
                         { family: [ :name ], hobbies: [] }])
</code></pre>

<p>The documentation goes on to explain:</p>

<blockquote>
  <p>This declaration permits the name, emails, and friends attributes. It is expected that emails will be an array of permitted scalar values, and that friends will be an array of resources with specific attributes: they should have a name attribute (any permitted scalar values allowed), a hobbies attribute as an array of permitted scalar values, and a family attribute which is restricted to having a name (any permitted scalar values allowed here, too).</p>
</blockquote>

<p>The documentation also explains that the permitted scalar values are:</p>

<pre><code>The permitted scalar types are `String`, `Symbol`, `NilClass`, `Numeric`, `TrueClass`, `FalseClass`, `Date`, `Time`, `DateTime`, `StringIO`, `IO`, `ActionDispatch::Http::UploadedFile`, and `Rack::Test::UploadedFile`.
</code></pre>

<p>That’s quite a few permitted types!</p>

<p>How might we approach this differently? I think we could do this in a clearer fashion with a gem called <a href="https://dry-rb.org/gems/dry-schema/1.10/">dry-schema</a>. The dry-schema gem allows us to define particular schemas that our data should comply with, and like strong parameters it will automatically drop keys that are not specified in the schema itself.</p>

<h3 id="creating-the-schema">Creating the schema</h3>

<p>Let’s try creating a schema from the above strong parameters code, but this time in dry-schema. I’m also going to add an extra field here called age:</p>

<pre><code class="language-ruby">PersonSchema = Dry::Schema.Params do
  required(:name).filled(:string)
  required(:age).filled(:integer)
  required(:emails).value(array[:string]).value(min_size?: 1)
  required(:friends).array(:hash) do
    required(:name).filled(:string)
    required(:family).hash do
      required(:name).filled(:string)
    end
  end
  required(:hobbies).array(:string)
end
</code></pre>

<p>With this schema we’re clearly defining the types of the data that we expect. Now we’ve limited the type of <code>name</code> to string, so it can no longer accept a file for its value. That is probably for the best.</p>

<p>The <code>required(:friends).array(:hash)</code> syntax might hurt a little bit to read, but it means “an array of any length, where the values are all hashes”. The block of this method then defines the permitted keys within those hashes.</p>

<p>You could define this schema at the top of your controller, if you like, or in its own file at <code>app/schemas/person_schema.rb</code>. It really should depend on the context in which it is used.</p>

<p>It goes further than strong parameters, because it specifies the types expected for things such as emails and hobbies, whereas strong parameters would allow any “permitted scalar values” in there, including things such as numbers. The <code>dry-schema</code> version <em>also</em> specifies that there has to be at least one email address.</p>

<h3 id="using-a-valid-set-of-parameters">Using a valid set of parameters</h3>

<p>A hash that would pass the checks for this schema.</p>

<pre><code class="language-ruby">params = {
  name: "Ryan",
  age: 34,
  emails: ["me@ryanbigg.com"],
  hobbies: ["MTG", "Coding"],
  friends: [
    {
      name: "Dear",
      family: { name: "Reader" }
    }
  ]
}
</code></pre>

<p>We can check this with:</p>

<pre><code class="language-ruby">result = PersonSchema.(params)
</code></pre>

<p>We will get a <code>Dry::Schema::Result</code> back from this, which we can grab the output of with:</p>

<pre><code>result.output
</code></pre>

<h3 id="type-coercions">Type-coercions</h3>

<p>Another hash that would pass the checks, even though it might not look like it, is this one:</p>

<pre><code class="language-ruby">params = {
  name: "Ryan",
  age: "34",
  emails: ["me@ryanbigg.com"],
  hobbies: ["MTG", "Coding"],
  friends: [
    {
      name: "Dear",
      family: { name: "Reader" }
    }
  ]
}
</code></pre>

<p>The <code>age</code> key here is specified as a string, but the schema says the type must be an <code>integer</code>. Let’s look at what happens:</p>

<pre><code class="language-ruby">result = PersonSchema.(params)
result.output[:age] # =&gt; 34
</code></pre>

<p>The <code>Dry::Schema.Params</code> type will do its best to cooerce string parameter values to their matching Ruby counterparts. This will also work for things such as dates in the “YYYY-MM-DD” formats, too. No more needing to do a <code>Date.parse</code> if that parameter is being sent to something else, like a service object instead of a model.</p>

<h3 id="unknown-keys-are-removed">Unknown Keys are removed</h3>

<p>Like with strong parameters, if we attempt to pass an extra key:</p>

<pre><code class="language-ruby">params = {
  name: "Ryan",
  age: 34,
  emails: ["me@ryanbigg.com"],
  hobbies: ["MTG", "Coding"],
  friends: [
    {
      name: "Dear",
      family: { name: "Reader" }
    }
  ],
  very_smart: true
}
</code></pre>

<p>Then the schema will remove this additional key, proving that I am just regular smart, if that.</p>

<h3 id="re-using-schemas">Re-using schemas</h3>

<p><code>dry-schema</code> also allows us to re-use schemas. Let’s say that we have two schemas, our <code>PersonSchema</code> and another schema called <code>FriendSchema</code> that defines the shape of the friend keys. Heres how we could use those together:</p>

<pre><code class="language-ruby">FriendSchema = Dry::Schema.params do
  required(:name).filled(:string)
  required(:family).hash do
    required(:name).filled(:string)
  end
end

PersonSchema = Dry::Schema.Params do
  required(:name).filled(:string)
  required(:age).filled(:integer)
  required(:emails).value(array[:string]).value(min_size?: 1)
  required(:friends).array(FriendSchema)
  required(:hobbies).array(:string)
end
</code></pre>

<p>This is particularly helpful if you had a couple of complicated data structures that you wanted to validate at the same time, and use each of those schemas in different locations.</p>

<p>I’d like to see strong parameters do that!</p>

<h3 id="error-messages-are-provided">Error messages are provided</h3>

<p>If the hash passed in is completely invalid, like this one:</p>

<pre><code class="language-ruby">params = {}
result = PersonSchema.(params)
</code></pre>

<p>Then we can retrieve error messages that are similar to Active Model validations back out:</p>

<pre><code>=&gt; {:name=&gt;["is missing"], :age=&gt;["is missing"], :emails=&gt;["is missing"], :friends=&gt;["is missing"], :hobbies=&gt;["is missing"]}
</code></pre>

<p>On top of this, the <code>result</code> is also going to respond to <code>success?</code> with <code>false</code>, meaning we could use this in a controller action to check if the parameters are valid, before even passing them to their final destination. That might be a model (with, perhaps, it’s own validations), or it could
be another service.</p>

<hr />

<p>I’ve only scratched the surface on what <code>dry-schema</code> can do. I purposely wanted to keep this post short today to cover how it could replace strong parameters within Rails to provide a much better developer experience than that bracketed mess.</p>

<p>If you’d like to know what else dry-schema can do, make sure to check out <a href="https://dry-rb.org/gems/dry-schema/">its documentation here</a>.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Using Union Types with GraphQL Mutations in Ruby</title>
   <link href="http://ryanbigg.com/2022/05/ruby-graphql-mutations-with-union-types"/>
   <updated>2022-05-06T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2022/05/ruby-graphql-mutations-with-union-types</id>
   <content type="html"><![CDATA[<p>The <a href="https://graphql-ruby.org/mutations/mutation_classes.html">official documentation for the graphql-ruby gem</a> recommends this code for a mutation class that can either succeed or fail:</p>

<pre><code class="language-ruby">class Mutations::CreateComment &lt; Mutations::BaseMutation
  argument :body, String
  argument :post_id, ID

  field :comment, Types::Comment
  field :errors, [String], null: false

  def resolve(body:, post_id:)
    post = Post.find(post_id)
    comment = post.comments.build(body: body, author: context[:current_user])
    if comment.save
      # Successful creation, return the created object with no errors
      {
        comment: comment,
        errors: [],
      }
    else
      # Failed save, return the errors to the client
      {
        comment: nil,
        errors: comment.errors.full_messages
      }
    end
  end
end
</code></pre>

<p>I’d like to show an alternative to this that I think leads to cleaner code by using GraphQL concept called <em>union types</em>.</p>

<p>We use union types in GraphQL when we want a field to return one or more distinct types as its result. In the case of the above comment mutation, the two types of things we would like to return are either:</p>

<ul>
  <li>A comment, if the mutation was successful</li>
  <li>Errors, if the mutation was unsuccessful</li>
</ul>

<p>Let’s change that mutation above to use a union type by declaring the type at the top of the mutation, and removing the two fields:</p>

<pre><code class="language-ruby">class Mutations::CreateComment &lt; Mutations::BaseMutation
  type Types::CreateCommentResult
  argument :body, String
  argument :post_id, ID

  def resolve(body:, post_id:)
    post = Post.find(post_id)
    comment = post.comments.build(body: body, author: context[:current_user])
    if comment.save
      # Successful creation, return the created object with no errors
      {
        comment: comment,
        errors: [],
      }
    else
      # Failed save, return the errors to the client
      {
        comment: nil,
        errors: comment.errors.full_messages
      }
    end
  end
end
</code></pre>

<p>This new type will be our union type that will represent either a successful creation for a comment, or a failed one.</p>

<p>We can define this type in our <code>types</code> directory under <code>graphql</code>, in a file called <code>create_comment_result.rb</code>:</p>

<pre><code class="language-ruby">module Types
  class CreateCommentResult &lt; BaseUnion
    description "The result from attempting to create a comment"
    possible_types Types::Comment, Types::Errors

    def self.resolve_type(object, _context)
      if object[:comment]
        [Types::Comment, object[:comment]]
      else
        [Types::Errors, object]
      end
    end
  end
end
</code></pre>

<p>A union type is defined by first inheriting from <code>BaseUnion</code>. If we had common logic to share between union types in our GraphQL API, that logic would go into <code>BaseUnion</code>.</p>

<p>Inside this <code>CreateCommentResult</code> type itself, we provide a description that’ll appear in our API documentation, and inform this class what the possible types are. For this union type, we’re defining two possible types: <code>Types::Comment</code>, and <code>Types::Errors</code>.</p>

<p>When the GraphQL code runs, it will call this <code>resolve_type</code> method to determine the correct GraphQL type to use when representing the result of the mutation. This method checks if <code>object[:comment]</code> is present, and if it is the type that’ll be used is a <code>Types::Comment</code>, and we can fetch the comment from that object using <code>object[:comment]</code>. In Rails parlance, this <code>object[:comment]</code> will be an instance of the <code>Comment</code> model – a result of a successful <code>build</code> and <code>save</code>.</p>

<p>If the operation was to fail, we would instead return a <code>Types::Error</code> type, and use the resulting object as the base object for that type.</p>

<p>These two types can be defined in the <code>types</code> directory too. Let’s look at <code>CommentType</code> first, defined in <code>types/comment.rb</code>:</p>

<pre><code class="language-ruby">class Types::Comment &lt; Types::BaseObject
  field :id, ID, null: false
  field :body, String, null: false
end
</code></pre>

<p>This type is used to represent comments in our GraphQL API. It provides access to both the <code>id</code> and <code>body</code> attributes from any <code>Comment</code> instance that is represented by this API.</p>

<p>Then, the <code>Errors</code> type:</p>

<pre><code class="language-ruby">class Types::Errors &lt; Types::BaseObject
  field :errors, [String], null: false
end
</code></pre>

<p>This type represents the <code>{ comment: nil, errors: [...] }</code> hash that will be returned when a comment creation fails.</p>

<p>With these union types setup, we can write this GraphQL query that will rely on them:</p>

<pre><code>mutation {
  createComment(input: { postId: 1, body: "Hello world" }) {
    __typename
    ... on Comment {
      id
    }

    ...on Errors {
      errors
    }
  }
}
</code></pre>

<p>Firstly, we call this mutation by passing in its required arguments. After that, we fetch a field called <code>__typename</code>. This field is automatically defined, and it will return the type whatever object is returned, either <code>Comment</code> or <code>Errors</code>. When calling this GraphQL API, we can use <code>__typename</code> to determine how to act.</p>

<p>The <code>... on</code> syntax here tells GraphQL which fields we would like to use in the case of each part of the union being returned here. If it’s a comment, we will fetch just the <code>id</code>. If it’s <code>Errors</code>, we can fetch just the errors.</p>

<p>If we were to call this mutation with an empty comment body, we would see this as the result:</p>

<pre><code class="language-json">{
  "data": {
    "createComment": {
      "__typename": "Errors",
      "errors": [
        "Body can't be blank"
      ]
    }
  }
}
</code></pre>

<p>And if we were to call it with a valid body, we would see this:</p>

<pre><code class="language-json">{
  "data": {
    "createComment": {
      "__typename": "Comment",
      "id": "6"
    }
  }
}
</code></pre>

<p>When using this API (for example, within a frontend codebase), we can assert on <code>__typename</code> to determine how to show the result to a user – if it’s a <code>Comment</code>, then indicate a successful comment creation. If it’s <code>Errors</code>, then show those errors on the form.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Typed View Components with dry-types</title>
   <link href="http://ryanbigg.com/2022/03/typed-view-components"/>
   <updated>2022-03-08T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2022/03/typed-view-components</id>
   <content type="html"><![CDATA[<p>This post was originally inspired by <a href="https://twitter.com/RogersKonnor">Konnor Rogers</a>, and <a href="https://gist.github.com/ParamagicDev/5dc17dea9e8ab414d227461ae521f011">this gist from him</a>.</p>

<hr />

<p>Last year, I wrote about <a href="https://ryanbigg.com/2021/04/view-components-the-missing-link">View Components</a> for the first time. That post demonstrated how you could use View Components to bridge the gap between Ruby and React by using a View Component to build up the props for a React component.</p>

<p>Since then, I’ve joined <a href="https://fatzebra.com">Fat Zebra</a> and we’re doing a lot of work involving Rails, React and View Components.</p>

<p>One thing we’ve discovered that helps with using View Components is adding types by using the <code>dry-initializer</code> and <code>dry-types</code> to those View Components. While we have the protection of types in TypeScript, we do not have the same level of protection in Ruby. And since TypeScript only does compile-time checking, it means that we could pass a property from these Ruby View Components down to our React components where that property’s type is incorrect.</p>

<p>Take for (contrived) example, this simple component that takes in a <code>standalone</code> property.</p>

<pre><code class="language-ruby">class RefundComponent &lt; ViewComponent::Base
  attr_reader :standalone

  def initialize(standalone:)
    @standalone = standalone
  end

  def props
    {
      standalone: standalone,
      # ...
    }
  end
end
</code></pre>

<p>There’s nothing in this component that dictates the type for <code>standalone</code>. It should be a boolean. It <em>could be</em> a string, or a number, or literally any valid object in Ruby. So when this component is used in this way:</p>

<pre><code class="language-ruby">render RefundComponent.new(standalone: params[:standalone])
</code></pre>

<p>What’s going to happen here?</p>

<p>Well, if we <em>think</em> standalone is a boolean, we can expect <code>params[:standalone]</code> is going to be either <code>"true"</code> or <code>"false"</code> ,given that Rails parameters are stringified.</p>

<p>Inside our React component, we might have code like this.</p>

<pre><code class="language-tsx">{standalone ? "Standalone" : "Not Standalone"}
</code></pre>

<p>The string <code>"true"</code> does the same as the boolean <code>true</code>. The string <code>"false"</code> does not do the same as the boolean <code>"false"</code>.</p>

<p>This is completely innocent code, and the kind that we might write any old day. Nothing stopped us from writing it. In fact, TypeScript gave us <em>two</em> thumbs up when we compiled our React code. Ruby doesn’t care. Ruby’s fine as long as the syntax is correct.</p>

<hr />

<p>To prevent a mistake like this, we can use the <code>dry-initializer</code> and <code>dry-types</code> gems like this:</p>

<pre><code class="language-ruby">class RefundComponent &lt; ViewComponent::Base
  extend Dry::Initializer
  Types = Dry.Types()

  option :standalone, Types::Bool

  def props
    {
      standalone: standalone,
      # ...
    }
  end
end
</code></pre>

<p>The <code>Types</code> constant here is usually defined on a more “global” level. For example, you might define it at <code>lib/types.rb</code> for your entire application. I’ve just included it in the class here for brevity.</p>

<p>The <code>option</code> method here defines a keyword argument initializer for <code>RefundComponent</code>, so this means our component will still be able to be rendered in the same way:</p>

<pre><code class="language-ruby">render RefundComponent.new(standalone: params[:standalone])
</code></pre>

<p>But this time, if we pass it a stringly-typed <code>standalone</code> here, it will show us an error:</p>

<pre><code>"false" violates constraints (type?(FalseClass, "false") failed) (Dry::Types::ConstraintError)
</code></pre>

<p>The error message is wordy, but with enough practice (just like TypeScript!) we can learn to read these. The error message here says that the type of <code>FalseClass</code>, is not the same type as <code>"false"</code>.</p>

<p>We cannot pass the stringly-typed <code>params[:standalone]</code> here anymore.</p>

<p>Instead, we would have to convert this parameter to a boolean so that our code would work:</p>

<pre><code>render RefundComponent.new(standalone: params[:standalone] == 'true')
</code></pre>

<h3 id="but-wait-theres-more">But wait, there’s more…</h3>

<p>We can also use <code>dry-types</code> to define the types for our properties too, in case we had some complicated logic there.  Perhaps we have an amount that is returned, and we want to guarantee it’s a float by the time it gets to our React library. To spice things up, for legacy reasons the <code>amount</code> arrives at our component as a string, not a float. With this amount also comes a currency property, which is also a string.</p>

<p>Here’s how we would handle that by using another <code>dry-rb</code> library, <code>dry-struct</code>:</p>

<pre><code class="language-ruby">class RefundComponent &lt; ViewComponent::Base
  extend Dry::Initializer
  Types = Dry.Types()

  option :standalone, Types::Bool
  option :amount, Types::String
  option :currency, Types::String

  class Props &lt; Dry::Struct
    schema schema.strict

    attribute :standalone, Types::Bool
    attribute :amount, Types::Float
    attribute :currency, Types::String
  end

  def props
    Props.new(
      standalone: standalone,
      amount: amount.to_money(currency).to_f,
      currency: currency,
      # ...
    ).to_h
  end
end
</code></pre>

<p>This way, we can call <code>RefundComponent</code> with a stringified <code>amount</code>, and have <code>props</code> be the correct type:</p>

<pre><code>&gt;&gt; component = RefundComponent.new(standalone: params[:standalone] == 'true', amount: "1234", currency: "AUD")
=&gt; #&lt;RefundComponent:0x000000013e6a76a8 @amount="1234", @currency="AUD", @standalone=true&gt;
&gt;&gt; component.props
=&gt; {:standalone=&gt;true, :amount=&gt;1234.0, :currency=&gt;"AUD"}
</code></pre>

<p>If the type of <code>Props#amount</code> (once it has been coerced) wasn’t a float and instead was an integer, like this:</p>

<pre><code class="language-ruby">amount: amount.to_money(currency).to_i,
</code></pre>

<p>This code would cause this error:</p>

<pre><code>1234 (Integer) has invalid type for :amount violates constraints (type?(Float, 1234) failed) (Dry::Types::SchemaError)
</code></pre>

<p>This helps alert us to a typing issue earlier on in our code, before it even reaches our React code.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Culture and Values</title>
   <link href="http://ryanbigg.com/2021/12/culture-and-values"/>
   <updated>2021-12-09T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/12/culture-and-values</id>
   <content type="html"><![CDATA[<p>It’s been one year since I was fired.</p>

<p>The Big Boss at the time wanted everyone to work out of an office in Melbourne (because by the end of 2020, everyone thought that The Pandemic was <em>over</em>), and I was moving 250km to the west.</p>

<p>What’s more, is that I was an opinionated asshole who cared too much about things and got angry about it. The whole pandemic thing didn’t help.</p>

<p>It was the third time I had been let go from a job in just over a year. I was made redundant in November 2019 and again in April 2020. In 13 months, I had left 3 jobs. That doesn’t look so good on a resume.</p>

<p>So I thought I should change things this year – usher in a new era of stability for myself and my family… and instead undertook consultancy work which has meant that I’ve had <em>at least</em> 4 on-the-books jobs this year. But why go into consultancy after so many years of working full-time? And <em>especially</em> why go into consultancy work despite wanting all that precious stability? And in the same year that I got a mortgage?</p>

<p>Sure, the consulting money’s good (like, really good), but there’s a simpler answer: burnout.</p>

<p>I was burned out on companies, especially when it came to the culture and values they espoused. <em>Especially</em> the “F” word: “family”.</p>

<p>I became too invested in those companies, and when it was time to wrap things up there, it was traumatic and devastating. There’s no nice way to sugar-coat things.</p>

<p>I want to share a bit about the history of that trauma today, as (I guess) a way of coping with it.</p>

<p>Perhaps others out there have experienced similar situations. I share this to cope, but I also share this to say to those people that you are not alone, and things can get better.</p>

<h2 id="2019-redundancy">2019 Redundancy</h2>

<p>The job I was made redundant from 2019 was my favourite job so far. I was running a Junior Engineering Program, and had trained up about 20 different developers. I was expressly told to start plotting and scheming for a 3rd iteration of that program. Two weeks after the “plotting and scheming” meeting, I was told I would be offered a redundancy. I took the remainder of that week off to cope with the whiplash.</p>

<p>This was in July. I was slated to wrap up in November. It was a nice long goodbye.</p>

<p>I cared deeply about the company, and its mission, and its people. I forgave it for its sins and transgressions.</p>

<p>I forgave it for its office in Richmond with its oddly-named, incredibly stuffy meeting rooms. The same office that had windows that were fixed opened directly to the outside, even in Winter. The same cathedral-like office that couldn’t prioritise sound-proofing to prevent the conversations of the 150-people inside echoing off every conceivable surface.</p>

<p>I’ve almost forgiven it for the time that it decided to run a 5-day-long all-hands conference, where the days were rougly 15 hours long, but may as well have been 150 hours for how exhausted I felt at the end of it all.</p>

<p>Then November 2019 came around, and the person who did the exit interview at that company wasn’t my manager, or even a long-term HR employee. It was practically a stranger, someone who had started there <em>that very week</em> in HR and she conducted my exit interview. I had never met this person before this interview, and I haven’t seen her since.</p>

<p>I do not forgive the company for that.</p>

<p>What softened the blow was a sizable redundancy payout. One that helped me buy the house that I’m now sitting in. I like that I have a house that’s progressively getting to be more and more my own, brick by sandstone brick, and less and less the bank’s. But I digress.</p>

<p>It’s after this whole redundancy process that I came to realise that I cared too much about the company. I was <em>too invested</em> in its values, its success, its <em>culture</em>. I had tied too much of my own <em>value</em> to the company’s <em>value</em>.</p>

<p>It was devastating to be shown the door.</p>

<h2 id="april-2020-redundancy">April 2020 Redundancy</h2>

<p>Then I found a job with a company whose values I very strongly aligned with. A company that trained up junior-junior developers. People who were just getting started with their programming careers. I thought I could make a real difference here in educating the next generation of developers who were entering the industry.</p>

<p>Then a little thing called a pandemic hit. I’m sure you’ve heard of it by now. The parent company of the one I joined relied on international students for a large majority of its income. A pandemic in Australia meant closed borders (easy to enforce, as we’re a <em>giant island</em>), and closed borders meant no international students, which ultimately meant little-to-no money for that company.</p>

<p>I, along with the entire company, were told about potential redundancies happening in a staff-wide email on a <em>Monday</em> at the end of March. During this week we found out it was going to be 235 people across the whole company. I got that dreaded call back on <em>Friday</em> at 3pm. That was a particularly unproductive week, let me tell you. This time again it wasn’t my boss, or even a long-term colleague. It was some high-up HR woman who sounded absolutely exhausted.</p>

<p>About 5 minutes after this phone call, I was locked out of Slack, GitHub, and email. It was clinical and effective. I went into the office the next week and collected my things. That was the last time I was in an office.</p>

<p>I had become <em>too invested</em> again in the company’s success.</p>

<p>And I was cast out, without pity and this time without compensation.</p>

<h2 id="december-2020">December 2020</h2>

<p>With the pandemic hitting its stride by April 2020, I didn’t exactly put a lot of thought into where I wanted to go next. What I did put thought into was that I didn’t want to be made redundant again after being made redundant twice in quick succession, and that I didn’t want to lose my job during the pandemic.</p>

<p>I cared about this job, and poured my focus and attention into it. I wanted things to be <em>right</em> for our customers. A little too hard. I cared about things that I shouldn’t have cared about. I got upset when things that I thought were important were not considered important by others. I cared about creating a good working culture for the development team. I cared about replacing parts of our Backbone code with something from this decade. I cared too much. I got angry.</p>

<p>And I got fired.</p>

<h2 id="2021">2021</h2>

<p>So this year, I started out as a consultant which is a pleasant way of saying “an opinionated asshole for hire”. I could choose to work 3-month contracts with no strings attached. I didn’t <em>need</em> to care about the company culture, or get invested in its success. I needed to trade labor for dollars.</p>

<p>I got to work with a few different teams releasing some major features in Rails and Rails-adjacent tech, and even upgraded a Rails app or two. I was trusted for my opinion on things, but really worked hard on giving the opinion in a <em>nice way</em>. I joked to close friends that I should’ve hung bunting above my desk spelling out the word “PROFESSIONALISM” in giant letters. Sometimes I think I should still put it up.</p>

<p>Ultimately, I was successful in doing the consultant thing of trading labor for dollars. And leaving things better than I how I found them, just for my own moral satisfaction.</p>

<p>But, ultimately, it was lonely stuff. Working out of my house this year, by myself, with a 15-minute call for standup at the start of the day… just doesn’t tickle the social aspect of my brain in the right way. It often felt like I was an <em>interloper</em> into these projects, tossing grenades (or bouquets, depending on the mood) into projects and then skipping off into the sunset with my fat bags of consultant cash.</p>

<p>You ever walk into a meeting room, except it’s the wrong one? Well, if you like that feeling, become a consultant because that’s the feeling you get every damn day.</p>

<h2 id="interviewing-in-2021">Interviewing in 2021</h2>

<p>Around about the time that I figured out the “fucking hell, this is lonely work” thing I wrote <a href="https://ryanbigg.com/2021/07/job-hunt-q2-2021">this post</a>. I write <em>this</em> post today to provide some context, some colour, around why I sound so… bleak in that other post. It wasn’t just the pandemic.</p>

<p>At the time of that post in July, I interviewed at a number of companies. I got offered coding tests. <a href="https://ryanbigg.com/2021/07/on-coding-tests">I got angry about being offered coding tests</a>. And I refused to do them this time. Some people balked at that. I stood my ground, and was outright refused by some companies because I refused to do coding tests.</p>

<p>The other half of the interviews that companies love to do is the culture part of the interview.</p>

<p>A culture interview essentially boils down to “are you an asshole?” and, honestly, you could spend an hour reading about who I am and what I’ve done and get a pretty good idea about that. Or you could spend that hour talking to me and I’ll tell you the same thing. The best answer I can give you right now for that is: “you would probably rather hire 2021 Ryan than 2020 Ryan, and you’d <em>certainly</em> hire 2020 Ryan over 2015 Ryan”. Just wait for 2022 Ryan. Jeez that guy is good.</p>

<p>Things have improved. There are things that need improving that I am aware of. There are things that need improving that I’m not aware of. This is what makes us human. We’ll work on it together. I’ll try my damndest to not repeat the mistakes of the past and to prevent future ones.</p>

<p>A culture interview can sometimes have questions like “what value of ours do you most identify with?” and if you’re interviewing at several different companies and have either been made redundant or fired from the last three big companies you’ve worked for… chances are you’re going to be particularly burned out on that aspect. You’re not going to have done your homework on those values of this one particular company, and you’re going to flub that particular question. Like I did.</p>

<p>Later on, when <em>at least</em> 5 friends suggest that I would be really great for that company’s Developer Mentor role (a different one to the one I applied for) that they’ve been advertising for months… the job where you could <em>train junior developers and get paid to do it</em> and <em>holy fuck you’d be so good at it because this is your wheelhouse</em>…. it kinda smarts and I get to re-live the trauma of <em>failing an interview as a really experienced developer</em> again, and again, and again. All because I didn’t read the fucking list of values on their website, because I was seriously burned out on the whole “culture and values” thing.</p>

<p>Who doesn’t love re-living moments of such abject failure?</p>

<hr />

<p>To me, it is not important what the values written on a page of a company’s website are. It’s all the same bullshit.</p>

<p>What matters to me is what happens there every single day. The values are not what is written on a website. The values are the stuff <em>in between the people</em> every day. It’s the holding the proverbial bucket for the developer who’s just found That Piece of Legacy Code. It’s giving people time and space <em>away from the damn screen</em> when they need it, no questions asked. It’s allowing people to make mistakes, and not punishing them. It’s about making sure the people doing the work are treated like people.</p>

<p>These are the values that matter to me. It’s ironic that I write these values, on a page, on a website. But there you go.</p>

<h2 id="working-full-time-again">Working full-time, again</h2>

<p>I joined <a href="https://www.fatzebra.com/">a company</a> in August. I do a little bit more than “crush code” – I’m working on improving this company’s approach to frontend design and tooling. I’m working on building out a design system. And yes, I get to train up other people too. I spend a lot of my time convincing people that the scary frontend boogeyman is just code, like all the rest of the app. You can understand that, so you can understand this, too. Here’s some pretty buttons you can use.</p>

<p>I have learned a lot about becoming <em>too invested</em> in the culture and values of the companies I have worked for in the past. I still struggle with that to this day. That ever-burdensome question of: “am I becoming <em>too</em> attached here?”. Every day I measure how well I would react if today was the day I was told I was being let go. My mental “grab &amp; go bag” still sits, heavy in my brain. Would I be as upset as those three other times?</p>

<p>The trauma of being let go three times in 13 months left a deep, mental scar. I trusted people to make decisions, and those decisions were unfavourable.</p>

<p>At my current job, I get told that my work is deeply appreciated and I feel like my opinion is respected. And I share that opinion in at least what I think is a non-asshole way. And I trust people to tell me if or when I’m being one. I can still hold strong opinions around the right way to do things. But I’ve learned to share those opinions in a nicer way. They’ve even trusted me to interview and hire other people.</p>

<p>But occassionally, the trauma flares up and says “what if this, too, is all bullshit?”. That’s what counselling is for. I’m grateful that the Australian government subsidises these sessions, and even if they didn’t they’re worth more than their full price. I’ve talked through these feelings, and worked out some coping mechanisms. The trauma flares up less occasionally, and when it does I have things to bat it back with. Lights to push back the darkness. It’s forever present, lurking. But I’m armed now, and I am ready for it.</p>

<p>I wouldn’t say that I am anywhere near as invested in this company’s culture and values as I have been with previous companies. That isn’t to say that I am <em>uncaring</em> about the culture or values. I am simply not as attached. I still care about the happiness of the people around me. I reckon that’s what’s essential here. If things were to wrap up today, tomorrow or next week, I would probably cope better than those three other times.</p>

<p>I choose to work full-time again, to become <em>trusting</em> of a company again, to help with those <em>interloper</em> consultant feelings.</p>

<p>I guess that’s an indicator of personal growth. While trauma does happen, we can always <em>grow around</em> it. To come up against adversarial situations is a part of what makes us human. We are not alone in these situations, as much as it can feel this way sometimes.</p>

<p>I hope that sharing a little bit about my history and how I’ve worked through it helps you, either today or into the future.</p>
]]></content>
 </entry>
 
 <entry>
   <title>A tour of Twist</title>
   <link href="http://ryanbigg.com/2021/08/a-tour-of-twist"/>
   <updated>2021-08-11T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/08/a-tour-of-twist</id>
   <content type="html"><![CDATA[<p>When I’m writing <a href="/books">my books</a>, it’s more often than not that reviewers read and review these books on an application that I built myself called <a href="https://github.com/radar/twist-v2">Twist</a>. It looks like this:</p>

<p><img src="https://raw.githubusercontent.com/radar/twist-v2/master/preview.png" alt="Twist" /></p>

<p>In this post, I’d like to cover just one half of Twist: the backend half. There’s also a frontend half that’s just as interesting!</p>

<p>What’s most interesting about this backend application is that it is a Ruby application that is <em>not</em> a Rails application, and it is <em>not</em> a Sinatra application. While it borrows inspiration (and gems!) from the Hanami project, it is not a Hanami application. It’s a hybrid application, one that is built on top of some pretty great foundations from those Hanami gems, and also some gems from the <a href="https://dry-rb.org/">dry-rb</a> and <a href="https://rom-rb.org/">rom-rb</a> suites of gems. I’d like to spend this post covering a few key details here about Twist and its unique structure.</p>

<p>In this post I cover:</p>

<ul>
  <li>The application container object</li>
  <li>Sub-system dependencies</li>
  <li>Entities, Repositories and Relations from rom-rb</li>
  <li>Receiving webhook requests from GitHub</li>
  <li>Background jobs</li>
  <li>Transactions</li>
  <li>The GraphQL API</li>
</ul>

<p>To cover what Twist does in a nutshell: Twist receives webhook notifications from GitHub after new commits are pushed to a book’s GitHub repository. Twist then reads a book’s Markdown or AsciiDoc files and converts those formats into HTML and stores it in a database. Later on, that HTML is served out through a GraphQL endpoint in the form of books, chapters, and elements. Readers can then read the book and leave notes on the book as they go. I use these notes to improve the quality of the books I write.</p>

<p>If you want to get an idea of what working on this app is like, I’ve live streamed about 10 hours of active development on this project. <a href="https://www.youtube.com/watch?v=qWdyo3icsjU">The first episode is on Youtube here</a>.</p>

<h2 id="the-application-container">The application container</h2>

<p>The application starts off in a similar way to a Rails application. There’s a <code>config.ru</code> file that goes off and loads <code>config/boot.rb</code>. That sets up Bundler and Dotenv, configuring the gems and environment necessary for running the application. After that, we come to the application <em>container</em>.</p>

<p>An application container is a concept from the <code>dry-system</code> gem. It’s a space to define the components of your application and how they’re loaded. Twist does this with the following code:</p>

<pre><code class="language-ruby">require 'dry/system/container'
require 'dry/auto_inject'
require 'dry/system/loader/autoloading'
require 'zeitwerk'

module Twist
  class Container &lt; Dry::System::Container
    config.root = __dir__

    config.component_dirs.loader = Dry::System::Loader::Autoloading
    config.component_dirs.add_to_load_path = false
    config.component_dirs.default_namespace = 'twist'

    config.component_dirs.add "lib" do |dir|
      dir.auto_register = true
      dir.default_namespace = 'twist'
    end
  end

  Import = Dry::AutoInject(Container)
end

loader = Zeitwerk::Loader.new
loader.inflector.inflect "graphql" =&gt; "GraphQL"
loader.inflector.inflect "cors" =&gt; "CORS"
loader.push_dir Twist::Container.config.root.join("lib").realpath
loader.setup
</code></pre>

<p>When this code defines a container for our application, it specifies <code>component_dirs</code> for that application. These are directories that contain code that is useful to our application. From here, twist specifies that anything in <code>lib</code> is something we want to register as components for this application. What’s great about this is that we’ve set this application up to be autoloaded, and so things are only ever loaded when we reference them. You get this feature with Rails, sure, but you also get it in <code>dry-system</code> too.</p>

<p>That autoloading is taken care of by the <a href="https://github.com/fxn/zeitwerk">Zeitwerk</a> gem. This gem will notice when you’re referencing a constant like <code>Twist::Entities::Book</code>, and if that constant hasn’t been loaded, it will attempt to load it from the <code>lib/twist/entities/book.rb</code> file. Throughout this application, all constants follow this naming pattern of where the path to the file matches the namespacing of the constant.</p>

<p>There are two special cases for Zeitwerk here where we want to inflect some words different to how Zeitwerk might try to. For <code>GraphQL</code>, Zeitwerk would look for a directory called <code>graph_q_l</code> by default. We can inform Zeitwerk should look for a directory called <code>graphql</code> by specifying that inflection rule near the bottom of this file.</p>

<p>When this container is finalized (with a call to <code>finalize!</code> in <code>config/environment.rb</code>), it will scan through the <code>lib</code> directory and register everything underneath it as keys within the application container. As a small example of the keys registered, here’s what happens when we ask the container for its keys:</p>

<pre><code class="language-ruby">Twist::Container.keys
=&gt; ["oauth.client",
 "database",
 "authorization.book",
 "entities.book",
 "entities.book_note",
 "entities.branch",
 "entities.chapter",
 "entities.comment",
 "entities.commit",
 "entities.element",
 "entities.footnote",
 "entities.image",
 "entities.note",
 "entities.note_count",
 "entities.permission",
 "entities.reader",
 "entities.section",
 "entities.user",
 ...
</code></pre>

<p>These keys and their naming will be relevant in a minute.</p>

<h2 id="system-dependencies">System Dependencies</h2>

<p><code>dry-system</code> has a concept of system dependencies – parts of your application that you can opt-in to booting along with finalizing your application container. In Twist, we have a large <code>core</code> dependency in <code>system/boot/core.rb</code>:</p>

<pre><code class="language-ruby">
Twist::Container.boot(:core, namespace: true) do
  use :persistence

  init do
    require 'babosa'
    require 'redcarpet'
    require 'nokogiri'
    require 'pygments'
    require 'sidekiq'

    require 'dry/monads'
    require 'dry/monads/do'
  end

end
</code></pre>

<p>This file is responsible for requiring the different Ruby libraries that this application will need during its runtime.</p>

<p>The other file in this directory is called <code>persistence.rb</code>, and it defines the <code>persistence</code> system dependency:</p>

<pre><code class="language-ruby">Twist::Container.boot(:persistence) do
  init do
    require "rom-repository"
    require "rom-changeset"
    require "sequel"
  end

  start do
    container = ROM.container(:sql, Sequel.connect(ENV['DATABASE_URL']), extensions: [:pg_json]) do |config|
      config.auto_registration(File.expand_path("lib/twist"))

      # config.gateways[:default].use_logger Logger.new(STDOUT)
    end
    register(:database, container)
  end
end
</code></pre>

<p>It is possible to configure these dependencies in such a way that <code>core</code> <em>could</em> be booted separately from <code>persistence</code>, but I haven’t found a reason to uncouple these yet.</p>

<p>In <code>persistence</code>, there’s <code>require</code> statements for the persistence libraries, and then when the application starts up, a new container for ROM is created here. The container for the application that we saw earlier contains configuration for the application. The ROM container contains configuration for the database itself. This new container automatically registers ROM-specific things from <code>lib/twist</code>, which we’ll look at now.</p>

<h2 id="entities-repositories-and-relations">Entities, Repositories and Relations</h2>

<p>In order to interact with this database, Twist uses <a href="https://rom-rb.org">rom-rb</a>. Where ActiveRecord would tie everything together in the one class:</p>

<p><img src="https://ryanbigg.com/images/maintainable_rails/normal_model_clean.png" alt="Active Record" /></p>

<p>These responsibilities are split out into several distinct classes within ROM-based applications.</p>

<ul>
  <li>Entities: Ruby classes that use <code>ROM::Struct</code> to define attributes.</li>
  <li>Relations: Classes that interact with a single database table and where complicated query logic lives.</li>
  <li>Repositories: Classes that serve as an adapter layer between relations and the application as a whole.</li>
</ul>

<h3 id="entities">Entities</h3>

<p>Here’s a quick example of an entity class:</p>

<pre><code class="language-ruby">module Twist
  module Entities
    class Book &lt; ROM::Struct
      attribute :id, Types::Integer
      attribute :title, Types::String
      attribute :permalink, Types::String
      attribute :github_user, Types::String
      attribute :github_repo, Types::String

      def path
        git = Git.new(
          username: github_user,
          repo: github_repo,
        )
        git.local_path
      end
    end
  end
end
</code></pre>

<p>The attributes are defined right in the class, and so we don’t need to go skulking through <code>db/schema.rb</code> or the database itself or a <code>console</code> session to figure out what they are. We also get a type-safety of sorts here… if we attempt to assign a number to those string fields, this is what happens:</p>

<pre><code class="language-ruby">Dry::Struct::Error: [Twist::Entities::Book.new] 2 (Integer) has invalid type for :title violates constraints (type?(String, 2) failed)
</code></pre>

<p>Whereas a Rails app would just silently coerce the number into a string, <code>ROM::Struct</code> and its underlying <code>Dry::Struct</code> do not do that coercion and will warn you before you go ahead and do something you might later regret.</p>

<p>The <code>path</code> method here uses attributes from the entity to give us the path to a book on disk.</p>

<p>Note here that there is absolutely nothing to do with talking to a database in this class. Or validations. Or callbacks. The only code here is code that works with the attributes from the entity itself.</p>

<h3 id="repositories--relations">Repositories &amp; Relations</h3>

<p>Repositories are used to provide an interface layer between the relation classes that speak with the database and application-specific classes. Once data is returned from a repository, it is no longer possible to make database queries by calling additional methods on those returned objects.</p>

<p>In order to set this up to use the configuration from <code>persistence.rb</code>, Twist has a <code>Repository</code> class that imports the configuration:</p>

<pre><code class="language-ruby">module Twist
  class Repository &lt; ROM::Repository::Root
    struct_namespace ::Twist::Entities

    include Import[container: "database"]
  end
end
</code></pre>

<p>The <code>include</code> statement here uses <code>dry-auto_inject</code> to find the <code>database</code> key’s configuration, and imports it here as <code>container</code>. All ROM repositories need to know the <em>container</em> that they’re operating in, so that they’re aware of which database to speak to.</p>

<p>A quick example of a repository would be the <code>BranchRepo</code>:</p>

<pre><code class="language-ruby">module Twist
  module Repositories
    class BranchRepo &lt; Twist::Repository[:branches]
      commands :create, use: :timestamps, plugins_options: { timestamps: { timestamps: %i(created_at updated_at) } }

      def by_book(book_id)
        branches.where(book_id: book_id).to_a
      end

      def by_id(id)
        branches.by_pk(id).one
      end

      ...
</code></pre>

<p>ROM Repositories do not immediately offer us things such as <code>create</code> or <code>update</code> – we have to opt into them. That’s what’s happening here with the first line that specifies <code>commands</code> here.</p>

<p>The <code>by_book</code> and <code>by_id</code> methods here use another method called <code>branches</code>. This method is an instance of the <code>Twist::Relations::Branches</code> class and we can then call methods on that to query the database.</p>

<p>If we have particularly complicated query logic, we extract that logic out to relations. An example of this is the code from <code>NoteRepo</code>:</p>

<pre><code class="language-ruby"># rubocop:disable Metrics/AbcSize
def count(element_ids, state)
  counts = notes.counts_for_elements(element_ids, state)

  missing = element_ids.select { |id| counts.none? { |c| c.element_id == id } }
  counts += missing.map { |m| Entities::NoteCount.new(element_id: m, count: 0) }
  counts.map { |nc| [nc.element_id, nc.count] }.to_h
end
# rubocop:enable Metrics/AbcSize
</code></pre>

<p>The <code>counts_for_elements</code> method used here is defined within <code>Twist::Relations::Notes</code>:</p>

<pre><code class="language-ruby">module Twist
  module Relations
    class Notes &lt; ROM::Relation[:sql]
      schema(:notes, infer: true)

      def counts_for_elements(element_ids, state)
        where(element_id: element_ids)
        .where(state: state)
        .select { [element_id, function(:count, :id).as(:count)] }
        .group(:element_id)
        .order(nil)
        .to_a
      end
    end
  end
end
</code></pre>

<p>What’s happening here is that we’ve got <em>two</em> spots of complicated logic: one where we need to query the database for the note counts for a range of elements, and another where we need to do some massaging of that data into <code>Entities::NoteCount</code> objects. By having the code split up into repositories and relations here, we’re able to have a clear “home” for the code that talks to the database (that’s the relation) and then code that massages that data belongs in the repository. In a typical Rails application, you would throw everything together into one super method in the model.</p>

<p>This <code>count</code> method on the <code>NoteRepo</code> will return a confusing looking hash:</p>

<pre><code class="language-ruby">Twist::Container["repositories.note_repo"].count([16], "open")
=&gt; {16=&gt;1}
</code></pre>

<p>This hash is not fit for human consumption, but is later sent through an API and then made fit for human consumption. The key is the element ID, and the values are the number of notes for that element.</p>

<p>How about another example, that <em>is</em> “fit for human consumption”?</p>

<pre><code class="language-ruby">Twist::Container["repositories.branch_repo"].by_book(1)
=&gt; [
  #&lt;Twist::Entities::Branch
    id=1
    name="master"
    default=true
    book_id=1
    created_at=2021-08-11 14:59:48.203662 +1000
    updated_at=2021-08-11 14:59:48.203662 +1000
  &gt;
]
</code></pre>

<p>When we call the <code>by_book</code> method on the <code>BranchRepo</code>, that class reaches out to the <code>branches</code> relation and performs a <code>where</code> query, finding all branches for a particular book. When the data comes back from the database, it’s mapped into <code>Twist::Entities::Branch</code> objects. These entities are then very bare-bones:</p>

<pre><code class="language-ruby">[10] pry(main)&gt; ls Twist::Container["repositories.branch_repo"].by_book(1).first
#&lt;Dry::Core::Equalizer:0x00007fba268d3140&gt;#methods: freeze  hash
Dry::Core::Equalizer::Methods#methods: ==  eql?
Dry::Struct#methods: []  __attributes__  __new__  attributes  deconstruct_keys  inspect  new  to_h  to_hash
ROM::Struct#methods: fetch
Twist::Entities::Branch#methods: default  id  name
Twist::Entities::Branch#methods: book_id  created_at  updated_at
instance variables: @attributes
</code></pre>

<p>Not counting methods from <code>Object.methods</code>, there are only 13 methods available on this object. A typical Active Record model will have around 300 different methods, but that varies based on the number of attributes it has too, as it adds in meta-programmed methods like <code>title_will_change?</code> from <code>ActiveModel::Dirty</code> and friends. I think 300 methods is a lot.</p>

<h2 id="receiving-webhook-requests">Receiving webhook requests</h2>

<p>Twist’s primary purpose is to serve as a two-endpoint Rack app. The first endpoint – <code>/books/:permalink/receive</code> – is used by GitHub’s webhooks system. The second is <code>/graphql</code>.</p>

<p>GitHub notifies Twist through the “receive” endpoint whenever a book’s repository is updated. The route for this request is defined in the <code>web</code> part of Twist.</p>

<p>It’s here that it’s probably best to mention that Twist’s backend is split into two distinct parts. There’s the regular Ruby stuff, and the web stuff.</p>

<p>The “regular Ruby stuff” includes things like <code>Twist::Entities::Book</code>, a class that is used to represent data about a book within the application. The “regular” side of the application also includes the relations and repositories that we saw earlier. Let’s not also forget to mention that the “regular” directory also contains <em>transactions</em>, which are classes that perform one, and only one, transaction within the application. Things like creating a new note, or inviting a new reader to a book.</p>

<p>Over on the “web” side of the application (<code>lib/twist/web</code>), you’ll find the stuff you know and love from Rails: your router, your controllers, the actions.</p>

<p>The router is defined as a Hanami router:</p>

<pre><code class="language-ruby">module Twist
  module Web
    Router = Hanami::Router.new do
      if ENV['APP_ENV'] == "development"
        require 'sidekiq/web'
        mount Sidekiq::Web, at: '/sidekiq'
      end

      post '/graphql', to: Controllers::GraphQL::Run.new
      options '/graphql', to: Controllers::GraphQL::Run.new

      post '/books/:permalink/receive', to: Controllers::Books::Receive.new

      get '/oauth/authorize', to: Controllers::Oauth::Authorize.new
      get '/oauth/callback', to: Controllers::Oauth::Callback.new
    end
  end
end
</code></pre>

<p>As you can see from this code, routes do not route to one giant controller class with several actions inside it. Instead, each action is its own class. This concept makes it much easier to jump to the code for one particular action, without being confused about what code is relevant to which action inside a controller – like what might happen to you in a standard Rails application. An example of this is that the <code>authorize</code> and <code>callback</code> actions associated with the OAuth parts of this application are their own separate classes here.</p>

<p>We’re straying a little off track there, so let’s get back on track: the <code>/books/:permalink/receive</code> route. That route goes to the <code>Controllers::Books::Receive</code> action, which is defined in <code>lib/twist/web/controllers/books/receive.rb</code>. Note here that the path here matches the constant – this is something that Zeitwerk enforces so that it can automatically load our constant when we need it.</p>

<p>This controller starts out in an interesting way:</p>

<pre><code class="language-ruby">module Twist
  module Web
    module Controllers
      module Books
        class Receive &lt; Hanami::Action
          include Twist::Import[
            find_book: "transactions.books.find",
            find_or_create_branch: "transactions.branches.find_or_create"
          ]
</code></pre>

<p>An <em>include</em> statement at the top of a controller that isn’t doing something like <code>include ApplicationHelper</code>? This certainly seems like some sort of black magic – at least that’s what I thought when I originally saw it.</p>

<p>What this is doing is including two helpful transactions from within our application’s container. This code will find the classes registered under the keys <code>transactions.books.find</code> and <code>transactions.branches.find_or_create</code> and it will load those classes at this point. Not only are these classes loaded, but new instances of these classes are initialized at this point too. And <em>not only that</em>, but these instances are then made available through the methods <code>find_book</code> and <code>find_or_create_branch</code> within this controller.</p>

<p>This is made possible by another dry-rb gem called <code>dry-auto_inject</code>.</p>

<p>Later on this controller, we can refer to these instances and call the <code>call</code> method on these transactions by writing code such as:</p>

<pre><code class="language-ruby">book = find_book.(permalink: req.params[:permalink])
</code></pre>

<p>And:</p>

<pre><code class="language-ruby">branch = find_or_create_branch.(book_id: book.id, ref: payload["ref"])
</code></pre>

<p>It’s worth noting that similar includes / imports can be found in those transaction classes too:</p>

<pre><code class="language-ruby">module Twist
  module Transactions
    module Books
      class Find
        include Twist::Import["repositories.book_repo"]

        def call(permalink:)
          book_repo.find_by_permalink(permalink)
        end
      end
    end
  end
end
</code></pre>

<p>The benefit here of using <code>dry-auto_inject</code> is that we can quickly include dependencies from across our application into other classes. <code>dry-auto_inject</code> works by re-defining the <code>initialize</code> method wherever it is used to something similar to this:</p>

<pre><code class="language-ruby">def initialize(find_book: Twist::Container['transactions.books.find'], find_or_create_branch: Twist::Container['transactions.branches.find_or_create'])
  @find_book = find_book
  @find_or_create_branch = find_or_create_branch
end
</code></pre>

<p>This means that we <em>could</em> change away from the default values here to something else entirely. A good example of where we might like to do that is within tests. You’ll see an example of this over in <code>backend/spec/twist_web/controllers/books/receive_spec.rb</code>.</p>

<pre><code class="language-ruby">describe Twist::Web::Controllers::Books::Receive do
  let(:find_or_create_branch) do
    -&gt;(book_id:, ref:) { branch }
  end

  subject do
    described_class.new(
      find_or_create_branch: find_or_create_branch,
      ...
    )
  end
</code></pre>

<p>The test for this action immediately stubs out <code>find_or_create_branch</code> and will return a <code>branch</code> object for whatever’s passed in. Later on in the test, that variable is defined as:</p>

<pre><code class="language-ruby">let(:branch) { double(Twist::Entities::Branch, name: "master") }
</code></pre>

<p>This means that we don’t need to set up messy test data within factories – we can stub out our transactions to return simple doubles here instead. This means that the tests for this controller action are remarkably quick. In fact, by following this pattern throughout the whole application all of the application’s tests are remarkably quick! The slowest ones are ones that need to interact with a filesystem.</p>

<p>There are about 150 tests for this application so far and they take about 12 seconds to run.</p>

<p>Speaking of: when Twist receives a book, it enqueues that book for processing through one of its processor classes, either <code>Twist::Processors::Markdown::BookWorker</code> or its AsciiDoc equivalent. Let’s look at what happens then.</p>

<h2 id="background-jobs">Background jobs</h2>

<p>Receiving a webhook from GitHub takes a very short time. I really wish I could say the same for processing a book! However, there are some complexities here.</p>

<p>First, Twist needs to pull the latest changes from GitHub. By this point, Twist has only been <em>notified</em> that changes have happened – it doesn’t exactly know what’s changed. Twist runs a background job with Sidekiq that does a <code>git pull</code> on the book’s Git repository. From there, Twist will read each of the book’s chapters in a <em>separate</em> background job and convert the chapters into HTML. From there, it processes each individual HTML element using classes such as <code>Twist::Processors::Markdown::ElementProcessor</code>. I won’t go so much into this code, as it’s more Twist-specific than applicable to other codebases.</p>

<p>The complexities here involve downloading the code from GitHub, and uploading the images to S3. Each image is processed as <em>another</em> async job separate from the book and chapter async workers. The main issue here is that, for a few brief seconds, the <em>words</em> of a chapter can be available on Twist, but sometimes the images will not have finished processing.</p>

<p>In the end, what we end up with in the database is a new commit from GitHub tied to the book, and under that commit are the relevant chapters, and under those chapters their elements, such as section headings, paragraphs and images.</p>

<h2 id="transactions">Transactions</h2>

<p>Transactions are classes within Twist that perform a single operation / action / transaction. Let’s look at how a JWT is decoded within Twist.</p>

<pre><code class="language-ruby">module Twist
  module Transactions
    module Users
      class FindCurrentUser &lt; Transaction
        include Twist::Import["repositories.user_repo"]

        def call(token)
          return Failure("no token specified") if !token || token.length == 0

          token = token.split.last
          return Failure("no token specified") unless token

          payload, _headers = JWT.decode token, ENV.fetch('AUTH_TOKEN_SECRET'), true, algorithm: 'HS256'
          user = user_repo.find_by_email(payload["email"])
          user ? Success(user) : Failure("no user found")
        end
      end
    end
  end
end
</code></pre>

<p>This class inherits from <code>Twist::Transaction</code>, and that class defines some common transaction things:</p>

<pre><code class="language-ruby">module Twist
  class Transaction
    def self.inherited(base)
      base.include Dry::Monads[:result]
      base.include Dry::Monads::Do.for(:call)
    end

    def permission_denied!
      Failure("You must be an author to do that.")
    end
  end
end
</code></pre>

<p>The <code>dry-monads</code> gem here provides <code>Result</code> objects, which can be used to short-circuit the execution of transactions to bail out early if things are going wrong. In the <code>call</code> method of this transaction, we have failure cases where the token might be missing or too short, or if a user couldn’t be found that matched a provided token. We have a single <code>Success()</code> case if the user could be found here.</p>

<p>We’re able to assert on the outcome of this transaction by calling <code>.success?</code> or <code>.failure?</code> on it, as indicated by this class’s tests:</p>

<pre><code class="language-ruby">require "spec_helper"

module Twist
  describe Transactions::Users::FindCurrentUser do
    include Twist::Import[
      "transactions.users.generate_jwt",
      create_user: "transactions.users.create"
    ]

    let(:user) do
      create_user.(
        email: "me@ryanbigg.com",
        name: "Ryan Bigg",
        password: "password",
        github_login: "radar",
      ).success
    end

    let(:token) { generate_jwt.(email: user.email).success }

    it "finds a user by a given JWT token" do
      result = subject.(token)
      expect(result).to be_success
      expect(result.success).to eq(user)
    end

    it "finds no user with a nil token" do
      result = subject.(nil)
      expect(result).to be_failure
    end

    it "finds no user with a blank token" do
      result = subject.("")
      expect(result).to be_failure
    end
  end
end
</code></pre>

<p>The benefit of using <code>Success</code> and <code>Failure</code> objects from <code>dry-monads</code> is that we can easily check for the success or failure of any transaction within the application.</p>

<h2 id="graphql">GraphQL</h2>

<p>As I mentioned at the start of this post, Twist is two distinct applications – a frontend application written in TypeScript + React and a backend application written in Ruby. To get the two to communicate nicely with each other I use GraphQL. GraphQL is <em>great</em> here as we can easily define the types of objects on the Ruby side of things, and have those <em>same types</em> available in the frontend.</p>

<p>Requests come in through the router and head to the <code>Twist::Web::Controllers::GraphQL::Run</code> action. This action sets up a <code>Twist::Web::GraphQL::Runner</code> to run the queries themselves. This second class exists so that I can test GraphQL queries separate from a request / response stack if I need to.</p>

<p>Ultimately, this code path leads us to <code>twist/web/graphql/query_type.rb</code>, which defines fields and how they’re resolved for queries:</p>

<pre><code class="language-ruby">module Twist
  module Web
    module GraphQL
      class QueryType &lt; ::GraphQL::Schema::Object
        graphql_name "Query"
        description "The query root of this schema"

        field :books, [Types::Book], null: false, resolver: Resolvers::Books
</code></pre>

<p>The types are defined like this:</p>

<pre><code class="language-ruby">module Twist
  module Web
    module GraphQL
      module Types
        class Book &lt; ::GraphQL::Schema::Object
          graphql_name "Book"
          description "A book"

          field :id, ID, null: false
          field :title, String, null: false
          field :blurb, String, null: false
          field :permalink, String, null: false
</code></pre>

<p>While the resolver above is defined like this:</p>

<pre><code class="language-ruby">module Twist
  module Web
    module GraphQL
      module Resolvers
        class Books &lt; Resolver
          def resolve
            books = context[:book_repo].all
            books.select do |book|
              authorization = Authorization::Book.new(
                book: book,
                user: current_user,
                permission_repo: context[:permission_repo],
              )
              authorization.success?
            end
          end
        end
      end
    end
  end
end
</code></pre>

<p>It’s tempting to me to move most of this logic of the resolver out to a distinct <code>Twist::Transaction</code> class, but this code is only used within the resolver here. I think I would move it out to that transaction if I wanted to share it across the different parts of the application.</p>

<p>It’s important to note here that because we’re in GraphQL-land, we do as the GraphQL’ers do and read things like the <code>book_repo</code> and <code>permission_repo</code> from the context, rather than include-importing them. This then groups together all different context-related things into one variable, rather than having to chop and change between context and imported values.</p>

<p>When writing these GraphQL queries, I’ll typically start building out something in the frontend first. Once I’m happy with the structure, I’ll map that to a GraphQL query and then write a spec around it before writing the Ruby code to fulfill the query. Here’s the related spec for this <code>books</code> query:</p>

<pre><code class="language-ruby">require "requests_helper"

module Twist
  describe "Books", type: :request do
    let(:create_book) { Twist::Container["transactions.books.create"] }
    let!(:create_user) { Twist::Container["transactions.users.create"] }
    let!(:grant_permission) { Twist::Container["transactions.users.grant_permission"] }
    let!(:book) { create_book.(title: "Rails 4 in Action", default_branch: "master").success }

    let!(:user) do
      create_user.(
        email: "me@ryanbigg.com",
        password: "password",
        name: "Ryan Bigg",
      ).success
    end

    before do
      grant_permission.(user: user, book: book)
    end

    it "gets a list of books" do
      query = &lt;&lt;~QUERY
      {
        books {
          id
          permalink
          title
          defaultBranch {
            name
          }
        }
      }
      QUERY

      query!(query: query, user: user)
      expect(json_body).to eq({
        "data" =&gt; {
          "books" =&gt; [
            {
              "id" =&gt; book.id.to_s,
              "permalink" =&gt; book.permalink,
              "title" =&gt; book.title,
              "defaultBranch" =&gt; {
                "name" =&gt; "master"
              }
            }
          ]
        }
      })
    end
  end
end
</code></pre>

<p>It’s important to note here that the request specs in this application are the only place where we’re interacting with a database. I feel like this is necessary to ensure that the queries are working completely from end-to-end. If I was to stub something here, there’s no guarantee that the shape of what I’m stubbing matches exactly the shape of what would be returned by a database query.</p>

<p>So instead of hoping / praying that my stubbing is correct, I instead create real objects for books, users and permissions in this test. When the GraphQL query runs, it gets served by the real action and that queries a real (test) database and I can then assert that the data being returned here is what I intended it to be.</p>

<p>What’s really great here is that if I change the query on the frontend, I can just copy and paste it right into this spec without having to map it to something Ruby-ish. The same principle applies if I’m going the other way too. I really like that about GraphQL.</p>

<p>The final thing I’ll mention about GraphQL is that over in the <code>Rakefile</code> for this application I have a task setup to dump the GraphQL schema out:</p>

<pre><code class="language-ruby">require "graphql/rake_task"

GraphQL::RakeTask.new(
  schema_name: "Twist::Web::GraphQL::Schema",
  directory: "../graphql",
  dependencies: [:environment]
)
</code></pre>

<p>This dumps out a <code>graphql/schema.graphql</code> file as well as a <code>graphql/schema.json</code> file. These files are then read by some frontend tasks to automatically generate TypeScript types using the <code>graphql-codegen</code> library. This is then used to ensure that the types that I’ve defined in the GraphQL schema are <em>exactly</em> matching to the ones used over in the frontend. Without this, I reckon ensuring consistency between the backend and frontend applications would’ve been a major headache.</p>

<h2 id="summary">Summary</h2>

<p>So there you have it, a grand tour of the Twist application with my favourite highlights. I really enjoy working within this application, moreso than any Rails application that I’ve ever touched. And sure, that might be because I was the one who wrote this app and I’m the only one who maintains it.</p>

<p>But, really, it’s more than that.</p>

<p>The clean layers of separation between things like the entities, repositories and relations make it really easy to reason about where code should go.</p>

<p>Transactions provide me a clear way of separating out application operations away from code that might’ve otherwise gone inside actions. I can then share this code between different parts of my application easily without worrying about having to untie it from a controller’s grasp.</p>

<p>And the GraphQL API provides a clear, distinct layer between my backend and frontend application parts, while still allowing an enforcement of the datatypes across the barrier.</p>

<p>It’s really a joy to work in.</p>

<hr />

<p>If you like what you see in this post, you might also like to read my book <a href="https://leanpub.com/maintain-rails/c/opinions">Maintainable Rails</a> which is just $5 at the moment. This book demonstrates how to bring the concepts shown in this post into a brand new Rails application, ultimately leading to an application that is easier to maintain in the long-term.</p>
]]></content>
 </entry>
 
 <entry>
   <title>On coding tests</title>
   <link href="http://ryanbigg.com/2021/07/on-coding-tests"/>
   <updated>2021-07-27T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/07/on-coding-tests</id>
   <content type="html"><![CDATA[<p>As you might know, I’ve been <a href="https://ryanbigg.com/2021/07/job-hunt-q2-2021">job hunting recently</a>. I’m at the part of this step for some companies where we’ve had our initial conversation and now they want me to do a coding test.</p>

<p>But that’s okay, because it “should only take up to 3 hours to do”. Now let’s theoretically say that I’m talking with 5 companies now. That’s <em>15 hours</em> of my time, that I have to pull out of work, life or sleep, to do these coding tests. All to prove to them that I can code!</p>

<p>This strikes me as odd because I’m pretty sure I can code.</p>

<p>I’ve been employed as a developer in one way or another since 2004. That’s 17 years! I’ve had to pass other coding tests in the past to get some of those jobs. I had a lot more free time in my youth and wasn’t such a crotchety old man like I am now.</p>

<p>I’ve <a href="https://ryanbigg.com/books">written books</a> where I try to teach other people how to code. If I don’t know how to code, how could I teach other people to code? Mystery!</p>

<p>I’ve recently <a href="https://www.youtube.com/watch?v=qWdyo3icsjU">released a 6-part screencast series</a> where I demonstrate my ability to code in not one, but THREE different languages <strong>AT THE SAME TIME</strong>! I’m clearly not a 10x developer. Maybe a 3x developer?</p>

<p>I’ve even made the <a href="https://github.com/radar/twist-v2">codebase from that screencast series completely open source</a>.</p>

<p>I’m also responsible for maintaining the <a href="https://github.com/ruby-i18n/i18n">12th-most-downloaded Ruby Gem – i18n</a>. Yeah, this is code that I’ve (unlikely) written or (likely) vetted &amp; approved that’s <em>probably running in your Rails application right now</em>.</p>

<p>But no, these things don’t count for <em>anything</em> in the interview process. Maybe I’ve gone too far down the path of tying my self-worth up in these things. The way I feel is: if you don’t value these things I’ve <em>already done</em>, then you do not value me.</p>

<hr />

<p>I can read the replies now:</p>

<blockquote>
  <p>but how do we know that you really know how to code, according to our 100% bias-free baseline?</p>
</blockquote>

<blockquote>
  <p>We have subjected our other developers to this antiquated hazing ritual so why shouldn’t we subject you to the same?</p>
</blockquote>

<p>Fact is, you don’t. Some people can code really well in interviews and have had lots of practice answering how exactly you go about reversing a purple linked list uphill both ways in the snow. Some people struggle with the pressure of developing something <em>completely solo</em> and then having that scruitinised in an hour-long live-code-review session.</p>

<p>I’m personally <em>done</em> with being hazed in this way. You know I can code. I have proven this with my long tenure in this industry and the stuff I’ve put out in the world.</p>

<p>Let’s just get down to business. I’ll happily trade labour for dollars. Hold the haze. Use the books, code and screencast I’ve already put out in order to judge my abilities.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Using Ruby 2.7&apos;s new triple-dot syntax to clean up service objects</title>
   <link href="http://ryanbigg.com/2021/07/ruby-27s-new-triple-dot-syntax"/>
   <updated>2021-07-21T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/07/ruby-27s-new-triple-dot-syntax</id>
   <content type="html"><![CDATA[<p>In big Rails projects there’s been a bit of a push to move things out to <em>service objects</em>. You might recognise these from their appearance in things like controllers:</p>

<pre><code class="language-ruby">CreateBook.new.call(book_params)
</code></pre>

<p>The <code>CreateBook</code> class itself might look like this:</p>

<pre><code class="language-ruby">class CreateBook
  include Dry::Monads[:do, :result]

  def call(params)
    book_params = yield validate(params)
    create_book(book_params)
  end
end
</code></pre>

<p>In order to access that instance <code>call</code> method from the controller, we must first create an instance of this <code>CreateBook</code> class. This makes our code <em>slightly</em> messy because we must always <code>new</code> before we <code>call</code>. The <code>call</code> here <em>must</em> be an instance method because we’ve included <code>Dry::Monads</code> methods within instances of this class, as per the best-practices when using that gem.</p>

<p>However, we can tidy things up here by using Ruby 2.7’s new triple-dot syntax. This syntax is another special type of argument, used in the same place you might use positional or keyword arguments. We can use triple-dots to pass arguments from a class method down to an instance method, like in this example:</p>

<pre><code class="language-ruby">class CreateBook
  include Dry::Monads[:do, :result]

  def self.call(...)
    new.call(...)
  end

  def call(params)
    book_params = yield validate(params)
    create_book(book_params)
  end
end
</code></pre>

<p>Anytime the <code>call</code> method on the <em>class</em> is called, a new <code>CreateBook</code> <em>instance</em> is created, then those arguments from the class-level <code>call</code> are passed to the instance-level <code>call</code>. By defining this new <code>call</code> method on the class itself, we can then change our controller to this:</p>

<pre><code class="language-ruby">CreateBook.call(book_params)
</code></pre>

<p>This makes our code out to the <code>CreateBook</code> class from wherever we’re using it slightly easier, while still allowing us to create &amp; use instances of <code>CreateBook</code> if we wish. One particular case where that might come in handy is if you wanted to inject a dependency here:</p>

<pre><code class="language-ruby">CreateBook.new(book_repository: book_repo).call(book_params)
</code></pre>

<p>But that’s a story for another day.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Job Hunt Q2 2021</title>
   <link href="http://ryanbigg.com/2021/07/job-hunt-q2-2021"/>
   <updated>2021-07-19T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/07/job-hunt-q2-2021</id>
   <content type="html"><![CDATA[<p>After <a href="https://ryanbigg.com/2021/04/finding-a-new-contract-gig">wrapping up a contract</a> earlier in the year, I wrote a post about how I looked for a future job. Now it’s around about the time that <em>that</em> job is wrapping up. So why not write another post about this hunt? Maybe there are some things that are different.</p>

<p>Last time I pitched myself as a “mercenary developer wizard”. While I enjoy developing code, nothing brings more joy than developing <em>people</em>. Running the Culture Amp JEP was some of the most fun-at-work I’ve had. I would love to do that stuff again. So I’ve been pitching myself this time as someone who would rather be developing people, than developing code. I could definitely do both!</p>

<p>The appetite for this sort of work has been incredibly lacking. It appears from my perspective that more companies are <em>still</em> more interested in hiring senior “mercenary developer wizards” who can “crush code”, than training up <em>any</em> developers at all.</p>

<p>I’ve been <a href="https://ryanbigg.com/2019/09/hiring-juniors-2019">banging the drum around hiring juniors</a> for almost a decade. For the status quo to remain the same for this time is disheartening. Perhaps the developer drought is not severe enough for companies to act. The impetus is not strong enough. <em>Despite</em> all these companies being so ravenously thirsty for senior developers.</p>

<p>I dearly, desperately want a job where I am not <em>just</em> somebody who can crush code, but someone who gets to work with other people to improve their skills. That’s my jam. That’s where I get the joy.</p>

<p>But, fine. Okay. That job doesn’t (seemingly) exist.</p>

<p>I need to be real.</p>

<p>So I’ll just go and pick up a senior dev role at some shop somewhere, “crush code” and earn a paycheck so I can pay my mortgage.</p>

<p>I’m disheartened by the current outcomes from the current iteration of the job hunting process, but things have changed before and might change again.</p>

<p>Always the next step.</p>
]]></content>
 </entry>
 
 <entry>
   <title>How I found a new contract gig</title>
   <link href="http://ryanbigg.com/2021/04/finding-a-new-contract-gig"/>
   <updated>2021-04-29T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/04/finding-a-new-contract-gig</id>
   <content type="html"><![CDATA[<p>I’ve resolved this year to work as a developer-for-hire / contractor / sole-trader / mercenary developer wizard. This decision came after what was frankly an unmitigated disaster of a year-and-a-bit with two redundancies in a row topped off with being fired. Thanks, 2020. Go fuck yourself.</p>

<p>As a “mercenary developer wizard”, I talk to people, we agree to work together for a period of time, we do the work, we make sure everyone’s happy with the work, then they pay me money. Sometimes I’ll tweet the odd rant about how Rails is bad, even though it pays all my bills. It’s a neat arrangement.</p>

<p>Recently, I’ve had to start looking for work again, this time due to a contract wrapping up. No, I wasn’t fired <em>this time</em>. We just had a discussion and decided we did almost everything we set out to do together. Amicable!</p>

<p>It’s a sellers’ market out there at the moment. I have joked in the past while working on the 10th floor of an office building that I could sit at my desk, tweet that I was looking for work, and by the time I was out the front door of the lobby I’d have at least one offer. While this hasn’t yet played out in truth, it’s a bit like that. Fastest “lead time” to being approached for a job was 28 minutes after an initial message.</p>

<p>So I started my hunt about 2 weeks ago, putting messages out on Twitter, Linked In, and three local Australian Developer Slack groups.</p>

<blockquote>
  <p>Hello! I’m looking for my next contract starting after May 7th. Remote only, based in Warrnambool. Can code React / TypeScript / CSS / Ruby / Elixir, etc. ~15 years experience. I care about reliable software, up-skilling the team that I join, and leaving things better than I how I found them.</p>

  <p>There’s a bit more history here: <a href="https://ryanbigg.com/work">https://ryanbigg.com/work</a>.</p>

  <p>Happy to talk in DM or via email: me@ryanbigg.com</p>
</blockquote>

<p><strong>Within those 2-and-a-bit weeks, I received 12 offers for future contracts.</strong></p>

<p>See? Sellers’ market.</p>

<p>Having no particular allegiance to an industry makes it particularly hard to choose where to go next. However, there’s some places I could exclude right off the bat by using a list I have written up:</p>

<ul>
  <li>Cryptocurrency - Fancy ponzi scheme that does nothing good for the world</li>
  <li>Advertising / marketing  — slimy.</li>
  <li>Betting / Gambling — I don’t like gaming other people’s addictive behaviours.</li>
  <li>Smoking / Vaping — I find smoking in all forms extremely anti-social.</li>
  <li>Real Estate - I’ve had enough dealings with real estate agents, thank you.</li>
  <li>Working on an entire team with people like me (white, straight, male)</li>
</ul>

<p>While that helped to cull <em>some</em> of the list, I was still left with about 7.</p>

<p>What happens next is that reply with a standard professional “no thanks” to those who I’ve “culled”, even though my heart wants to say things like “AW HELL NAH” and “not in a million years, bucko”. Best to reply professionally and they go on their merry way than to start a fight with some internet stranger.</p>

<p>So then what I need to do is actually <em>talk to people</em>. If you’re a developer and you’re reading this you might have just had a cold shiver. I know, I know. Talking to people. Over the phone. EWWW. Part of doing business as a consultant. Must be done. Like the washing up and flossing your teeth.</p>

<p>What I find out here is a few things:</p>

<ul>
  <li>Are you okay with me working only 4 days a week?</li>
  <li>Are you okay with me working remotely from Warrnambool, Victoria?</li>
  <li>Are you okay with me not being able to come into your office, ever?</li>
  <li>What’s the project?</li>
  <li>How is it helping to improve the world?</li>
  <li>What’s the potential duration of our engagement?</li>
  <li>How big is the team?</li>
  <li>Who’s on the team? What’s the mix of seniority?</li>
  <li>What’s the tech stack look like?</li>
  <li>How’s the code deployed to production?</li>
  <li>How’s the work managed / triaged / approved?</li>
  <li>(And if I’m feeling cheeky) What’s hard about working there?</li>
</ul>

<p>The first 3 questions here are big deal-breakers. I enjoy spending a day of my week free to do writing and chores and then spending the weekend doing things with my family. The Warrnambool thing is… well, it’s where I live. And commuting <em>ever</em> into an office is a dealbreaker as I’m solo-parenting a 4-year-old, 4-days-a-week and I need to be there for kindergarten drop-off in the morning and pickup in the evening. I really don’t think she’ll want to be waiting for daddy’s train to get back at 10pm at night, do you?</p>

<p>These initial questions were not okay for some clients, and them’s the breaks. Some people want full-time, some people want hybrid-remote. That’s okay, we can talk about it and say “not yet” and go no further.</p>

<p>This time around I’ve put a bit of an emphasis on the team composition + size, as I want to spend more time working with more people than I have done thus far for my contracting gig. A bigger team “ranked higher” in my scoring for this round.</p>

<p>The tech stack / deployment questions give me a bit of data which I like to think of similar to a <a href="https://en.wikipedia.org/wiki/Kardashev_scale">Kardashev Scale</a>. Things I look for here are:</p>

<ul>
  <li>Card kickoffs</li>
  <li>Software used for tracking work (ala Jira / Trello / etc.)</li>
  <li>Retrospective frequency</li>
  <li>Sprint duration</li>
  <li>How is tech debt prioritised?</li>
  <li>Is there one shared staging environment, or can you deploy a pull request to its own staging environment?</li>
  <li>Is there more than one frontend framework at play?</li>
</ul>

<p>This information gives me an idea of how (dys)functional things are currently, and gives me a good idea of where I could potentially help to improve things. Every tech company is dysfunctional at <em>something</em>, and so I try and drag it out of people during the interview phase first, before I find out about it while working there. Because I will find out.</p>

<p>All of this above information goes into a huge database (read: cyclone) in my brain and mixes around in there for days on end.</p>

<p>In particularly this time around I’m looking for:</p>

<ul>
  <li>A team larger than 2.</li>
  <li>Comprised of a mix of skill levels (because there’s some training opportunities there!)</li>
  <li>A team that can rely on each other to get things done, and relies on each others’ skills</li>
  <li>Solving a real-world, real-human problem (<em>not fucking cryptocurrency</em>)</li>
  <li>A tech stack that’s cared for and maintained</li>
</ul>

<p>Ultimately, this helped it narrow it down from <em>7</em> to <em>1</em>.</p>

<p>Then I spent more time thinking about it by asking myself questions like:</p>

<ul>
  <li>Would I feel proud to have worked here after 3-6 months?</li>
  <li>Would I want to <em>continue</em> working here after that time, if it was offered?</li>
  <li>If I told people what I was working on, would it matter to them? Would they see the utility of it?</li>
</ul>

<p>And that really helped me make the final decision and to know that this was the right decision to make.</p>

<p>So on May 10th, I’ll start working at a new gig, still writing Rails (and tweeting about it) and some TypeScript / React for the next 3 months, working on a mid-sized team, helping everyone get to where we need to be. And possibly longer than that!</p>
]]></content>
 </entry>
 
 <entry>
   <title>View Components: The Missing Link</title>
   <link href="http://ryanbigg.com/2021/04/view-components-the-missing-link"/>
   <updated>2021-04-07T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/04/view-components-the-missing-link</id>
   <content type="html"><![CDATA[<p>There has been an uptick in making Rails play nice with React recently, made possible by gems such as <a href="https://github.com/reactjs/react-rails">react-rails</a>. The <code>react-rails</code> gem allows you to inject React components into your Rails views like this:</p>

<pre><code class="language-erb">&lt;%= react_component("HelloWorld", { greeting: "Hello from react-rails." }) %&gt;
</code></pre>

<p>The first argument here is the component name, and the hash at the end is the props that get passed down to the component.</p>

<p>This gem serves a very useful purpose, but I think there’s a missing link here and I want to show you what that link is, and how best to leverage it.</p>

<h3 id="complicated-props-crowd-up-the-view">Complicated props crowd up the view</h3>

<p>Sometimes, we want to pass a bunch of props through to a React component. Maybe it starts out as one prop and then grows to ten props. This can get really messy:</p>

<pre><code class="language-erb">&lt;%= react_component("UserPicker", { users: @users.map { |user| { value: user.id, label: user.name }} }, selectedUserIds: @selected_user_ids }) %&gt;
</code></pre>

<p>As a component grows in complexity, the amount of Ruby in the view continues to grow and grow. Views are sometimes treated like a dumping ground: “well, this <em>can’t</em> go in the model and it <em>shouldn’t</em> go in the controller… guess I’ll just leave it here in the view!”</p>

<p>Yes, this could be more clearly written with some line breaks:</p>

<pre><code class="language-erb">&lt;%= react_component("UserPicker", {
  users: @users.map do |user|
    { value: user.id, label: user.name }
  end,
  selectedUserIds: @selected_user_ids
}) %&gt;
</code></pre>

<p>But that still feels quite clunky!</p>

<h3 id="enter-view-components">Enter, view components</h3>

<p>GitHub, has released a gem called <a href="https://github.com/github/view_component/">view_component</a> which aims to solve this problem in a neat way. The <code>view_component</code> gem defines new classes where you can put complicated view logic, and separates those views into their own directory too.</p>

<p>Let’s take our <code>UserPicker</code> component from above. This now becomes a class called <code>UserPickerComponent</code>, and lives at <code>app/components</code>:</p>

<pre><code class="language-ruby">class UserPickerComponent &lt; ViewComponent::Base
  attr_reader :users, :selected_user_ids

  def initialize(users:, selected_user_ids:)
    @users = users
    @selected_user_ids = selected_user_ids
  end

  def props
    user_props = @users.map { |user| { value: user.id, label: user.name } }

    {
      users: user_props,
      selectedUserIds: @selected_user_ids
    }
  end
end
</code></pre>

<p>That’s much nicer! Our Ruby code is now where it belongs: in a <em>Ruby</em> file. The code that converts the users to an array-of-hashes with <code>value</code> and <code>label</code> key now feels at home in this file and has stopped clogging up our ERB file.</p>

<p>But where’s our ERB code that renders this React component? Isn’t that back over in <code>app/views</code>? Well, yeah it is! But we can move that code now into the <em>other half</em> of <code>view_component</code>, a special view component ERB file at <code>app/components/user_picker.html.erb</code>:</p>

<pre><code class="language-erb">&lt;%= helpers.react_component "UserPicker", **props %&gt;
</code></pre>

<p>View component renders components using a combination of the Ruby class and the ERB template, both named the same.</p>

<p>To access the <code>react_component</code> helper, we need to use the <code>helpers</code> method provided by <code>view_component</code>. But there’s not much difference here to what we had earlier in a view.</p>

<p>The main thing to note is that our Ruby code now lives in a Ruby file, and the code to render the React component lives over in the component’s view. If we had any additional HTML that was required to be wrapped around this component, this is where it would belong too. I’ve left that out to make things simple here.</p>

<p>If this is the only line of code that would be in our view, we can instead define a <code>call</code> method on the component class:</p>

<h3 id="rendering-a-view-component">Rendering a view component</h3>

<p>With the Ruby and ERB nicely separated into a view <em>component</em>, it’s time to add that code back to our view. We will first need to initialize the component in the controller action:</p>

<pre><code class="language-ruby">def new
  @user_picker_component = UserPickerComponent.new(
    users: @users,
    selected_user_ids: @selected_user_ids,
  )
end
</code></pre>

<p>Then we can render the component, just like we would render a partial, by calling <code>render</code> in the view for the action:</p>

<pre><code class="language-erb">&lt;%= render(@user_picker_component) %&gt;
</code></pre>

<p>And there you have it, a clear separation between the responsibilities for rendering a React component within a Rails application. We now have:</p>

<ul>
  <li>The controller action: responsible for collection information based on the request, and prepares the component</li>
  <li>The view: tells Rails where we want to put the component</li>
  <li>The component Ruby class: container for any Ruby code that we need to run <em>before</em> rendering our React component, but <em>after</em> the controller has done its duty</li>
  <li>The component view file: a clearly separated file that concerns itself with only rendering a React component</li>
</ul>

<h3 id="translations">Translations</h3>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">How are people taking i18n translations and making them available to React components these days?</p>&mdash; Ryan Bigg (@ryanbigg) <a href="https://twitter.com/ryanbigg/status/1379259002731646979?ref_src=twsrc%5Etfw">April 6, 2021</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>A few days ago, I started experimenting with the right ways to pass translations down to these React components from Ruby.</p>

<p>A few replies to the above tweet were along the lines of “just load all 644kb of JSONified I18n translations on every page load! Your users will love you!” and if this is supposed to be the latest-and-greatest of web development please let me off this wild ride.</p>

<p>Having a view component means that we have somewhere that we can run calls to <code>I18n.t</code>, and then pass these as strings through to our React component. Here, let’s have a look:</p>

<pre><code class="language-ruby">class UserPickerComponent &lt; ViewComponent::Base
  attr_reader :users, :selected_user_ids

  def initialize(users:, selected_user_ids:)
    @users = users
    @selected_user_ids = selected_user_ids
  end

  def props
    user_props = @users.map { |user| { value: user.id, label: user.name } }

    {
      users: user_props,
      selectedUserIds: @selected_user_ids
      translations: translations
    }
  end

  private

  def translations
    scope = "users.picker"

    {
      selectAUser: helpers.t("select_a_user", scope: scope)
    }
  end
end
</code></pre>

<p>In the component file, we’re now defining an extra method called <code>translations</code>. This is then going to add one extra prop to our React component, and definitely <em>won’t</em> be sending 664kb of JSONified I18n translations to our users.</p>

<p>To access these translations in the component, we access them the same as any other property:</p>

<pre><code class="language-tsx">const UserPicker = ({ translations, users, seelectedUserIds}) =&gt; {

  return (
    // ...
    &lt;p&gt;{translations.selectAUser}&lt;/p&gt;
  )
}
</code></pre>
]]></content>
 </entry>
 
 <entry>
   <title>The Bikeshed</title>
   <link href="http://ryanbigg.com/2021/03/the-bikeshed"/>
   <updated>2021-03-29T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/03/the-bikeshed</id>
   <content type="html"><![CDATA[<p>Hello.</p>

<p>This is a meeting to discuss the bike shed project. I called this 2.5hr long meeting (running until 1pm) on a Monday so we can start the week by deciding the way forward for the bike shed project.</p>

<p>As the senior consultant here I have some ideas.</p>

<p>The previous bike shed colour did not test well with our beta users and we were particularly ravaged by that one guy on Twitter in an extensive 46-tweet thread. Turns out, chatruese is his ex-wife’s favourite colour. Due to the above reasons, we will be deciding on a new colour for the bike sheds.</p>

<p>We are A/B testing new colours with a focus group that is including not only bike riders but also drivers, motorbike riders and those people with the electronic skateboards. The upcoming Bike Shed 2.0 project will be catering for their needs too.</p>

<p>Dave 3 from our consulting team has determined that the previous consultants did a poor job architecting the bike shed and as such it is not up to code. Daves 2 through 5 recommend a rebuild, while Daves 1 and 6 are still on the fence. That is, they’re on BAU work for the Fence Alpha release that was due out a week and a half ago.</p>

<p>Dave 3 estimates the rebuild of the bike shed will take approximately 3 months, which coincidentally is two weeks longer than our contract lasts for. We will talk to the management here about renewing our contract for another 12 months.</p>

<p>Are there any questions before we begin?</p>
]]></content>
 </entry>
 
 <entry>
   <title>Maintainable Rails</title>
   <link href="http://ryanbigg.com/2021/03/maintainable-rails"/>
   <updated>2021-03-23T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/03/maintainable-rails</id>
   <content type="html"><![CDATA[<p><em>This is the Preface from my book, <a href="https://leanpub.com/maintain-rails">Maintainable Rails</a>, available on Leanpub for half-price ($10USD) for the next month. Maintainable Rails demonstrates how to separate out the distinct responsibilities of a Rails application into smaller classes, leading to a more maintainable Rails application architecture.</em></p>

<hr />

<p>When Rails came out, it was revolutionary. There was an order to everything.</p>

<p>Code for your business logic or code that talks to the database <em>obviously</em>
belongs in the model.</p>

<p>Code that presents data in either HTML or JSON formats <em>obviously</em> belongs in
the view.</p>

<p>Any special (or complex) view logic goes into helpers.</p>

<p>The thing that ties all of this together is <em>obviously</em> the controller.</p>

<p>It was (and still is) neat and orderly. Getting started with a Rails
application is incredibly easy thanks to everything having a pre-assigned home.</p>

<p>The Rails Way™ enforces these conventions and suggests that this is the
One True Way™ to organise a Rails application. This Rails Way™ suggests that,
despite there being over a decade since Rails was crafted, that there still is
no better way to organise an application than the MVC pattern that Rails
originally came with.</p>

<p>While I agree that this way is still extremely simple and great for <em>getting
started</em> within a Rails application, I do not agree that this is the best way to
organise a Rails application in 2021 with long-term maintenance in mind.</p>

<p>As a friend of mine, <a href="https://twitter.com/bjeanes">Bo Jeanes</a> put it neatly once:</p>

<blockquote>
  <p>Code is written for the first time only once.</p>

  <p>Then there is anywhere between 0 and infinite days of having to change that code, understand that code, move that code, delete that code, document that code, etc. Rails makes it easy to write that code and to do some of those things early on, but often harder to do all the those things on an ongoing basis.</p>

  <p>We benefit by being patient in that first period and maybe trading off some of that efficiency for a clarity and momentum for the <em>life</em> of the project.</p>
</blockquote>

<p>A decade of Ruby development has produced some great alternatives to Rails’
MVC directory structure that are definitely worthwhile to consider.</p>

<p>In this book, I want to show an <em>alternative</em> viewpoint on how a Rails
application should be organised in order to increase its maintainability.</p>

<p>These are the best pieces that I’ve found to work for me and others.</p>

<p>This research for how to construct a better Rails application comes out of 15 years worth of developing Rails applications.</p>

<p>To best understand why this alternative architecture is a better approach, we must first understand the ways in which Rails has failed.</p>

<h2 id="where-rails-falls-down">Where Rails falls down</h2>

<p>The Original Rails Way™ falls down in at least three major areas in my opinion. Three major areas that have to do with organization. Coincidentally (or not), these three areas are the major highlights of the way Rails suggests you organize applications: models, controllers, and views.</p>

<p>Let’s start with controllers.</p>

<h2 id="messy-controllers">Messy controllers</h2>

<p>The controller’s actions talk to the model, asking the model to create, read, update or delete records in a database. And then this controller code might do more: send emails, enqueue background jobs, make requests to external services. There is no pre-determined, widely agreed-upon location for this logic; the controller is the de facto place. A controller action can often have request logic, business logic, external API calls and response logic all tied up in the one method, typically inside the action itself.</p>

<p>If this logic is not inside of the actions themselves, it is then likely found in private methods at the bottom of the controller. This leads to a common anti-pattern seen in Rails applications, one called the “iceberg controller”. What appears to be a small handful of clean actions is actually masking 100+ lines of private methods defined underneath. It is not immediately clear from scanning through these private methods which private method is used in which action. Or even if they <em>are</em> used at all!</p>

<p>Testing all these intertwining parts individually is hard work. To make sure that it all works together, you often have to write many feature and/or request tests to test the different ways that the controller action is called and utilized. The logic of the controller’s actions – those calls out to the model – get intimately acquainted with the logic for handling the request and response for that action. The lines between the incoming request, the business logic and the outgoing response become blurred. The controller’s responsibilities are complex because there is no other sensible place for this code to go.</p>

<h2 id="the-problems-with-active-record-models">The problems with Active Record Models</h2>

<p>Controllers are bad, but models are worse. In order to remove complexity from controllers, it has been suggested to move that logic to the models instead – the “Fat model, skinny controller” paradigm.</p>

<p>An Active Record model is responsible for <em>at least</em> the following things:</p>

<ul>
  <li>Mapping database rows to Ruby objects</li>
  <li>Containing validation rules for those objects</li>
  <li>Managing the CRUD operations of those objects in the database (through
inheritance from <code>ActiveRecord::Base</code>)</li>
  <li>Providing a place to put code to run before those CRUD operations (callbacks)</li>
  <li>Containing complicated database queries</li>
  <li>Containing business logic for your application</li>
  <li>Defining associations between different models</li>
</ul>

<p>If you were to colour each responsibility of your model, it might look something like this:</p>

<p><img src="/images/maintainable_rails/normal_model_clean.png" alt="Normal model" /></p>

<p>Or really, it might look like this:</p>

<p><img src="/images/maintainable_rails/normal_model.png" alt="Normal model" /></p>

<p>In traditional Rails models, all of this gets muddled together in the model,
making it very hard to disentangle code that talks to the database and code
that is working with plain-Ruby objects.</p>

<p>For instance, if you saw this code:</p>

<pre><code>class Project &lt; ApplicationRecord
has_many :tickets

  def contributors
    tickets.map(&amp;:user).uniq
  end
end
</code></pre>

<p>You might know <em>instinctively</em> that this code is going to make a database call
to the <code>tickets</code> association for the <code>Project</code> instance, and then for each of
these <code>Ticket</code> objects it’s going to call its <code>user</code> method, which will load a
<code>User</code> record from the database.</p>

<p>Someone unfamiliar with Rails – like, say, a junior Ruby developer with very
little prior Rails exposure – might think this is bog-standard Ruby code
because that’s <em>exactly</em> what it looks like. That is what Rails is designed to look like. There’s something called
<code>tickets</code>, and you’re calling a <code>map</code> method on it, so they might guess that
<code>tickets</code> is an array. Then <code>uniq</code> further indicates that. But <code>tickets</code> is an
association method, and so a database query is made to load all the associated
tickets.</p>

<p>This kind of code is very, very easy to write in a Rails application because
Rails applications are intentionally designed to be easy. <a href="http://youtu.be/Gzj723LkRJY">“Look at all the
things I’m <em>not</em> doing”</a> and <a href="http://rubyonrails.org/doctrine/#provide-sharp-knives">“provide sharp
knives”</a> and all that.</p>

<p>However, this code executes one query to load all the <code>tickets</code>, and then one
query <em>per ticket</em> to fetch its users. If we called this method in the console, then the query output might look like this:</p>

<pre><code>Project Load (0.2ms)  SELECT  "projects".* FROM "projects" ORDER BY "projects"."id" ASC LIMIT ?  [["LIMIT", 1]]
Ticket Load (0.1ms)  SELECT "tickets".* FROM "tickets" WHERE "tickets"."project_id" = ?  [["project_id", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 1], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 2], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 3], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 1], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 2], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 3], ["LIMIT", 1]]
</code></pre>

<p>This is a classic N+1 query, which Rails does not stop you from doing. It’s a
classic Active Record footgun / sharp knife. And this is all because Active Record makes it
<em>much</em> too easy to call out to the database. This code
for <code>Project#contributors</code> combines business logic intent (“find me all the
contributors to this project”) with database querying and it’s <em>the</em> major
problem with Active Record’s design.</p>

<p>What’s worse, is that you can make a database call <em>wherever a model is used in a Rails application</em>. If you use a model in a view, a view can make a database call. A view helper can. Anywhere! Rails’ attitude to this is one of “this is fine”, because they provide sharp knives and you’re supposed to trust the “omakase chefs” of the Rails core team. Constant vigilance can be exhausting, however.</p>

<p>Database queries are cheap to make because Active Record makes it so darn
easy. When looking at the performance of a large, in-production Rails
application, the number one thing I come across is slow database queries
caused by methods just like this. Programmers writing innocent looking Ruby
code that triggers not-so-innocent database activity is something that I’ve
had to fix too many times within a Rails application.</p>

<p>Active Record makes it way too easy to make calls to the database. Once these
database calls are ingrained in the model like this and things start depending
on those calls being made, it becomes hard to refactor this code to reduce
those queries. Even tracking down where queries are being made can be
difficult due to the natural implicitness that <em>some</em> method calls produce
database queries.</p>

<p>Thankfully, there are tools like <a href="https://appsignal.com">AppSignal</a>, <a href="https://skylight.io">Skylight</a> and <a href="https://newrelic.com">New
Relic</a> that point directly at the “smoking guns” of
performance hits in a Rails application. Tools like these are invaluable. It
would be nice to not need them so much in the first place, however.</p>

<p>The intention here with the <code>contributors</code> method is very innocent: get all the
users who have contributed to the project by iterating through all the tickets
and finding their users. If we had a <code>Project</code> instance (<a href="https://github.com/rails/rails">with thousands of
tickets</a>), running that contributors method
would cause thousands of database queries to be executed against our database.</p>

<p>Of course, there is a way to make this all into two queries through Rails:</p>

<pre><code>class Project &lt; ApplicationRecord
  def contributors
    tickets.includes(:user).map(&amp;:user).uniq
  end
end
</code></pre>

<p>This will load all the tickets <em>and</em> their users in two separate queries,
rather than one for tickets and then one for each ticket’s user, thanks to the
<em>power of eager loading</em>. (Which you can <a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">read more about in the Active Record
Querying
guide</a>.)</p>

<p>The queries look like this:</p>

<pre><code>Ticket Load (0.4ms)  SELECT "tickets".* FROM "tickets" WHERE "tickets"."project_id" = ?  [["project_id", 1]]
User Load (0.4ms)  SELECT "users".* FROM "users" WHERE "users"."id" IN (1, 5)
</code></pre>

<p>Active Record loads all the ticket objects that it needs to, and then it issues
a query to find all the users that match the <code>user_id</code> values from all the
tickets.</p>

<p>You can of course not load all the tickets at the start either, you could load
only the 100 most recent tickets:</p>

<pre><code>class Project &lt; ApplicationRecord
  def contributors
    tickets.recent.includes(:user).map(&amp;:user).uniq
  end
end

class Ticket &lt; ApplicationRecord
  scope :recent, -&gt; { limit(100) }
end
</code></pre>

<p>But I think this is still too much of a mish-mash of database querying and
business logic. Where is the clear line between database querying and business
logic in this method? It’s hard to tell. This is because Active
Record <em>allows</em> us to do this sort of super-easy querying; intertwining
Active Record’s tentacles with our business logic.</p>

<h2 id="views">Views</h2>

<p>Views in a typical Rails application are used to define logic for how to present data from models once this data has been fetched by controllers.</p>

<p>We’ve already discussed how Active Record allows you to execute additional queries in any context that a model is used. Typically additional queries like the <code>tickets</code> and <code>contributors</code> ones above will be executed in a view. There’s no clear barrier between models and views to prevent this from happening.</p>

<p>This sort of “leakage” makes it very hard for views to be used in complete isolation from a database. The moment a view uses a model is the moment that the view is now potentially tied to a database. For example: could you look at a view and quickly know how many, if any, database queries were being executed? Probably not.</p>

<p>To define any sort of Ruby logic for views, Rails recommends using view helpers. Perhaps we want to render a particular avatar for users:</p>

<pre><code>module UsersHelper
  def avatar
    image_tag(user.avatar_url || "anonymous.png")
  end
end
</code></pre>

<p>And then we were to use this in our view over at <code>app/views/projects/show.html.erb</code>:</p>

<pre><code>&lt;ul&gt;
  &lt;% @project.tickets.each do |ticket| %&gt;
    &lt;li&gt;&lt;%= avatar(ticket.author) %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This code is defined in a helper file at <code>app/helpers/users_helper.rb</code>, but is used in a completely separate directory, under a completely different namespace. The distance between where the code is <em>defined</em> and where it is <em>used</em> is very far apart.</p>

<p>On top of all that, helpers are then shared across <em>all</em> views. So while the helper is defined in <code>UsersHelper</code>, it will be available for <em>all</em> views. If you define a helper in <code>UsersHelper</code>, then it is also available under views at <code>app/views/tickets</code>, or <code>app/views/projects</code>, too.</p>

<p>Because of this “wide sharing” of view helpers, we don’t know if changing it is going to have ramifications elsewhere in our application. If we change it for this <em>one</em> context, will it potentially break other areas? We cannot know without looking through our code diligently.</p>

<h3 id="presenters">Presenters</h3>

<p>A common way to approach solving this problem is through the <em>presenter</em> pattern. Presenters define classes that then “accentuate” models. They’re typically used to include presentational logic for models – things that would be “incorrect” to put in a model, but okay to put in a view.</p>

<p>By using a presenter, we have a clear indicator of where the presenter’s method is used: look for things like <code>UserPresenter.new(user)</code>, and then that’ll be where it is used.</p>

<p>Here’s our <code>avatar</code> example, but this time in a presenter:</p>

<pre><code>class UserPresenter
  def avatar
    image_tag(user.avatar_url || "anonymous.png")
  end
end
</code></pre>

<p>To use this, we would then need to initialize a new instance of this presenter per user object:</p>

<pre><code>&lt;ul&gt;
  &lt;% @project.tickets.each do |ticket| %&gt;
    &lt;li&gt;&lt;%= UserPresenter.new(ticket.author).avatar %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This then muddles together the Ruby and HTML code of our view. A way to solve this could be to move that preparation of the data into a helper:</p>

<pre><code>module TicketsHelper
  def author_avatar(author)
    UserPresenter.new(author).avatar
  end
end
</code></pre>

<p>Then in the view:</p>

<pre><code>&lt;ul&gt;
  &lt;% @project.tickets.each do |ticket| %&gt;
    &lt;li&gt;&lt;%= author_avatar(ticket.author) %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>We have now got the logic for rendering an avatar spread over three different points:</p>

<ol>
  <li>The view</li>
  <li>The presenter</li>
  <li>The helper</li>
</ol>

<p>This is not a very clear way to organize this code, and the more this pattern is used, the more confusing your application will get.</p>

<p>Views in a default Rails application leave us with no alternative other than to create a sticky combined mess of logic between our ERB files and helper files that are globally shared.</p>

<h2 id="we-can-do-better">We can do better</h2>

<p>It should be possible to render a view without relying on a model to be connected to a database. Being
able to reach into the database from your views <em>should</em> be hard work.
Your business logic should have everything it needs to work by the stage a view is being rendered. This will then make it easier to test the view in isolation from the other components of your application.</p>

<p>The source of these frustrations is the Active Record pattern and Rails’ strict adherence to it. A class containing only business logic and being passed some data should not need
to know also about how that data is validated, any “callbacks” or how that data
is persisted too. If a class knows about all of those things, it has too many
responsibilities.</p>

<p>The Single Responsibility Principle says that a class or a module should only
be responsible for one aspect of the application’s behaviour. It should only
have one reason to change. An Active Record model of any meaningful size has
many different reasons to change. Maybe there’s a validation that needs
tweaking, or an association to be added. How about a scope, a class method or a
plain old regular method, like the contributors one? All more reasons why
changes could happen to the class.</p>

<p>An Active Record model flies in the face of the Single Responsibility
Principle. I would go as far as to say this: Active Record leads you to writing
code that is hard to maintain from the very first time you set foot in a Rails
application. Just look at any sizable Rails application. The models are
usually the messiest part and I really believe Active Record – both the
design pattern and the gem that implements that pattern – is the cause.</p>

<p>Having a well-defined boundary between different pieces of code makes it easier
to work with each piece. Active Record does not encourage this.</p>

<p>Validations and persistence should be their own separate responsibilities and separated into
different classes, as should business logic. There should be specific, dedicated classes that only
have the responsibility of talking to the database. Clear lines between the
responsibilities here makes it so much easier to work with this code.</p>

<p>It becomes easier then to say: this class works with only validations and this
other class talks to the database. There’s no muddying of the waters between
the responsibilities of the classes. Each class has perhaps not <em>one</em> reason to
change, but at least <em>fewer</em> reasons to change than Active Record classes.</p>

<p>It’s possible to build a Rails application with distinct classes for validations, persistence and logic that concerns itself with data from database records. It’s possible to build one that does not combine a heap of messy logic in a controller action, muddling it in with request and response handling.</p>

<p>Just because DHH &amp; friends decided in 2006 that there was One True Way™ to build a Rails application – it does not mean that now in 2021, a full 15 years later, that we need to hew as close to that as possible.</p>

<p>We can explore other pathways. This is a book dedicated to charting that exploration, leading to a brighter future for your Rails application.</p>

<p>The way we’re going to <em>improve</em> upon the default Rails architecture is with two suites of gems: those from the <a href="https://dry-rb.org/">dry-rb</a> suite, and those from the <a href="https://rom-rb.org">rom-rb</a> suite.</p>

<p>We’ll be using these gems to clearly demarcate the lines between responsibilities for our application.</p>

<p>We’ll have particular classes that will separate the code that validates user input from the code that talks to a database.</p>

<p>We’ll take apart the intermingling of request-response handling and business logic from within our controllers, and move that out to another set of distinct classes.</p>

<p>We’ll move code that would typically be in a view or a helper, into yet another type of distinct class: one called a <em>view component</em>.</p>

<p>And with this, we’ll move forward into that bright future that’ll lead to your Rails applications being maintainable.</p>

<hr />

<p>_If you want to find out how to build maintainable Rails applications, read my book: <a href="https://leanpub.com/maintain-rails">Maintainable Rails</a>, available on Leanpub for $10 for the next month.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Contracting as a developer in Australia</title>
   <link href="http://ryanbigg.com/2021/03/getting-started-with-contracting-in-australia"/>
   <updated>2021-03-04T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/03/getting-started-with-contracting-in-australia</id>
   <content type="html"><![CDATA[<p>(All advice in this blog post is of a general nature and comes with the regular disclaimers, such as: “I am not a lawyer / tax agent”, etc. etc. If you have questions about the law or your tax obligations, talk to real lawyers, tax agents or even the people at the ATO.)</p>

<p>(This blog post will be updated as I find out more things about contracting – there is definitely more to learn!)</p>

<p>After working as a developer full-time for a number of years, I’ve decided to give that a break. And instead I’m now working full-time as a sole-trader contractor instead.</p>

<p>Maybe it was the two redundancies and then being fired. Maybe it was the “ride or die” / undying loyalty that companies want from their employees now. Who knows what truly led to this ridiculous decision to work as a solo contractor.</p>

<p>It wasn’t supposed to be full-time – but having two months off work does <em>nasty</em> things to your bank account. Alas. So I’m working full-time (for now) as a contractor, hoping to reduce that to 4 days in the near future.</p>

<p>Another developer by the name of Susan Pan asked these questions on an Australian web developer Slack group recently:</p>

<blockquote>
  <p>Hey everyone, was wondering if there are any people here with contracting experience? I’m new to the industry and also new to contracting so I have no idea about the logistics of it all (working out a salary, need an abn?, legal protections, etc). I’d be super appreciative if anyone has any time to chat/dm about their experience? Thanks!</p>
</blockquote>

<p>Here’s my (slightly edited) answers to those questions, and I’ll add a bit extra here too that I didn’t include there. Just for you!</p>

<h2 id="abn">ABN</h2>

<p>If you’re working as a contractor within Australia it’s likely that you’ll need an ABN. You can <a href="https://abr.gov.au/ABRWeb/Default.aspx?Target=CheckAbnEntitlement&amp;pid=71">check your ABN eligibility here</a>. I have an ABN. You can look it up!</p>

<p>An ABN helps identify transactions between businesses within Australia. The government will <em>probably</em> require you to have one, so I would suggest getting one as a first point of call. But! Check your eligibility first.</p>

<h2 id="money">Money</h2>

<h3 id="working-out-a-daily-rate">Working out a daily rate</h3>

<p>I contract out at a daily rate that was worked out based on what I was previously paid ($150k as a senior Ruby / JavaScript dev), plus a bit of extra padding to account for things like 1) making my own tax + super contributions 2) giving myself annual leave and sick leave.</p>

<p>I am now charging out at [redacted] as a contractor, working 8 hour days (with an hour lunch break somewhere in there, unpaid). This works out to [redacted]/day, which is a nice round number that makes me happy.</p>

<p>This base-hour number is a point-in-time sample and may vary, depending on circumstances. Someone else on that same Slack group gave this advice:</p>

<blockquote>
  <p>The best advice I ever got for setting your rate is “think of the highest number you can say with a straight face, then say that number”</p>
</blockquote>

<p>That’s essentially how I work out my number, too. What I will say is that if I was working full-time at this rate that I would make somewhere north of $200k/yr, pre-tax. The overall plan is to <em>not</em> work full-time, and to work part-time instead.</p>

<p>What clients get for that number is someone with a decade and a half of web development experience in many different teams of different shapes and sizes, with a good knowledge across many different languages. And: “he wrote <em>the book on Rails!</em>”</p>

<h3 id="invoicing">Invoicing</h3>

<p>Invoicing: get yourself a <a href="https://xero.com">Xero</a> subscription and hook it up to your bank account. Dedicate a time on a particular morning each week to track expenses in Xero and issue invoices or to follow up unpaid invoices.</p>

<p>Expense tracking is incredibly helpful for depreciating things around tax time like the “tools of the trade”: laptops, chairs, desks, pencils, pens, rulers… if you use it for a job, keep the receipt (in Xero) and list it under business expenses.</p>

<p>On that same topic: talk to a tax agent around tax time. Again, this is another couple-of-hundred-dollars worth of expenses but the good ones will save you more than what you pay them in raw time-value. The tax agent bill can then be expensed the next financial year. Your tax agent’s job is to sift through the data you’ve diligently collected in Xero and to help you pay the correct amount of tax, or even in some cases to get a tax refund if you’ve overpaid in your tax obligations.</p>

<h3 id="gst">GST</h3>

<p>Speaking of tax: if you’re earning over $75k, you’ll need to <a href="https://www.ato.gov.au/Business/GST/Registering-for-GST/">register for GST as well</a>. The ATO purports to have the facilities to do this online, but when I tried using their app it shit the bed (maybe they need to hire more contractors?) and so I had to call them up. Even though I had to wait a while, the agent was super helpful and guided me through all the steps.</p>

<p>I’m now registered for GST, which means that I need to <em>collect</em> GST from the clients that I charge, and then pay that money every quarter to the government, through a process called a Business Activity Statement. You take <em>all</em> the money you charged for GST, <em>minus</em> the GST on purchases you’ve paid for the business, and that’s then your BAS payment for the quarter.</p>

<p>Xero has a great automatic tool for calculating BAS.</p>

<h3 id="whats-it-going-to-take-to-run-the-business-this-month">What’s it going to take to run the business this month?</h3>

<p>Once I’ve invoiced the client, received the money and correctly set aside the GST amount, it’s math time.</p>

<p>For the sole-tradership that I operate, there are business expenses that need to be taken of on usually a monthly recurring rate. There are some that are <em>yearly</em> as well. These provide me with a baseline cost of what it’s going to take to run the business this month. The yearly ones get divided by 12 and treated like a monthly cost, except the money is transferred into the business savings account.</p>

<h3 id="pay-yourself">Pay yourself</h3>

<p>Using that base number, I can then work out that my <a href="https://www.ato.gov.au/rates/individual-income-tax-rates/">income tax rate</a> is somewhere in the range of 37c-45c in the dollar (after certain amounts), depending on if I end up making more than $180k this year or not. This depends on how many weeks I can work this year. This is impossible to predict, given the nature of contracting work. Tide goes in, tide goes out.</p>

<p>So I err on the side of it being 45c instead of 37c. To make the mental math easy, I take whatever I get paid and put away half (50%) of that into a savings account that is then, essentially, untouchable. That then goes to paying my quarterly BAS bills that I get from the government with the money set aside for tax reasons listed in the BAS as a “tax withheld” amount.</p>

<p>Previously, I was on a Pay-as-you-go quarterly payment plan with the government thanks to my <a href="https://leanpub.com">Leanpub royalties</a> – but that’ll be changing to a quarterly Business Activity Statement soon due to the increased nature of my “business’s” earnings.</p>

<p>My effective tax rate is not exactly 37c or 45c on the dollar for every dollar – it’s important to note here that it’s 37c on every dollar <em>over</em> $120,000. So if my annual income was $150,000, the tax would not be $55,500 ($150k x 0.37). It would be more like: $150,000 - $120,000 = $30,000. Then that $30,000 x 0.37 = $11,100, plus the base rate of $29,467, or $40,567, or about 27% of $150k. An important distinction to make here!</p>

<p>By the time tax time comes around and I talk to my tax agent (below), we do some math and work out how much additional tax I need to pay. Hopefully this amount is zero, and that there’s also a nice tax return attached to that. If it’s not, no sweat: the money in the business savings account will cover it.</p>

<p>If there’s still leftover money in the savings account after all that then that gets rolled into the general transaction account for the business and I’ll spend it on things that I need, or transfer it into my family’s accounts as an extra bonus.</p>

<p>I then take 9.5% of whatever I get paid and put that directly into my superannuation. When I retire, I want money to be able to live, so this is a sensible choice. I could contribute more here.</p>

<p>I also take 5% out of this total amount for leave entitlements. I am (unfortunately) not invulnerable, so I will need paid sick leave from <em>somewhere</em>, and occasionally I might like to leave my computer so annual leave needs to be accounted for too. This really should be somewhere in the range of 11-12%, as annual + sick leave entitlements are usually in the range of 6 weeks of the year (11.5% of the year)… but I’m bootstrapping my consulting business now and I’m choosing to take fewer leave days for the moment.</p>

<p>By this point I’ve deducted these things from my business’s income:</p>

<ul>
  <li>Running the business expenses</li>
  <li>Tax obligations (both GST + personal income tax)</li>
  <li>Superannuation</li>
  <li>Leave entitlements</li>
</ul>

<p>The rest of this money then goes into my family’s bank accounts.</p>

<h2 id="get-it-in-writing">Get it in writing</h2>

<p>Next up: contracts!</p>

<p>My wife is an ex-lawyer and read over a contract that I drafted using my significant (read: completely lacking) legal expertise.</p>

<p>Having a Real Lawyer™ look over the contract ensures that I’m not missing obvious things (like including GST in payments, dummy!). Get yourself a contract lawyer who can do the same.</p>

<p>The contract is designed to answer the who, what, why, where, when, how questions:</p>

<ol>
  <li>Who’s this contract between?</li>
  <li>What’s this contract about?</li>
  <li>Why are we entering into this agreement?</li>
  <li>Where are we gonna be doing the work?</li>
  <li>For how long is this work going to happen?</li>
  <li>How are we going to work together?</li>
</ol>

<p>Get a contract. Get it signed.</p>

<p><strong>You cannot be a contractor without a contract. You will be an “or”. Nobody wants an “or”</strong>. Get it in writing. Get it signed. Dated. As the wise Jeff Casimir once said, contracts are written while in love, but only ever used in hate. You will want a good one for when shit hits the fan. And it will hit the fan.</p>

<p>If you agree to some work, it’s in writing <em>in your personal email account, not in their company’s Slack</em>. It’s timestamped, filed away and easily accessible. Can you find that documentation with minimal effort? You better be able to.</p>

<h2 id="getting-paid">Getting paid</h2>

<p>In order to make it ridiculously easy for people to pay me, I work with Australian-only clients <em>and</em> I offer two different payment methods: bank transfer or PayPal. Anyone who’s adulted a single day in Australia will know how to do a bank transfer between Australian bank accounts. Australian-only clients means that I don’t need to worry about international transfer fees, currency conversions or tracking alternative income for tax purposes. PayPal is for the occasional international client, and for Leanpub royalties.</p>

<p>I issue invoices (through Xero) fortnightly for one week gone, and one week coming. For example, if I was issuing an invoice on next Monday, the 8th of March, that invoice would cover all my work for the week of the 1st-5th of March <em>and also</em> the work that I would do during the week of the 8th-12th March. If I (unexpectedly) take time off that week, it would be deducted from the following invoice. That invoice would be on the 22nd of March, and would cover 15th-19th and 22nd-26th March, and so on and so on.</p>

<p>On the topic of getting paid: all my invoices are 14 days payable. This means that if an invoice is issued on, say, the 8th of March, then it must be paid by the time the 22nd of March comes around.</p>

<p>If the invoice is not paid by that time, then I will stop working. No exceptions. No “check is in the mail”, no “I’ll pay you next week”. If the money is not in the bank account by the very day the invoice says it is due, the work does not get done. Absofuckinglutely not.</p>

<p>Why am I so bullish on this point? Because I’ve been dicked around before, and I <em>will not</em> let it happen again. As a contractor, I rely on a steady stream of income to support my family and the moment that is cut off is the very moment I will need to start finding a new stream.</p>

<p>Take pride in yourself as a contractor and have the same rules.</p>

<h3 id="billable-hours">Billable hours</h3>

<p>On a related topic: billable hours. Did you spend time working for a client between the hours of 9am and 5pm? That’s billable time. Did you spend time outside of those hours working for the client? Maybe you had an on-call incident in the middle of the night or had to work a weekend? That’s billable too. Get it in writing in the contract that it’s a thing that <em>might</em> happen, and <em>bill for it</em>.</p>

<p>Conversely: did you spend an hour at a dentist appointment? That’s not billable. Haircut? Unbillable. Had a case of the “dunwannas” and needed to lie on the couch? Don’t you dare think about billing for it.</p>

<p>When it comes to invoicing clients for hours worked, keep it honest in <em>both directions</em>. Bill for the hours you’ve worked (even if they’re slightly outside of the agreed time) and do not bill for the hours you did not work for them. Honesty is the best policy here.</p>

<h2 id="leave-the-campsite-better-than-how-you-found-it">Leave the campsite better than how you found it</h2>

<p>The header of this section is a Scouts motto. After attending the scouts for precisely zero days of my life, this statement <em>still</em> resonates with me.</p>

<p>I care about the long-term viability of your codebase, company and team, not just the money coming in the door. The money in the door helps me keep my family alive and happy. The work I deliver at your company keeps <em>your</em> families alive and happy, and I want that to remain that way long-term. If it remains that way, it’s likely you’ll keep me as a contractor or at least recommend me to your favourite people.</p>

<p>I’ve had to work on codebases where contractors who <em>didn’t</em> care about those things (“oh fuck we’ve only got 2 weeks shipitshipitshipit”) and it was miserable. I don’t want misery – I want happiness. I want people to go “yeah, you should hire Ryan because he came in for 3 months and did X, Y and Z and rocked our socks.” Yeah it’s nice being paid, but the <em>success</em> of doing a good job is what counts.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Twist V2 - Live Coding</title>
   <link href="http://ryanbigg.com/2021/01/twist-v2-live-coding"/>
   <updated>2021-01-13T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/01/twist-v2-live-coding</id>
   <content type="html"><![CDATA[<p>This year, I’ve been continuing on my work on <a href="https://github.com/radar/twist-v2">Twist</a>. As the README says:</p>

<blockquote>
  <p>This is a rewrite of my <a href="http://github.com/radar/twist">Rails-based book review app</a> in <a href="https://rom-rb.org/">rom-rb</a>, <a href="https://dry-rb.org/">dry-rb</a>, (some parts of) <a href="https://hanamirb.org/">Hanami</a>, <a href="https://sidekiq.org/">Sidekiq</a>, <a href="https://graphql.org/">GraphQL</a>, <a href="https://reactjs.org/">React</a>, <a href="https://reach.tech/router/">Reach Router</a>, <a href="https://www.apollographql.com/">Apollo</a>, <a href="https://www.typescriptlang.org/">TypeScript</a>, <a href="https://graphql-code-generator.com/">GraphQL Code Generator</a>, <a href="https://tailwindcss.com/">Tailwind</a>, and whatever other Cool Hipster Tech™ I can get my grubby hands on.</p>
</blockquote>

<p>This application is a hybrid application, consisting of two distinct parts: a Ruby backend, and a TypeScript frontend. They communicate over GraphQL.</p>

<p>To demonstrate what working on this application is like, I’m doing some live coding sessions on it, every Wednesday morning.</p>

<h2 id="episode-1-starting-the-invitations-feature">Episode 1: Starting the invitations feature</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/qWdyo3icsjU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="episode-2-continuing-the-invitations-feature">Episode 2: Continuing the invitations feature</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/RKQLEEGIPyE" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="episode-3-checking-for-permissions-on-the-invitations">Episode 3: Checking for permissions on the invitations</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Bg1W8-SzbHw " frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

]]></content>
 </entry>
 
 <entry>
   <title>React Select + Capybara + Selenium</title>
   <link href="http://ryanbigg.com/2020/09/react-select-capybara-selenium"/>
   <updated>2020-09-23T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/09/react-select-capybara-selenium</id>
   <content type="html"><![CDATA[<p>Today, I was adding a <a href="https://react-select.com/home">React Select</a> element to a page, and I really wanted to test it.</p>

<p>This is, surprisingly, <a href="https://github.com/JedWatson/react-select/issues/856">not the first time I’ve attempted this</a>.</p>

<p>Since 2016, React Select has undergone some changes, released a brand-new (and much better!) version. One of these big features is that it uses <a href="https://emotion.sh/docs/introduction">Emotion</a> for styling. A consequence of this is that React Select no longer has <code>.Select</code>, or <code>.Select-input</code> classes that you could use as selectors in the tests. Instead, it will generate hashed CSS selectors, like <code>css-2b097c-container</code> and <code>css-1rhbuit-multiValue</code>. These have the potential to change: if the underlying CSS changes, then the hash will change. So they are not reliable in tests.</p>

<p>To fix this, I used another prop of <code>ReactSelect</code> called <code>classNamePrefix</code>:</p>

<pre><code class="language-tsx">import CreatableSelect from "react-select/creatable";

// ...

const options = [
  { label: "Admin", value: "Admin" },
  { label: "HIU", value: "HIU" },
  { label: "Organisational", value: "Organisational" },
  { label: "Paid", value: "Paid" },
];

// "tags" here comes from a prop on this component
const selectedOptions = options.filter(({ value }) =&gt; tags.includes(value));

return (
  &lt;CreatableSelect
    options={options}
    defaultValue={selectedOptions}
    isMulti
    classNamePrefix="tags"
  /&gt;
);
</code></pre>

<p>This prop adds additional classes to the React Select component, such as <code>.tags__control</code> and <code>.tags__multi-value</code> – values that <em>are</em> reliable and predictable!</p>

<p>This means that in the Capybara test, I can now use these to interact with this React Select component, like this:</p>

<pre><code class="language-ruby"># spec/support/filter_helpers.rb
module FilterHelpers
  class SelectControl
    include Capybara::DSL

    attr_reader :prefix

    def initialize(prefix:)
      @prefix = prefix
    end

    def select(option)
      within_control do
        find("input").fill_in(with: option)
      end

      find(".#{prefix}__option", text: option).click
    end

    def value
      find(single_value_selector).text
    end

    def blank?
      page.has_no_selector?(single_value_selector)
    end

    def values
      all(multi_value_selector).map(&amp;:text)
    end

    def remove(label)
      value = find(multi_value_selector, text: label)
      within(value) do
        find("#{multi_value_selector}__remove").click
      end
    end

    def visible?
      page.has_selector?(control_selector)
    end

    def hidden?
      !visible?
    end

    private

    def single_value_selector
      ".#{prefix}__single-value"
    end

    def multi_value_selector
      ".#{prefix}__multi-value"
    end

    def control_selector
      ".#{prefix}__control"
    end

    def within_control(&amp;block)
      within(control_selector, &amp;block)
    end
  end

  module TagFilterControl
    def tag_filter_control
      SelectControl.new(prefix: "tags")
    end

    def add_new_tag(tag)
      tags_control.select(tags)
    end

    def expect_tags_selected(tags)
      expect(tags_control.value).to eq(tags)
    end

    def expect_no_tags_selected
      expect(tags_control).to be_blank
    end

    def remove_tags(*tags)
      tags.each do |tag|
        tags_control.remove(tag)
      end
    end
  end
end

# spec/features/updating_tags_spec.rb

RSpec.describe "Updating tags" do
  include TagFilterControl

  scenario "Can update a User's tags", js: true do
    visit edit_admin_user_path(user)

    expect_tags_selected("Existing tag")
    remove_tag("HIU")
    add_new_tag("Paid")
    add_new_tag("Custom tag")
  end
end
</code></pre>

<p>I have the following helpers:</p>

<ol>
  <li><code>expect_selected_tag</code>: When the page loads, the Select element should contain a tag that is <em>already</em> assigned to the user.</li>
  <li><code>remove_tag</code>: Used to remove a tag that appears in the Select element.</li>
  <li><code>add_new_tag</code>: Used to add either a tag from the list of options, or to create a brand new tag.</li>
</ol>

<p>With these helpers, I can effectively test React Select within Capybara and Selenium.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Selenium, Capybara, ChromeDriver: connection refused error debugging</title>
   <link href="http://ryanbigg.com/2020/08/selenium-capybara-chromedriver-connection-refused-error-debugging"/>
   <updated>2020-08-29T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/08/selenium-capybara-chromedriver-connection-refused-error-debugging</id>
   <content type="html"><![CDATA[<p>A few days ago, we started seeing this exception happening for <em>some</em> of our Capybara feature tests:</p>

<pre><code>1.1) Failure/Error: visit(sign_out_path)

      Selenium::WebDriver::Error::UnknownError:
        java.net.ConnectException: Connection refused (Connection refused)
      # [remote server] org.openqa.selenium.remote.server.WebDriverServlet(WebDriverServlet.java):240:in `lambda$handle$0'
      # [remote server] java.util.concurrent.Executors$RunnableAdapter(Executors.java):511:in `call'
      # [remote server] java.util.concurrent.FutureTask(FutureTask.java):266:in `run'
      # [remote server] java.util.concurrent.ThreadPoolExecutor(ThreadPoolExecutor.java):1149:in `runWorker'
      # [remote server] java.util.concurrent.ThreadPoolExecutor$Worker(ThreadPoolExecutor.java):624:in `run'
      # [remote server] java.lang.Thread(Thread.java):748:in `run'
      # ./spec/support/pages/login.rb:5:in `login'
      # ./spec/concepts/extraction/keyboard_shortcuts_spec.rb:84:in `block (2 levels) in &lt;main&gt;'
      # ./spec/spec_helper.rb:69:in `block (2 levels) in &lt;main&gt;'
      # ./spec/support/elasticsearch_spec_helper.rb:42:in `block (3 levels) in &lt;main&gt;'
      # ./spec/support/elasticsearch_spec_helper.rb:38:in `block (2 levels) in &lt;main&gt;'
</code></pre>

<p>Connection refused, fine. But connection refused to <em>what</em>? This error message doesn’t give us much to go on.</p>

<p>Seemingly nothing that we changed had caused this issue – it was one of those types of issues that just popped up spontaneously.</p>

<p>It turns out that this is due to a bug within Google ChromeDriver <code>85.0.4183.83</code>. Here’s the bug report for ChromeDriver: <a href="https://bugs.chromium.org/p/chromedriver/issues/detail?id=3578">Issue 3578</a>.</p>

<h2 id="debugging-steps">Debugging steps</h2>

<p>After quite a lot of playing around with our Docker container setup, building EC2 instances and testing things out there… I was able to track it down to this issue by adding this line to the configuration for our tests:</p>

<pre><code>Selenium::WebDriver.logger.level = Logger::DEBUG
</code></pre>

<p>I knew of this trick by having to debug Selenium issues in the past – it’s a very helpful trick to get messages out of Selenium WebDriver that you wouldn’t otherwise see.</p>

<p>When I did this, I saw these messages come through:</p>

<pre><code>2020-08-30 08:39:15 INFO Selenium &lt;- {"value":{"data":{"text":"{Alert text : "},"error":"unexpected alert open","message":"unexpected alert open: {Alert text : }\n  (Session info: chrome=85.0.4183.83)","stacktrace":"0   chromedriver                        0x000000010a9261b9 chromedriver + 4911545\n1   chromedriver                        0x000000010a8c5e03 chromedriver + 4517379\n2   chromedriver                        0x000000010a533da6 chromedriver + 773542\n3   chromedriver                        0x000000010a4c4072 chromedriver + 315506\n4   chromedriver                        0x000000010a4b7c23 chromedriver + 265251\n5   chromedriver                        0x000000010a491720 chromedriver + 108320\n6   chromedriver                        0x000000010a492693 chromedriver + 112275\n7   chromedriver                        0x000000010a8eef72 chromedriver + 4685682\n8   chromedriver                        0x000000010a8fcb3a chromedriver + 4741946\n9   chromedriver                        0x000000010a8fc801 chromedriver + 4741121\n10  chromedriver                        0x000000010a8d225e chromedriver + 4567646\n11  chromedriver                        0x000000010a8fd061 chromedriver + 4743265\n12  chromedriver                        0x000000010a8e3d0a chromedriver + 4640010\n13  chromedriver                        0x000000010a9160ba chromedriver + 4845754\n14  chromedriver                        0x000000010a92c387 chromedriver + 4936583\n15  libsystem_pthread.dylib             0x00007fff67652109 _pthread_start + 148\n16  libsystem_pthread.dylib             0x00007fff6764db8b thread_start + 15\n"}}
</code></pre>

<p>Well that looks like a crash!</p>

<p>An unexpected alert open? What does that mean?</p>

<p>This lead me to look through the issue logs for Capybara first, as these were tests using Capybara. The final “exit” point from our code uses Capybara code. When I looked on Capybara’s issue tracker I saw that there’s an issue for this problem: <a href="https://github.com/teamcapybara/capybara/issues/2382">Capybara Issue #2382</a>. This then links to a Selenium issue: <a href="https://github.com/SeleniumHQ/selenium/issues/8638">Selenium Issue #8638</a>, which itself then links to <a href="https://bugs.chromium.org/p/chromedriver/issues/detail?id=3578">Issue 3578</a>.</p>

<p>These are pretty good pieces of evidence that indicate it was a chromedriver issue. I then recalled that a colleague of mine, Luiz, mentioned that Chrome had updated a few days ago. An update of Chrome leads to an update in Chromedriver, and since it was Chromedriver that was breaking, I thought to check that.</p>

<p>On the Capybara issue, there are some good steps to reproduce the issue with a minimal test case. I used this to lock Chromedriver to the more modern version:</p>

<pre><code>Webdrivers::Chromedriver.required_version = '85.0.4183.87'
</code></pre>

<p>The issue reported on Capybara wasn’t happening with that <code>.87</code> release, but it <em>does</em> happen with this:</p>

<pre><code>Webdrivers::Chromedriver.required_version = '85.0.4183.83'
</code></pre>

<p>So this then indicates that it’s a particular version of Chromedriver that causes the issue.</p>

<p>There are at least two ways to fix this issue.</p>

<p>The first is to lock Chromedriver using <code>Webdrivers::Chromedriver.required_version</code> to a particular version. But that means we need to remember to update that.</p>

<p>The second way is to dismiss the alert before finishing the test:</p>

<pre><code class="language-ruby">require 'bundler/inline'

gemfile do
  source 'https://rubygems.org'
  gem 'capybara'
  gem 'puma'
  gem 'selenium-webdriver'
  gem 'webdrivers'
  gem 'byebug'
  gem 'pry'
end

require 'selenium-webdriver'
require 'capybara/dsl'

Webdrivers::Chromedriver.required_version = '85.0.4183.83'
Selenium::WebDriver.logger.level = Logger::DEBUG

html = &lt;&lt;~HTML
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;

    &lt;script type="text/javascript"&gt;
      window.addEventListener('beforeunload', (event) =&gt; {
        event.preventDefault();
        event.returnValue = '';
      });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;&lt;a href="https://google.com"&gt;Hello World&lt;/a&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
HTML

app = proc { |env| [200, { "Content-Type" =&gt; "text/html" }, [html] ] }

session = Capybara::Session.new(:selenium_chrome, app)
session.visit '/'
session.click_on 'Hello World' # interact with the page, to get Chrome to fire `beforeunload`
session.driver.browser.switch_to.alert.accept
session.visit '/'
</code></pre>

<p>It’s the third-to-last and second-to-last lines here that will work around the issue here – we need to attempt to navigate away from the page and then click the alert. Then we can carry on testing after that point.</p>
]]></content>
 </entry>
 
 <entry>
   <title>How to tidy up Git Pull Requests</title>
   <link href="http://ryanbigg.com/2020/04/how-to-tidy-up-git-pull-requests"/>
   <updated>2020-04-23T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/04/how-to-tidy-up-git-pull-requests</id>
   <content type="html"><![CDATA[<p><strong>This post will cover how to break up a commit on a Git branch into two separate commits all from the terminal.</strong></p>

<p>Sometimes, developers can get carried away when they make commits. For instance, take <a href="https://github.com/radar/twist-v2/commit/19a513a6ae33ed0de3fb8ce426e7c7ec99449f0d">this commit</a> from yours truly. It <em>claims</em> to be fixing a particular issue, but there’s <em>a lot</em> of code there to fix that issue. Is all of it really necessary?</p>

<p>I’ll save you the spelunking: just the <code>frontend/src/styles.css</code> and <code>frontend/src/tailwind.css</code> files are the only things required to fix this issue. This commit <em>really</em> should’ve just been changes to those two files. The storybook changes should’ve been in a <em>separate</em> commit.</p>

<p>But the work has been done! Isn’t it now set in stone? No, this is Git! We can rewrite history.</p>

<p>So let’s pretend like this commit <em>hasn’t been committed to master yet</em>. I can do this by checking out a new branch to the commit before that one:</p>

<pre><code>git checkout 19a513a6~1 -b tidy-up-git-example
</code></pre>

<p>Here, <code>~1</code> means “1 before”. You could put any number here. You can see what this branch looks like <a href="https://github.com/radar/twist-v2/tree/tidy-up-git-example">on GitHub</a>. The latest commit will be <code>bb36d9b</code>, “Add back image missing”.</p>

<p>We now want to apply that <code>19a513a6</code> commit, the one that fixes Issue #22, to this branch. To do this, we’ll open a pull request against this <code>tidy-up-git-example</code> branch.</p>

<p>First, we need to switch to a new branch:</p>

<pre><code class="language-plaintext">git switch -c fix/issue-22
</code></pre>

<p><code>switch</code> is a recent sub-command of Git, and <a href="https://github.blog/2019-08-16-highlights-from-git-2-23/">was added in 2.23.0</a>. You can think of it behaving like <code>checkout</code>.</p>

<p>We’ll now bring in that commit to this branch, applying it on top of the current history with <code>cherry-pick</code>:</p>

<pre><code class="language-bash">git cherry-pick 19a513a6
</code></pre>

<p>When we run <code>git log --oneline</code>, we’ll see this:</p>

<pre><code class="language-text">f20de41 (HEAD -&gt; fix/issue-22) Fixes #22
bb36d9b (origin/tidy-up-git-example) Add back image missing
</code></pre>

<p>This shows us that the top-most / latest commit is that one we just cherry picked, and that the next most recent commit is the latest from the <code>origin/tidy-up-git-example</code> branch.</p>

<p>Next, you’ll need to push this branch up to GitHub:</p>

<pre><code class="language-text">git push origin fix/issue-22
</code></pre>

<p>If you don’t have permission to push to this repository (and most of you won’t!), you’ll need to fork it on GitHub first, then:</p>

<pre><code class="language-text">git remote add your-username git@github.com:your-username/twist-v2.git
git push your-username fix/issue-22
</code></pre>

<p>When this branch has been pushed to GitHub, you should now be able to create a pull request from that branch. You can do this by going to https://github.com/your-username/twist-v2/pull/new/fix/issue-22. On this page, under “Open a pull request” you’ll see two dropdowns: one for a “base” branch and one for “compare” branch:</p>

<p><img src="/images/tidy-up-github/base-and-compare.png" alt="Base &amp; Compare" /></p>

<p>The base branch is the branch you will be applying your pull request to. The changes in your pull request come from the compare branch. The “Able to merge” here indicates that there are no conflicts between the branches, and so this PR would be mergeable onto the base branch without trouble.</p>

<p>If we go ahead and create this PR now, we’ll see this:</p>

<p><img src="/images/tidy-up-github/big-diff.png" alt="Big Diff" /></p>

<p>How many lines?! If I was reviewing a PR of this length I would make sure to grab at least <em>one</em> cup of coffee and have slept well the night before too. Does this PR need to be so <em>massive</em>? We answered that before: no.</p>

<p>So we now have got ourselves a little bit stuck. We want to have the changes to fix Issue #22, but we also care about the storybook changes too. Let’s now work on how we can separate these two into two separate PRs.</p>

<h2 id="separating-out-issue-22">Separating out Issue #22</h2>

<p>Let’s start with just the CSS changes from <code>frontend/src/styles.css</code> and <code>frontend/src/tailwind.css</code>. We want just these changes to be in the PR’s commit. To do that, we need to <em>undo</em> and <em>redo</em> this commit.</p>

<p>To <em>undo</em> a commit, we use a Git operation called a <em>soft reset</em>:</p>

<pre><code class="language-text">git reset --soft HEAD~1
</code></pre>

<p>You can think of this like the opposite of <code>git commit</code>; it resets the Git repository’s state back to how it was right before <code>git commit</code> was run. All of changes from this commit will be staged for commit:</p>

<p><img src="/images/tidy-up-github/staged-for-commit.png" alt="Staged for commit" /></p>

<p>But our latest commit will show up as the one from <code>tidy-up-git-example</code>:</p>

<pre><code class="language-text">git log --oneline
</code></pre>

<pre><code>bb36d9b (HEAD -&gt; fix/issue-22, origin/tidy-up-git-example) Add back image missing
</code></pre>

<p>Now that we’re back to our pre-<code>git commit</code> stage, we need to go back one more step, back to before <code>git add</code> was run to stage these files. To do that, we need to run:</p>

<pre><code>git reset HEAD
</code></pre>

<p>This command will unstage all the changes in our repository:</p>

<p><img src="/images/tidy-up-github/unstaged-files.png" alt="Unstaged files" /></p>

<p>Now we want to just add the changes from <code>frontend/src/styles.css</code> and <code>frontend/src/tailwind.css</code>. We can do this with:</p>

<pre><code>git add frontend/src/styles.css
git add frontend/src/tailwind.css
</code></pre>

<p>(Or if we were wanting to pick-and-choose changes from these files, we could do <code>git add -p &lt;file&gt;</code> instead)</p>

<p>This will stage these two files:</p>

<p><img src="/images/tidy-up-github/two-staged-files.png" alt="Two staged files" /></p>

<p>Next, we can commit these changes:</p>

<pre><code>git commit -m "Fixes #22"
</code></pre>

<p>We’ve now re-written the history of the <code>fix/issue-22</code> branch. The latest commit on this branch, according to our local computer, is different to the latest one on GitHub. We need to tell GitHub that our history is correct, and we can do this with:</p>

<pre><code>git push &lt;your username&gt; fix/issue-22 --force-with-lease
</code></pre>

<p>This option will force-push your changes to GitHub, updating GitHub with the simpler changes.</p>

<p>If you refresh the GitHub pull request window, you’ll now see a much, much smaller diff number:</p>

<p><img src="/images/tidy-up-github/small-diff.png" alt="Small Diff" /></p>

<p>Much better! Our PR is now just focussed on the small changes that we needed to make to fix Issue #22.</p>

<p>We can then merge this PR to the branch, confident that the commit is small.</p>

<h2 id="storybook">Storybook</h2>

<p>Next up, we still need to pull in those storybook changes. Because we’ve reset and unstaged all the changes, those storybook changes will still be tracked as unstaged in our Git repository:</p>

<p><img src="/images/tidy-up-github/unstaged-storybook-files.png" alt="Unstaged storybook files" /></p>

<p>We can check out to a new branch for these changes, add these files, make a new commit and push these changes to GitHub:</p>

<pre><code>git switch -c update-storybook
git add .
git commit -m "Update Storybook + separate stories"
git push origin update-storybook
</code></pre>

<p>We can then go about creating a pull request for these changes if we like by going to https://github.com/your-username/twist-v2/pull/new/update-storybook. Remember to change the base branch here to <code>tidy-up-git-example</code>!</p>

<p>Once the PR is created, we can choose to merge it to that base branch. The base branch will then have both sets of changes on it: one (small one) to fix Issue #22, and one (large one) to upgrade storybook.</p>

<p>The storybook changes <em>could</em> probably be split out into smaller commits too, but I’ll leave that one as an exercise to the reader.</p>
]]></content>
 </entry>
 
 <entry>
   <title>The Stand Down</title>
   <link href="http://ryanbigg.com/2020/04/the-stand-down"/>
   <updated>2020-04-06T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/04/the-stand-down</id>
   <content type="html"><![CDATA[<p>Two weeks ago, I was moved from a teaching position into a “curriculum development” position at Coder Academy. Instead of facing students and teaching them directly, I was to work with my teacher’s assistant on improving curriculum for <em>all of Coder Academy</em>. I absolutely love writing, and so this was an amazing opportunity to apply my craft.</p>

<p>We set to work on updating curriculum for all Coder Academy’s bootcamps, revising content a week or two ahead of where they were all at.</p>

<p>At the start of the week last week, an email went out from Coder Academy’s parent company that announced they were standing down some staff. This was at 9:50am on Monday morning. This email did not mention how many staff it was, but <a href="https://www.theguardian.com/australia-news/live/2020/mar/30/coronavirus-update-live-australia-news-nsw-qld-victoria-scott-morrison-press-conference-covid-19-restrictions-public-gatherings-cruise-lockdown-app-latest-updates?page=with:block-5e8138d38f0878a2a48aca93#block-5e8138d38f0878a2a48aca93">The Guardian helpfully reported that the number would be 235 staff</a>.</p>

<p>I was told that Monday that “don’t worry, it’s not academic staff”, meaning I would not be affected. They let some of the admin staff go, or reduced their hours. Some people went from working 5 days a week to only working two.</p>

<p>I didn’t receive word at all if I still had my job or not until Friday. On Friday, at about 3pm, I received a phone call not from my Coder Academy manager, but from the head of HR at RedHill: Ruby Biscuit. She told me that I would be stood down immediately.</p>

<p>It was almost an entire business week of waiting and anxiety. I still tried working through it and, surprisingly, got a lot done.</p>

<p>13 minutes after that phone call, I was locked out of Coder’s GitHub and Slack accounts. My direct bosses did not know this phone call was going to happen. The call came from Ruby instead.</p>

<hr />

<p>Then there was a standard “Stand Down” form letter. It’s brutal. An older version of this post contained the text, but I’ll save you the brutality here.</p>

<p>The letter says that I can come back to my job once this whole COVID thing blows over. That’s all well-and-good, but to be honest I will likely have another job by then.</p>

<p>The letter also says that I remain an employee, but the dictionary definition of “employee” is:</p>

<blockquote>
  <p>a person employed for wages or salary, especially at non-executive level.</p>
</blockquote>

<p>And I am not getting wages or a salary, nor am I being required to do any work. So I am not sure how this still makes me an employee.</p>

<p>The letter says that I can draw down on my annual leave entitlements, but there are only 7 days of those. So I get a week and a half of runway before my money dries up.</p>

<p>The letter goes on to say that I should look into government benefits, but neglects to mention if RedHill has applied for the <a href="https://www.business.gov.au/risk-management/emergency-management/coronavirus-information-and-support-for-business/jobkeeper-payment">JobKeeper program</a>, or even if I would qualify for it. Doing my own research, yes I probably would. Do I know if they’ve applied for the program? Nope.</p>

<p>The letter at one point says:</p>

<blockquote>
  <p>We anticipate that the stand down will apply for a period of 3 months, but that timeframe may change pending the company’s ongoing review of pandemic circumstances.</p>
</blockquote>

<p>And later:</p>

<blockquote>
  <p>At the end of the stand down period, you will return to your role and your employment agreement will continue.</p>
</blockquote>

<p>But does not take into account my contract was due to run out on the 7th of July. The stand down came into effect on the 6th of April, Monday of this week. If it’s indeed <em>exactly</em> 3 months, it means that I would return to work on the 6th of July only for my contract to then run out on the 7th.</p>

<hr />

<p>How you let people go <em>matters</em>. More than ever in these COVID-19 times. We need to stick together; to be kind to one another. This letter and process is devoid of feeling and it threw me for a big loop. 13 minutes from phone call to cut off from my colleagues is too harsh. Especially when I did nothing wrong other than be in the wrong team.</p>

<p>Two simple ways they could’ve improved this process are:</p>

<ul>
  <li><strong>Let people know <em>immediately</em> on Monday morning if they had their job or not</strong>. The anxiety I had throughout the week would’ve been reduced massively.</li>
  <li><strong>Given me a week’s notice</strong> (as per the contract I signed when I joined). I would’ve liked to have (proverbially) packed my desk and (not proverbially) said my goodbyes. As it stands now, I have LinkedIn / Whatsapp / insert-26-other-chat-programs here messages to do that. It would’ve also allowed me to hand over any work or knowledge that I had to other people.</li>
</ul>

<p>Just these two things would’ve been a big help and really helped me transition out of there. Instead, I and many, many others have been cast out like detritus. It really hurts.</p>

<p>Anyway, I’m now looking for a new job. Go to <a href="https://ryanbigg.com/work">my /work page</a> to see what I’m interested in doing. I’m (obviously) available immediately.</p>
]]></content>
 </entry>
 
 <entry>
   <title>ROM and Dry Showcase: Part 4</title>
   <link href="http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-4"/>
   <updated>2020-02-20T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-4</id>
   <content type="html"><![CDATA[<p>This is the 4th (and final) part of a 4 part series covering the <a href="https://rom-rb.org/">rom-rb</a> and <a href="https://dry-rb.org/">dry-rb</a> suites of gems.</p>

<ul>
  <li>Part 1: <a href="/2020/02/rom-and-dry-showcase-part-1">Application + Database setup</a></li>
  <li>Part 2: <a href="/2020/02/rom-and-dry-showcase-part-2">Validations + Operations</a></li>
  <li>Part 3: <a href="/2020/02/rom-and-dry-showcase-part-3">Testing</a></li>
</ul>

<p>In this last part, we’re going to make it so that our application can receive and respond to HTTP requests.</p>

<p>So far, we’ve been seeing how to use gems either from the <code>dry-rb</code> suite of gems, or the <code>rom-rb</code> suite of gems. In this part though, we’re going to be using a gem from a <em>different</em> suite, a suite called Hanami.</p>

<p>Hanami is first and foremost a web framework. It has routes, controllers, actions, views and models. Just like your <em>other</em> favourite web framework – Rails. But the big difference between Hanami and Rails is that with Hanami we can pick and choose the parts of the framework that we want to use.</p>

<p>Hanami is a <em>modular</em> web framework, and if all we want to use is the router, controllers and actions, then we can. In this part of this showcase, we’re going to look at how we can use two gems from Hanami called <code>hanami-router</code> and <code>hanami-controller</code>. These gems will provide us with the features our application needs to receive and respond to HTTP requests.</p>

<p>Our application will take a request to <code>POST /users</code> with a JSON body shaped like this:</p>

<pre><code class="language-json">{
  "first_name": "Ryan",
  "last_name": "Bigg",
  "age": 32,
}
</code></pre>

<p>And the <em>response</em> will indicate if the request was successful or not. If it was successful, we will see a JSON response:</p>

<pre><code class="language-json">{
  "id": 1,
  "first_name": "Ryan",
  "last_name": "Bigg",
  "age": 32
}
</code></pre>

<p>Let’s go!</p>

<h2 id="installing-the-hanami-gems">Installing the Hanami gems</h2>

<p>Let’s add these gems to our Gemfile:</p>

<pre><code class="language-ruby">gem "hanami-controller", "~&gt; 1.3"
gem "hanami-router", "~&gt; 1.3"
</code></pre>

<p>To install these gems, we can run <code>bundle install</code>.</p>

<p>In order to make sure that whatever we build with this application is performing correctly, we’ll add a third gem called <code>rack-test</code>:</p>

<pre><code class="language-ruby">gem "rack-test"
</code></pre>

<p>We’re going to be using this gem to test our application in conjunction with RSpec. You might be thinking: why <code>rack-test</code>? That’s because the part of our application that will recieve and respond to HTTP requests will be a <em>Rack</em> application! Just like every other Ruby web framework out there.</p>

<h2 id="setting-up-the-test-environment">Setting up the test environment</h2>

<p>Before we can write our any code, we need to write tests for it. It’ll make sure that our application is working correctly! But before we can write tests, there’s a bit of setup we need to do first. We’re going to create a new file called <code>spec/web_helper.rb</code>. This file will setup how our tests can speak to our Rack application:</p>

<pre><code class="language-ruby">require "spec_helper"
require "rack/test"

module RequestHelpers
  def app
    Bix::Web.app
  end

  def post_json(path, data)
    post path, data.to_json, "CONTENT_TYPE" =&gt; "application/json"
  end

  def parsed_body
    JSON.parse(last_response.body)
  end
end

RSpec.configure do |config|
  config.define_derived_metadata(file_path: %r{/spec/requests/}) do |metadata|
    metadata[:request] = true
  end

  config.include Rack::Test::Methods, request: true
  config.include RequestHelpers, request: true
end
</code></pre>

<p>We set the <code>web</code> metadata flag on any tests that will go in <code>spec/requests</code>. This allows us to specify that the <code>Rack::Test::Methods</code> and <code>RequestHelpers</code> modules are included <em>only</em> into tests under that particular directory.</p>

<p>The <code>Rack::Test::Methods</code> module will include methods that we can use to make requests to our app, like <code>get</code>, <code>post</code> and so on.</p>

<p>The <code>RequestHelpers</code> module defines one method so far, called <code>app</code>. This <code>app</code> method is what the <code>rack-test</code> gem uses to know what application to talk to when we use those <code>get</code> / <code>post</code> / etc. methods.</p>

<p>We’ve defined the <code>app</code> value here to be a small Rack application that compiles a few parts. The first is <code>Hanami::Middleware::BodyParser</code>. This is a piece of middleware, that will convert our JSON input into parameters that our controller can access. The second part is <code>Bix::Web::Router</code>, which will be the main Ruby entrypoint for our application. That doesn’t exist right now, but we’ll create it in a moment. We’ll see both of these parts again a little later on again.</p>

<p>The <code>post_json</code> method in <code>RequestHelpers</code> will allow us to make a <code>POST</code> request to our application and to send through JSON data with that request. Remember: the web part of application here is going to take JSON as input during a request, <em>and</em> it will also return JSON in a response. The <code>parsed_body</code> method will give us a Ruby hash of the response’s body, and we can use this later on to assert the returned data is what we expect.</p>

<p>Before we create our router and all of the other parts, let’s write a couple of simple tests to make sure it will behave as we wish.</p>

<h2 id="writing-our-first-test">Writing our first test</h2>

<p>Currently, our application has a single transaction for creating users. We’re going to use this transaction very soon, using it when a request to <code>POST /users</code> is made. We’re going to add two tets now. These two tests will ensure that the application behaves correctly for valid and invalid input to <code>POST /users</code>. Let’s add these new tests to <code>spec/requests/users_spec.rb</code>:</p>

<pre><code class="language-ruby">require "web_helper"

RSpec.describe "/users" do
  context "POST /" do
    context "with valid input" do
      let(:input) do
        {
          first_name: "Ryan",
          last_name: "Bigg",
          age: 32,
        }
      end

      it "succeeds" do
        post_json "/users", input
        expect(last_response.status).to eq(200)
        user = parsed_body
        expect(user["id"]).not_to be_nil
        expect(user["first_name"]).to eq("Ryan")
        expect(user["last_name"]).to eq("Bigg")
        expect(user["age"]).to eq(32)
      end
    end

    context "with invalid input" do
      let(:input) do
        {
          last_name: "Bigg",
          age: 32,
        }
      end

      it "returns an error" do
        post_json "/users", input
        expect(last_response.status).to eq(422)
        user = parsed_body
        expect(user["errors"]["first_name"]).to include("is missing")
      end
    end
  end
end
</code></pre>

<p>These tests should look pretty familiar! They are essentially the same tests for our transaction, just with rack-test methods being the primary difference.</p>

<p>When we attempt to run these tests, we’ll see that we’re missing a part of our application:</p>

<pre><code>  1) /users POST / with valid input succeeds
     Failure/Error: Bix::Web.app

     NoMethodError:
       undefined method `app' for Bix::Web:Module
</code></pre>

<p>Oh right! We need to setup this Web thing!</p>

<h2 id="building-the-web-component">Building the Web component</h2>

<p>To setup this web part of our application, we’re going to add a new file to <code>system/boot</code>, called <code>web.rb</code>. In this file, we’ll need to require all the gems that we’ll be using for the web part of our application:</p>

<pre><code class="language-ruby">Bix::Application.boot(:web) do |app|
  init do
    require "hanami-router"
    require "hanami-controller"
  end
end
</code></pre>

<p>This two lines will require the hanami gems that we’re going to be using here. Where we’ll use these gems is in a couple of files.</p>

<p>The first is a file called <code>lib/bix/web/application.rb</code>. This is where we’ll define the different Rack pieces for our application:</p>

<pre><code class="language-ruby">require "hanami/middleware/body_parser"

module Bix
  module Web
    def self.app
      Rack::Builder.new do
        use Hanami::Middleware::BodyParser, :json
        run Bix::Web::Router
      end
    end
  end
end
</code></pre>

<p>This file is defines the <code>Bix::Web.app</code> method that our test is looking for! This method returns a <code>Rack::Builder</code> object, which is to say it returns a <em>Rack application</em>.</p>

<p>This Rack application uses a single piece of middleware: <code>Hanami::Middleware::BodyParser</code>. This middleware is used to take in any JSON request body, and to transform it into parameters for our actions.</p>

<p>The <code>run</code> line at the of the builder’s block directs Rack to the application that will be serving our requests. Let’s build this part now in <code>lib/bix/web/router.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Web
    Router = Hanami::Router.new do
      post "/users", to: Controllers::Users::Create
    end
  end
end
</code></pre>

<p>This file allows us to define routes for the web side of our application. This route defines a <code>POST /users</code> request to go to <code>Controllers::Users::Create</code>. What is this mythical constant? It’s going to be the action that serves this request.</p>

<p>In this application, we’re going to put actions inside their own classes. This will keep the code for each action more clearly isolated from other actions.</p>

<p>We’ll define this action inside <code>lib/bix/web/controllers/users/create.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Web
    module Controllers
      module Users
        class Create
          include Hanami::Action

          def call(params)
            self.body = "{}"
          end
        end
      end
    end
  end
end
</code></pre>

<p>This action class includes the <code>Hanami::Action</code> module from the <code>hanami-controller</code> gem. This gives us access to a number of helpful methods, but the only one of these we’re using now is <code>self.body=</code>, which we’re using to set the response body to an empty JSON hash. What’s also worth mentioning here is that due to us not specifying a status, this action will return a <code>200</code> status.</p>

<p>With our router and controller now setup correctly, let’s switch back to looking at our tests.</p>

<h2 id="running-our-tests">Running our tests</h2>

<p>When we run these tests with <code>bundle exec rspec spec/requests</code> we’ll see they’re both failing:</p>

<pre><code>  1) /users POST / with valid input succeeds
     Failure/Error: expect(user["id"]).not_to be_nil

       expected: not nil
            got: nil
     # ./spec/requests/users_spec.rb:18:in `block (4 levels) in &lt;top (required)&gt;'

  2) /users POST / with invalid input returns an error
    Failure/Error: expect(last_response.status).to eq(422)

      expected: 422
          got: 200

      (compared using ==)
    # ./spec/requests/users_spec.rb:36:in `block (4 levels) in &lt;top (required)&gt;'
</code></pre>

<p>This is happening because all our action returns is an empty JSON body. Let’s work on changing this.</p>

<p>We’ll change the action to use the transaction class:</p>

<pre><code class="language-ruby">module Bix
  module Web
    module Controllers
      module Users
        class Create
          include Hanami::Action
          include Import["transactions.users.create_user"]
          include Dry::Monads[:result]

          def call(params)
            case create_user.call(params.to_h)
            in Success(result)
              self.body = result.to_h.to_json
              self.status = 200
            in Failure(result)
              self.body = { errors: result.errors.to_h }.to_json
              self.status = 422
            end
          end
        end
      end
    end
  end
end
</code></pre>

<p>At the top of this controller action, we import the <code>create_user</code> transaction by using the <code>Import</code> constant that we made a few parts ago – this is from <code>dry-auto_inject</code>.</p>

<p>Then we include <code>Dry::Moands[:result]</code> – this gives us access to the <code>Success</code> and <code>Failure</code> methods we use inside the action.</p>

<p>Inside the action itself, we call the transaction and then use Ruby 2.7’s new pattern matching to decide what to do. In the case of a successful transaction, we return the body of the result. If it fails, we return the errors and set the status to 422.</p>

<p>This should be exactly what our test is expecting. Let’s run them again and find out:</p>

<pre><code>2 examples, 0 failures
</code></pre>

<p>Good! Our tests for our router are now passing. But this only means that our router is working, not that we can serve HTTP requests yet! We need one final piece for that to work.</p>

<h2 id="racking-up-the-server">Racking up the server</h2>

<p>To run our HTTP server, we’ll use a gem called <code>puma</code>. Let’s add that gem to the <code>Gemfile</code> now:</p>

<pre><code>gem "puma"
</code></pre>

<p>And we’ll run <code>bundle install</code> to install it.</p>

<p>To run the Puma server, we can use the command by the same name:</p>

<pre><code>puma
</code></pre>

<p>When we do this, we get an error:</p>

<pre><code>Puma starting in single mode...
* Version 3.12.1 (ruby 2.7.0-p0), codename: Llamas in Pajamas
* Min threads: 0, max threads: 16
* Environment: development
ERROR: No application configured, nothing to run
</code></pre>

<p>This is because Puma hasn’t been told what to run yet. The good thing for us is that Puma will look for a special file to know what to run. That file is called <code>config.ru</code>. Let’s create that file now:</p>

<pre><code class="language-ruby">require_relative "config/application"

Bix::Application.finalize!

run Bix::Web.app
</code></pre>

<p>This file looks a lot like <code>bin/console</code>:</p>

<pre><code class="language-ruby">#!/usr/bin/env ruby

require_relative '../config/application'

Bix::Application.finalize!

require 'irb'
IRB.start
</code></pre>

<p>The difference is that we’re starting a server, instead of starting a console session.</p>

<p>Let’s try <code>puma</code> again:</p>

<pre><code>Puma starting in single mode...
* Version 3.12.1 (ruby 2.7.0-p0), codename: Llamas in Pajamas
* Min threads: 0, max threads: 16
* Environment: development
* Listening on tcp://0.0.0.0:9292
</code></pre>

<p>Great! We now have a HTTP server listening on port 9292.</p>

<p>To test this out, we can do one of two things. If you have the marvellous <a href="http://httpie.org">httpie</a> installed, you can run this command:</p>

<pre><code>http --json post http://localhost:9292/users first_name=Ryan last_name=Bigg
</code></pre>

<p>Otherwise, if you’re using <code>curl</code>, it’s a little more verbose:</p>

<pre><code>curl --request 'POST' \
-i \
--header 'Content-Type: application/json' \
--data '{"first_name":"Ryan"}' \
'http://localhost:9292/users'
</code></pre>

<p>(Use HTTPie!)</p>

<p>Either way, what we’ll see returned here is a validation error message indicating that our input was not quite complete:</p>

<pre><code>HTTP/1.1 422 Unprocessable Entity
Content-Length: 39
Content-Type: application/json; charset=utf-8

{
    "errors": {
        "last_name": [
            "is missing"
        ]
    }
}
</code></pre>

<p>Note here that the HTTP status is 422 as well.</p>

<p>Great, so that means the <em>failure</em> case for our action is now working as we wished it would.</p>

<p>Let’s see if we can test out the success case too with this <code>http</code> call:</p>

<pre><code>http --json post http://localhost:9292/users first_name=Ryan last_name=Bigg
</code></pre>

<p>Or this <code>curl</code> one:</p>

<pre><code>curl --request 'POST' \
-i \
--header 'Content-Type: application/json' \
--data '{"first_name":"Ryan", "last_name": "Bigg"}' \
'http://localhost:9292/users'
</code></pre>

<p>Now we will see a successful response:</p>

<pre><code>HTTP/1.1 200 OK
Content-Length: 140
Content-Type: application/json; charset=utf-8

{
    "age": null,
    "created_at": "[timestamp]",
    "first_name": "Ryan",
    "id": 6,
    "last_name": "Bigg",
     "updated_at": "[timestamp]"
}

</code></pre>

<p>And that’s all now working!</p>

<h2 id="summary">Summary</h2>

<p>In this fourth and final part of the ROM and Dry showcase, we barely looked at either Rom or Dry! Instead, we looked at some pieces of the Hanami web framework.</p>

<p>The Hanami web framework is a great alternative to the Rails framework that <a href="https://ryanbigg.com/2018/03/my-thoughts-on-hanami">I’ve loved for a few years</a>. What’s been great about Hanami in this series is that we were able to opt-in to using Hanami’s <code>hanami-router</code> and <code>hanami-controller</code> gems without having to opt-in to absolutely everything else from Hanami too.</p>

<p>These gems, along with the <code>puma</code> and <code>rack</code> gems, have allowed us to build a HTTP interface to our application. Our application is now capable of receiving and responding to HTTP requests.</p>

<p>I hope that this series has given you a great demonstration of what the rom-rb, dry-rb and Hanami gems are capable of. I strongly believe that these are viable, new-age alternatives to Rails for building modern Ruby applications.</p>

<p>I hope you continue to explore what these gems can offer and how you can approach building better, easier to maintain applications with them.</p>
]]></content>
 </entry>
 
 <entry>
   <title>ROM + Dry Showcase: Part 3 - Testing</title>
   <link href="http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-3"/>
   <updated>2020-02-03T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-3</id>
   <content type="html"><![CDATA[<p>This is the 3rd part of a 4 part series covering the <a href="https://rom-rb.org/">rom-rb</a> and <a href="https://dry-rb.org/">dry-rb</a> suites of gems.</p>

<ul>
  <li>Part 1: <a href="/2020/02/rom-and-dry-showcase-part-1">Application + Database setup</a></li>
  <li>Part 2: <a href="/2020/02/rom-and-dry-showcase-part-2">Validations + Operations</a></li>
</ul>

<p>In this 3rd part, we’re going to look at how we can test the application that we’ve built so far. In particular, we’ll test three classes:</p>

<ul>
  <li>The contract – to ensure it validates input correctly</li>
  <li>The repository – to ensure we can insert data into our database correctly and that we could find data once it is inserted</li>
  <li>The operation – to ensure that we can process the whole operation correctly</li>
</ul>

<p>When we get up to the operation part, we’ll see how we can use one more feature of <code>dry-auto_inject</code> to stub out the repository dependency in this particular test. Why would we want to stub out this dependency? Because we already have tests that make sure that our repository works! We don’t need to test it again a second time in the operation class.</p>

<p>Let’s get started!</p>

<h2 id="adding-rspec">Adding RSpec</h2>

<p>First things first! We will need to set up the RSpec testing framework, and a gem called <code>database_cleaner-sequel</code>. The database cleaner gem will ensure that our database is kept pristine across the different tests in our application. If we have data “leaking” across tests, that data may influence the outcome of other tests.</p>

<p>Let’s add these gems to our <code>Gemfile</code> now:</p>

<pre><code class="language-ruby">group :test do
  gem 'rspec'
  gem 'database_cleaner-sequel'
end
</code></pre>

<p>We’ve put these gems in a “test” group, as we will not want them installed when we deploy to production.</p>

<p>Then we’ll install these gems locally with <code>bundle install</code>.</p>

<p>Next up, we can initialize RSpec by running:</p>

<pre><code>bundle exec rspec --init
</code></pre>

<p>This will create us a <code>spec</code> directory with a file called <code>spec_helper.rb</code> in it. Here’s that file with the comments removed <em>and</em> with the database cleaner configuration added:</p>

<pre><code class="language-ruby">RSpec.configure do |config|
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups

  config.before do
    DatabaseCleaner.clean
  end
end

require_relative '../config/application'
Bix::Application.finalize!

require 'database_cleaner/sequel'
DatabaseCleaner.strategy = :truncation
</code></pre>

<p>At the bottom of this file, I’ve also added two lines to require <code>config/application.rb</code> and to finalize our application. This will ensure that by
the time the tests run everything for our application has been loaded.</p>

<p>At the bottom of the <code>configure</code> block, we clean the database to ensure that each and every test starts out with a completely empty database. How that database gets cleaned is defined by the final two lines in this file: it’s a <code>truncation</code> strategy meaning that each table in our database will be truncated before the test runs.</p>

<p>That’s all the setup that we’ll need to do here. Let’s write our first couple of tests for the contract.</p>

<h2 id="testing-the-contract">Testing the contract</h2>

<p>When we go to test a contract, we want to be sure that both the valid <em>and</em> invalid paths are covered effectively. Let’s start off with the invalid paths first and we’ll finish with the valid one. We’ll create a new file in <code>spec/contracts/users/create_user_spec.rb</code>:</p>

<pre><code class="language-ruby">require 'spec_helper'

RSpec.describe Bix::Contracts::Users::CreateUser do
  context "requires first_name" do
    let(:input) do
      {
        last_name: "Bigg",
        age: 32
      }
    end

    let(:result) { subject.call(input) }

    it "is invalid" do
      expect(result).to be_failure
      expect(result.errors[:first_name]).to include("is missing")
    end
  end

  context "requires last_name" do
    let(:input) do
      {
        first_name: "Ryan",
        age: 32
      }
    end

    let(:result) { subject.call(input) }

    it "is invalid" do
      expect(result).to be_failure
      expect(result.errors[:last_name]).to include("is missing")
    end
  end
end
</code></pre>

<p>In both of these tests, we’re setting up some invalid input for the contract. And also in both of these tests, we’re asserting that the contract shows us an error indicating either the <code>first_name</code> or <code>last_name</code> fields are missing.</p>

<p>We can run this test with <code>bundle exec rspec</code>. When we do this, we’ll see that the contract is working as intended:</p>

<pre><code>2 examples, 0 failures
</code></pre>

<p>This is good to see, and will now provide us with a safety net. If someone was to delete one of the lines from the contract <em>perhaps accidentally</em>, then our tests would catch that.</p>

<p>Let’s add another test for the happy path, the path of successful validation, to this file too:</p>

<pre><code class="language-ruby">RSpec.describe Bix::Contracts::Users::CreateUser do
  context "given valid parameters" do
    let(:input) do
      {
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32
      }
    end

    let(:result) { subject.call(input) }

    it "is valid" do
      expect(result).to be_success
    end
  end

  ...
</code></pre>

<p>In this test, we provide all the correct values for the input and therefore our contract should be successful. Let’s run the tests again and see:</p>

<pre><code>3 examples, 0 failures
</code></pre>

<p>Great!</p>

<p>We’re able to test our contract just like a standard Ruby class. We initialize the contract, and then depending on the input it is given, the contract with either succeed or fail.</p>

<h2 id="testing-the-repository">Testing the repository</h2>

<p>To test the repository, we can take the same kind of path. For this repository’s tests, we need to assert that the <code>create</code> method for <code>Bix::Repos::UserRepo</code> does a few things. What things? Well, let’s look at our code for the repository:</p>

<pre><code class="language-ruby">module Bix
  module Repos
    class UserRepo &lt; ROM::Repository[:users]
      include Import["container"]

      struct_namespace Bix

      commands :create,
        use: :timestamps,
        plugins_options: {
          timestamps: {
            timestamps: %i(created_at updated_at)
          }
        }

      def all
        users.to_a
      end
    end
  end
end
</code></pre>

<p>The repository has a <code>create</code> method and with this method we need to make sure:</p>

<ul>
  <li>The method returns a <code>Bix::User</code> object – because <code>struct_namespace</code> has configured the repository to use the <code>Bix</code> namespace for all structs.</li>
  <li>That the <code>Bix::User</code> object returned has an <code>id</code> attribute – this ID is automatically set by the database</li>
  <li>That both <code>created_at</code> and <code>updated_at</code> are set automatically – based on how we’ve configured the command at the top of the repository.</li>
</ul>

<p>The repository also has an <code>all</code> method, and just to be thorough we can add a simple test for this method to assert that <code>Bix::User</code> objects are returned.</p>

<p>Let’s add the tests for the <code>create</code> method first. We’ll create a new file at <code>spec/repos/user_repo_spec.rb</code> for these tests:</p>

<pre><code class="language-ruby">require "spec_helper"

RSpec.describe Bix::Repos::UserRepo do
  context "#create" do
    it "creates a user" do
      user = subject.create(
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32,
      )

      expect(user).to be_a(Bix::User)
      expect(user.id).not_to be_nil
      expect(user.first_name).to eq("Ryan")
      expect(user.last_name).to eq("Bigg")
      expect(user.created_at).not_to be_nil
      expect(user.updated_at).not_to be_nil
    end
  end
end
</code></pre>

<p>This test asserts that when we call <code>create</code> on our repository that it will return a <code>Bix::User</code> object and that the object has values for <code>id</code>, <code>first_name</code>, <code>last_name</code>, <code>created_at</code> and <code>updated_at</code>.</p>

<p>If we run this test with <code>bundle exec rspec</code>, we’ll see that it passes:</p>

<pre><code>4 examples, 0 failures
</code></pre>

<p>Good! We’ve now asserted that at least the <code>struct_namespace</code> and <code>commands</code> methods from our repository are working as they should. If a mistake was to be made, like accidentally removing the <code>struct_namespace</code> method from the repository, our test would break:</p>

<pre><code>  1) Bix::Repos::UserRepo#create creates a user
     Failure/Error: expect(user).to be_a(Bix::User)
       expected #&lt;ROM::Struct::User ...&gt; to be a kind of Bix::User
</code></pre>

<p>The issue with this repository returning a <code>ROM::Struct::User</code> object instead of a <code>Bix::User</code> object is that the <code>ROM::Struct::User</code> objects will not have access to any of <code>Bix::User</code>’s methods, like <code>full_name</code>. If we had this mistake in our application, and we tried using <code>User#full_name</code> then our application would break. This demonstrates why it’s important to have tested that <code>struct_namespace</code> is working.</p>

<p>Let’s add another quick test to our repository to test <code>all</code>:</p>

<pre><code class="language-ruby">context "#all" do
  before do
    subject.create(first_name: "Ryan", last_name: "Bigg", age: 32)
  end

  it "returns all users" do
    users = subject.all
    expect(users.count).to eq(1)
    expect(users.first).to be_a(Bix::User)
  end
end
</code></pre>

<p>This test uses <code>create</code> to setup a user in our database, and then asserts that when we call <code>all</code> we get a user back.</p>

<p>If we run this test, we’ll see that it’s already working:</p>

<pre><code>5 examples, 0 failures
</code></pre>

<p>This means that our <code>all</code> method now has some test coverage. If this method was to break <em>somehow</em>, then our test would indicate that the method was faulty and then we wwould know to fix it.</p>

<h2 id="testing-the-operation">Testing the operation</h2>

<p>So far, our testing of contracts and repositories has been very straightforward Ruby class tests. We have relied on <code>subject</code> from RSpec which is a method that behaves like this:</p>

<pre><code>def subject
  &lt;described class&gt;.new
end
</code></pre>

<p>Now we’re going to look at how to test a operation, and here’s where things are going to get more interesting. Rather than relying on RSpec’s own <code>subject</code>, we’re going to define our own. And when we define our own, we’re going to use a feature of <code>dry_auto-inject</code>, called <em>dependency injection</em>. This feature will allow us to inject a stubbed repository into our operation, so that we don’t have to hit the database for our operation’s test.</p>

<p>Not hitting the database means that we will save time on this test: there’s no need to make a request to a system outside of our Ruby code, and that’ll also mean that <code>database_cleaner</code> will not need to clean anything from the database. Ultimately, by injecting the repository dependency into our application’s operations when we’re testing them means that we can have fast transaction tests.</p>

<p>Let’s look at how to do this by creating a new file at <code>spec/operations/users/create_user_spec.rb</code>:</p>

<pre><code class="language-ruby">require 'spec_helper'

RSpec.describe Bix::Operations::Users::CreateUser do
  let(:user_repo) { double("UserRepo") }
  let(:user) { Bix::User.new(id: 1, first_name: "Ryan") }

  subject { described_class.new(user_repo: user_repo) }

  context "with valid input" do
    let(:input) do
      {
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32,
      }
    end

    it "creates a user" do
      expect(user_repo).to receive(:create) { user }
      result = subject.call(input)
      expect(result).to be_success
      expect(result.success).to eq(user)
    end
  end
end
</code></pre>

<p>In this test, we define our own <code>subject</code> block, which will override RSpec’s default. We inject the <code>user_repo</code> dependency into the operation object by passing a <code>user_repo</code> key in the <code>new</code> method. This works because <code>dry-auto_inject</code> re-defines <code>initialize</code> for classes when we use this syntax:</p>

<pre><code class="language-ruby">include Import[
  "contracts.users.create_user",
  "repos.user_repo"
]
</code></pre>

<p>By default, <code>dry-auto_inject</code> will load the contract class <code>Bix::Contracts::Users::CreateUser</code>, as well as the repo class <code>Bix::Repos::UserRepo</code> and provide them to the class through the <code>create_user</code> and <code>user_repo</code> methods automatically. The keys that we provide to <code>Import[]</code> here match the keys that are automatically defined by <code>dry-system</code> when it automatically registers the components for our application.</p>

<p>If we want to swap in something else for either the contract or the repository, we can do that by passing in a key matching the name (either <code>create_user</code> or <code>user_repo</code>) when we initialize this class. Just like we do in our test!</p>

<p>If we wanted to do this ourselves, without any sort of dry gem magic, it would look like this:</p>

<pre><code class="language-ruby">attr_reader :user_repo, :create_user

def initialize(
  user_repo: Bix::Repos::UserRepo.new,
  create_user: Bix::Contracts::Users::CreateUser.new
)
  @user_repo = user_repo
  @create_user = create_user
end
</code></pre>

<p>As we can see, by using <code>dry-auto_inject</code> along with <code>dry-system</code> we get to save a lot of typing.</p>

<p>Let’s look at that test again:</p>

<pre><code class="language-ruby">require 'spec_helper'

RSpec.describe Bix::Operations::Users::CreateUser do
  let(:user_repo) { double(Bix::Repos::UserRepo) }
  let(:user) { Bix::User.new(id: 1, first_name: "Ryan") }

  subject { described_class.new(user_repo: user_repo) }

  context "with valid input" do
    let(:input) do
      {
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32,
      }
    end

    it "creates a user" do
      expect(user_repo).to receive(:create) { user }
      result = subject.call(input)
      expect(result).to be_success
      expect(result.success).to eq(user)
    end
  end
end
</code></pre>

<p>The test asserts that when we use <code>subject.call</code> that the repository receives the <code>create</code> method once. We’ve stubbed this method to return a <code>Bix::User</code> object, and that’s what we’ll see when we call <code>result.success</code> at the end of the test.</p>

<p>Let’s run this test and we’ll see how it goes:</p>

<pre><code>6 examples, 0 failures
</code></pre>

<p>Success! We’re able to test our operation without it hitting the database at all. This means that our operation test is isolated from the database, leading to it being quick. While we only have one operation test <em>now</em>, as this application grows and we add further operation tests this quickness will quickly pile-up to a big benefit.</p>

<p>There’s also another benefit of this isolation: if we had database constraints then we would have to cater for those in this test.  Imagine for instance that when we created users that they had to be associated with a “Group” and that Groups had to be associated with an “Account”. In a normal application to test such a thing, we would need to create three separate objects our database: an account, a group, and a user.</p>

<p>For one test, it won’t matter too much. But if accounts, groups and users are the <em>core</em> of our application, it would quickly stack up to lots of database calls. By stubbing out the user repository dependency while testing this operation, we have isolated that test from any database concern. A better place to test that sort of database concern would be in the repository test, anyway.</p>

<p>To finish up, let’s add one more test for what happens when this operation fails due to invalid input:</p>

<pre><code class="language-ruby">context "with invalid input" do
  let(:input) do
    {
      last_name: "Bigg",
      age: 32,
    }
  end

  it "does not create a user" do
    expect(user_repo).not_to receive(:create)
    result = subject.call(input)
    expect(result).to be_failure
    expect(result.failure.errors[:first_name]).to include("is missing")
  end
end
</code></pre>

<p>This <code>input</code> is missing a <code>first_name</code> key, and so our operation should fail. This means that the <code>user_repo</code> should <em>never</em> receive a <code>create</code> method, because our operation will only call that if the <code>validate</code> step passes. When the validation fails, we would expect the result from this operation to be a failure, and that failure to contain errors indicating what went wrong.</p>

<p>When we run this test with <code>bundle exec rspec</code>, we’ll see it pass:</p>

<pre><code>7 examples, 0 failures
</code></pre>

<h2 id="summary">Summary</h2>

<p>In this 3rd part of the ROM and Dry showcase, we’ve seen how easy it is to add tests to our application to ensure that the individual parts of the application are working.</p>

<p>We saw that in order to test a contract and a repository, we can initialize either class and call the methods we want to test. There’s nothing particularly special that we’ve had to do to test these classes; we treat them like the plain Ruby classes they are.</p>

<p>When testing the operation, we’ve chosen to isolate those tests from the database by injecting a stubbed <code>UserRepo</code> object in place of the real thing. This isolation will mean that our tests will not have to concern themselves with setting up database state – for instance, if we had foreign key constraints – and over time it will mean that our operation tests will be lightning fast.</p>

<p>In the next part of this series, we’ll add the final piece of our application to our stack: a way to make HTTP requests. And we’ll <em>definitely</em> be adding tests for this too!</p>
]]></content>
 </entry>
 
 
</feed>