<?xml version="1.0" encoding="iso-8859-1"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>The Life of a Radar</title>
 <link href="http://ryanbigg.com/atom.xml" rel="self"/>
 <link href="http://ryanbigg.com"/>
 <updated>2021-07-29T09:17:09+10:00</updated>
 <id>http://ryanbigg.com/</id>
 <author>
   <name>Ryan Bigg</name>
   <email>radarlistener@gmail.com</email>
 </author>

 
 <entry>
   <title>On coding tests</title>
   <link href="http://ryanbigg.com/2021/07/on-coding-tests"/>
   <updated>2021-07-27T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/07/on-coding-tests</id>
   <content type="html"><![CDATA[<p>As you might know, I’ve been <a href="https://ryanbigg.com/2021/07/job-hunt-q2-2021">job hunting recently</a>. I’m at the part of this step for some companies where we’ve had our initial conversation and now they want me to do a coding test.</p>

<p>But that’s okay, because it “should only take up to 3 hours to do”. Now let’s theoretically say that I’m talking with 5 companies now. That’s <em>15 hours</em> of my time, that I have to pull out of work, life or sleep, to do these coding tests. All to prove to them that I can code!</p>

<p>This strikes me as odd because I’m pretty sure I can code.</p>

<p>I’ve been employed as a developer in one way or another since 2004. That’s 17 years! I’ve had to pass other coding tests in the past to get some of those jobs. I had a lot more free time in my youth and wasn’t such a crotchety old man like I am now.</p>

<p>I’ve <a href="https://ryanbigg.com/books">written books</a> where I try to teach other people how to code. If I don’t know how to code, how could I teach other people to code? Mystery!</p>

<p>I’ve recently <a href="https://www.youtube.com/watch?v=qWdyo3icsjU">released a 6-part screencast series</a> where I demonstrate my ability to code in not one, but THREE different languages <strong>AT THE SAME TIME</strong>! I’m clearly not a 10x developer. Maybe a 3x developer?</p>

<p>I’ve even made the <a href="https://github.com/radar/twist-v2">codebase from that screencast series completely open source</a>.</p>

<p>But no, these things don’t count for <em>anything</em> in the interview process. Maybe I’ve gone too far down the path of tying my self-worth up in these things. The way I feel is: if you don’t value these things I’ve <em>already done</em>, then you do not value me.</p>

<hr />

<p>I can read the replies now:</p>

<blockquote>
  <p>but how do we know that you really know how to code, according to our 100% bias-free baseline?</p>
</blockquote>

<blockquote>
  <p>We have subjected our other developers to this antiquated hazing ritual so why shouldn’t we subject you to the same?</p>
</blockquote>

<p>Fact is, you don’t. Some people can code really well in interviews and have had lots of practice answering how exactly you go about reversing a purple linked list uphill both ways in the snow. Some people struggle with the pressure of developing something <em>completely solo</em> and then having that scruitinised in an hour-long live-code-review session.</p>

<p>I’m personally <em>done</em> with being hazed in this way. You know I can code. I have proven this with my long tenure in this industry and the stuff I’ve put out in the world.</p>

<p>Let’s just get down to business. I’ll happily trade labour for dollars. Hold the haze. Use the books, code and screencast I’ve already put out in order to judge my abilities.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Using Ruby 2.7's new triple-dot syntax to clean up service objects</title>
   <link href="http://ryanbigg.com/2021/07/ruby-27s-new-triple-dot-syntax"/>
   <updated>2021-07-21T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/07/ruby-27s-new-triple-dot-syntax</id>
   <content type="html"><![CDATA[<p>In big Rails projects there’s been a bit of a push to move things out to <em>service objects</em>. You might recognise these from their appearance in things like controllers:</p>

<pre><code class="language-ruby">CreateBook.new.call(book_params)
</code></pre>

<p>The <code>CreateBook</code> class itself might look like this:</p>

<pre><code class="language-ruby">class CreateBook
  include Dry::Monads[:do, :result]

  def call(params)
    book_params = yield validate(params)
    create_book(book_params)
  end
end
</code></pre>

<p>In order to access that instance <code>call</code> method from the controller, we must first create an instance of this <code>CreateBook</code> class. This makes our code <em>slightly</em> messy because we must always <code>new</code> before we <code>call</code>. The <code>call</code> here <em>must</em> be an instance method because we’ve included <code>Dry::Monads</code> methods within instances of this class, as per the best-practices when using that gem.</p>

<p>However, we can tidy things up here by using Ruby 2.7’s new triple-dot syntax. This syntax is another special type of argument, used in the same place you might use positional or keyword arguments. We can use triple-dots to pass arguments from a class method down to an instance method, like in this example:</p>

<pre><code class="language-ruby">class CreateBook
  include Dry::Monads[:do, :result]

  def self.call(...)
    new.call(...)
  end

  def call(params)
    book_params = yield validate(params)
    create_book(book_params)
  end
end
</code></pre>

<p>Anytime the <code>call</code> method on the <em>class</em> is called, a new <code>CreateBook</code> <em>instance</em> is created, then those arguments from the class-level <code>call</code> are passed to the instance-level <code>call</code>. By defining this new <code>call</code> method on the class itself, we can then change our controller to this:</p>

<pre><code class="language-ruby">CreateBook.call(book_params)
</code></pre>

<p>This makes our code out to the <code>CreateBook</code> class from wherever we’re using it slightly easier, while still allowing us to create &amp; use instances of <code>CreateBook</code> if we wish. One particular case where that might come in handy is if you wanted to inject a dependency here:</p>

<pre><code class="language-ruby">CreateBook.new(book_repository: book_repo).call(book_params)
</code></pre>

<p>But that’s a story for another day.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Job Hunt Q2 2021</title>
   <link href="http://ryanbigg.com/2021/07/job-hunt-q2-2021"/>
   <updated>2021-07-19T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/07/job-hunt-q2-2021</id>
   <content type="html"><![CDATA[<p>After <a href="https://ryanbigg.com/2021/04/finding-a-new-contract-gig">wrapping up a contract</a> earlier in the year, I wrote a post about how I looked for a future job. Now it’s around about the time that <em>that</em> job is wrapping up. So why not write another post about this hunt? Maybe there are some things that are different.</p>

<p>Last time I pitched myself as a “mercenary developer wizard”. While I enjoy developing code, nothing brings more joy than developing <em>people</em>. Running the Culture Amp JEP was some of the most fun-at-work I’ve had. I would love to do that stuff again. So I’ve been pitching myself this time as someone who would rather be developing people, than developing code. I could definitely do both!</p>

<p>The appetite for this sort of work has been incredibly lacking. It appears from my perspective that more companies are <em>still</em> more interested in hiring senior “mercenary developer wizards” who can “crush code”, than training up <em>any</em> developers at all.</p>

<p>I’ve been <a href="https://ryanbigg.com/2019/09/hiring-juniors-2019">banging the drum around hiring juniors</a> for almost a decade. For the status quo to remain the same for this time is disheartening. Perhaps the developer drought is not severe enough for companies to act. The impetus is not strong enough. <em>Despite</em> all these companies being so ravenously thirsty for senior developers.</p>

<p>I dearly, desperately want a job where I am not <em>just</em> somebody who can crush code, but someone who gets to work with other people to improve their skills. That’s my jam. That’s where I get the joy.</p>

<p>But, fine. Okay. That job doesn’t (seemingly) exist.</p>

<p>I need to be real.</p>

<p>So I’ll just go and pick up a senior dev role at some shop somewhere, “crush code” and earn a paycheck so I can pay my mortgage.</p>

<p>I’m disheartened by the current outcomes from the current iteration of the job hunting process, but things have changed before and might change again.</p>

<p>Always the next step.</p>
]]></content>
 </entry>
 
 <entry>
   <title>How I found a new contract gig</title>
   <link href="http://ryanbigg.com/2021/04/finding-a-new-contract-gig"/>
   <updated>2021-04-29T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/04/finding-a-new-contract-gig</id>
   <content type="html"><![CDATA[<p>I’ve resolved this year to work as a developer-for-hire / contractor / sole-trader / mercenary developer wizard. This decision came after what was frankly an unmitigated disaster of a year-and-a-bit with two redundancies in a row topped off with being fired. Thanks, 2020. Go fuck yourself.</p>

<p>As a “mercenary developer wizard”, I talk to people, we agree to work together for a period of time, we do the work, we make sure everyone’s happy with the work, then they pay me money. Sometimes I’ll tweet the odd rant about how Rails is bad, even though it pays all my bills. It’s a neat arrangement.</p>

<p>Recently, I’ve had to start looking for work again, this time due to a contract wrapping up. No, I wasn’t fired <em>this time</em>. We just had a discussion and decided we did almost everything we set out to do together. Amicable!</p>

<p>It’s a sellers’ market out there at the moment. I have joked in the past while working on the 10th floor of an office building that I could sit at my desk, tweet that I was looking for work, and by the time I was out the front door of the lobby I’d have at least one offer. While this hasn’t yet played out in truth, it’s a bit like that. Fastest “lead time” to being approached for a job was 28 minutes after an initial message.</p>

<p>So I started my hunt about 2 weeks ago, putting messages out on Twitter, Linked In, and three local Australian Developer Slack groups.</p>

<blockquote>
  <p>Hello! I’m looking for my next contract starting after May 7th. Remote only, based in Warrnambool. Can code React / TypeScript / CSS / Ruby / Elixir, etc. ~15 years experience. I care about reliable software, up-skilling the team that I join, and leaving things better than I how I found them.</p>

  <p>There’s a bit more history here: <a href="https://ryanbigg.com/work">https://ryanbigg.com/work</a>.</p>

  <p>Happy to talk in DM or via email: me@ryanbigg.com</p>
</blockquote>

<p><strong>Within those 2-and-a-bit weeks, I received 12 offers for future contracts.</strong></p>

<p>See? Sellers’ market.</p>

<p>Having no particular allegiance to an industry makes it particularly hard to choose where to go next. However, there’s some places I could exclude right off the bat by using a list I have written up:</p>

<ul>
  <li>Cryptocurrency - Fancy ponzi scheme that does nothing good for the world</li>
  <li>Advertising / marketing  — slimy.</li>
  <li>Betting / Gambling — I don’t like gaming other people’s addictive behaviours.</li>
  <li>Smoking / Vaping — I find smoking in all forms extremely anti-social.</li>
  <li>Real Estate - I’ve had enough dealings with real estate agents, thank you.</li>
  <li>Working on an entire team with people like me (white, straight, male)</li>
</ul>

<p>While that helped to cull <em>some</em> of the list, I was still left with about 7.</p>

<p>What happens next is that reply with a standard professional “no thanks” to those who I’ve “culled”, even though my heart wants to say things like “AW HELL NAH” and “not in a million years, bucko”. Best to reply professionally and they go on their merry way than to start a fight with some internet stranger.</p>

<p>So then what I need to do is actually <em>talk to people</em>. If you’re a developer and you’re reading this you might have just had a cold shiver. I know, I know. Talking to people. Over the phone. EWWW. Part of doing business as a consultant. Must be done. Like the washing up and flossing your teeth.</p>

<p>What I find out here is a few things:</p>

<ul>
  <li>Are you okay with me working only 4 days a week?</li>
  <li>Are you okay with me working remotely from Warrnambool, Victoria?</li>
  <li>Are you okay with me not being able to come into your office, ever?</li>
  <li>What’s the project?</li>
  <li>How is it helping to improve the world?</li>
  <li>What’s the potential duration of our engagement?</li>
  <li>How big is the team?</li>
  <li>Who’s on the team? What’s the mix of seniority?</li>
  <li>What’s the tech stack look like?</li>
  <li>How’s the code deployed to production?</li>
  <li>How’s the work managed / triaged / approved?</li>
  <li>(And if I’m feeling cheeky) What’s hard about working there?</li>
</ul>

<p>The first 3 questions here are big deal-breakers. I enjoy spending a day of my week free to do writing and chores and then spending the weekend doing things with my family. The Warrnambool thing is… well, it’s where I live. And commuting <em>ever</em> into an office is a dealbreaker as I’m solo-parenting a 4-year-old, 4-days-a-week and I need to be there for kindergarten drop-off in the morning and pickup in the evening. I really don’t think she’ll want to be waiting for daddy’s train to get back at 10pm at night, do you?</p>

<p>These initial questions were not okay for some clients, and them’s the breaks. Some people want full-time, some people want hybrid-remote. That’s okay, we can talk about it and say “not yet” and go no further.</p>

<p>This time around I’ve put a bit of an emphasis on the team composition + size, as I want to spend more time working with more people than I have done thus far for my contracting gig. A bigger team “ranked higher” in my scoring for this round.</p>

<p>The tech stack / deployment questions give me a bit of data which I like to think of similar to a <a href="https://en.wikipedia.org/wiki/Kardashev_scale">Kardashev Scale</a>. Things I look for here are:</p>

<ul>
  <li>Card kickoffs</li>
  <li>Software used for tracking work (ala Jira / Trello / etc.)</li>
  <li>Retrospective frequency</li>
  <li>Sprint duration</li>
  <li>How is tech debt prioritised?</li>
  <li>Is there one shared staging environment, or can you deploy a pull request to its own staging environment?</li>
  <li>Is there more than one frontend framework at play?</li>
</ul>

<p>This information gives me an idea of how (dys)functional things are currently, and gives me a good idea of where I could potentially help to improve things. Every tech company is dysfunctional at <em>something</em>, and so I try and drag it out of people during the interview phase first, before I find out about it while working there. Because I will find out.</p>

<p>All of this above information goes into a huge database (read: cyclone) in my brain and mixes around in there for days on end.</p>

<p>In particularly this time around I’m looking for:</p>

<ul>
  <li>A team larger than 2.</li>
  <li>Comprised of a mix of skill levels (because there’s some training opportunities there!)</li>
  <li>A team that can rely on each other to get things done, and relies on each others’ skills</li>
  <li>Solving a real-world, real-human problem (<em>not fucking cryptocurrency</em>)</li>
  <li>A tech stack that’s cared for and maintained</li>
</ul>

<p>Ultimately, this helped it narrow it down from <em>7</em> to <em>1</em>.</p>

<p>Then I spent more time thinking about it by asking myself questions like:</p>

<ul>
  <li>Would I feel proud to have worked here after 3-6 months?</li>
  <li>Would I want to <em>continue</em> working here after that time, if it was offered?</li>
  <li>If I told people what I was working on, would it matter to them? Would they see the utility of it?</li>
</ul>

<p>And that really helped me make the final decision and to know that this was the right decision to make.</p>

<p>So on May 10th, I’ll start working at a new gig, still writing Rails (and tweeting about it) and some TypeScript / React for the next 3 months, working on a mid-sized team, helping everyone get to where we need to be. And possibly longer than that!</p>
]]></content>
 </entry>
 
 <entry>
   <title>View Components: The Missing Link</title>
   <link href="http://ryanbigg.com/2021/04/view-components-the-missing-link"/>
   <updated>2021-04-07T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2021/04/view-components-the-missing-link</id>
   <content type="html"><![CDATA[<p>There has been an uptick in making Rails play nice with React recently, made possible by gems such as <a href="https://github.com/reactjs/react-rails">react-rails</a>. The <code>react-rails</code> gem allows you to inject React components into your Rails views like this:</p>

<pre><code class="language-erb">&lt;%= react_component("HelloWorld", { greeting: "Hello from react-rails." }) %&gt;
</code></pre>

<p>The first argument here is the component name, and the hash at the end is the props that get passed down to the component.</p>

<p>This gem serves a very useful purpose, but I think there’s a missing link here and I want to show you what that link is, and how best to leverage it.</p>

<h3 id="complicated-props-crowd-up-the-view">Complicated props crowd up the view</h3>

<p>Sometimes, we want to pass a bunch of props through to a React component. Maybe it starts out as one prop and then grows to ten props. This can get really messy:</p>

<pre><code class="language-erb">&lt;%= react_component("UserPicker", { users: @users.map { |user| { value: user.id, label: user.name }} }, selectedUserIds: @selected_user_ids }) %&gt;
</code></pre>

<p>As a component grows in complexity, the amount of Ruby in the view continues to grow and grow. Views are sometimes treated like a dumping ground: “well, this <em>can’t</em> go in the model and it <em>shouldn’t</em> go in the controller… guess I’ll just leave it here in the view!”</p>

<p>Yes, this could be more clearly written with some line breaks:</p>

<pre><code class="language-erb">&lt;%= react_component("UserPicker", {
  users: @users.map do |user|
    { value: user.id, label: user.name }
  end,
  selectedUserIds: @selected_user_ids
}) %&gt;
</code></pre>

<p>But that still feels quite clunky!</p>

<h3 id="enter-view-components">Enter, view components</h3>

<p>GitHub, has released a gem called <a href="https://github.com/github/view_component/">view_component</a> which aims to solve this problem in a neat way. The <code>view_component</code> gem defines new classes where you can put complicated view logic, and separates those views into their own directory too.</p>

<p>Let’s take our <code>UserPicker</code> component from above. This now becomes a class called <code>UserPickerComponent</code>, and lives at <code>app/components</code>:</p>

<pre><code class="language-ruby">class UserPickerComponent &lt; ViewComponent::Base
  attr_reader :users, :selected_user_ids

  def initialize(users:, selected_user_ids:)
    @users = users
    @selected_user_ids = selected_user_ids
  end

  def props
    user_props = @users.map { |user| { value: user.id, label: user.name } }

    {
      users: user_props,
      selectedUserIds: @selected_user_ids
    }
  end
end
</code></pre>

<p>That’s much nicer! Our Ruby code is now where it belongs: in a <em>Ruby</em> file. The code that converts the users to an array-of-hashes with <code>value</code> and <code>label</code> key now feels at home in this file and has stopped clogging up our ERB file.</p>

<p>But where’s our ERB code that renders this React component? Isn’t that back over in <code>app/views</code>? Well, yeah it is! But we can move that code now into the <em>other half</em> of <code>view_component</code>, a special view component ERB file at <code>app/components/user_picker.html.erb</code>:</p>

<pre><code class="language-erb">&lt;%= helpers.react_component "UserPicker", **props %&gt;
</code></pre>

<p>View component renders components using a combination of the Ruby class and the ERB template, both named the smae.</p>

<p>To access the <code>react_component</code> helper, we need to use the <code>helpers</code> method provided by <code>view_component</code>. But there’s not much difference here to what we had earlier in a view.</p>

<p>The main thing to note is that our Ruby code now lives in a Ruby file, and the code to render the React component lives over in the component’s view. If we had any additional HTML that was required to be wrapped around this component, this is where it would belong too. I’ve left that out to make things simple here.</p>

<h3 id="rendering-a-view-component">Rendering a view component</h3>

<p>With the Ruby and ERB nicely separated into a view <em>component</em>, it’s time to add that code back to our view. We will first need to initialize the component in the controller action:</p>

<pre><code class="language-ruby">def new
  @user_picker_component = UserPickerComponent.new(
    users: @users,
    selected_user_ids: @selected_user_ids,
  )
end
</code></pre>

<p>Then we can render the component, just like we would render a partial, by calling <code>render</code> in the view for the action:</p>

<pre><code class="language-erb">&lt;%= render(@user_picker_component) %&gt;
</code></pre>

<p>And there you have it, a clear separation between the responsibilities for rendering a React component within a Rails application. We now have:</p>

<ul>
  <li>The controller action: responsible for collection information based on the request, and prepares the component</li>
  <li>The view: tells Rails where we want to put the component</li>
  <li>The component Ruby class: container for any Ruby code that we need to run <em>before</em> rendering our React component, but <em>after</em> the controller has done its duty</li>
  <li>The component view file: a clearly separated file that concerns itself with only rendering a React component</li>
</ul>

<h3 id="translations">Translations</h3>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">How are people taking i18n translations and making them available to React components these days?</p>&mdash; Ryan Bigg (@ryanbigg) <a href="https://twitter.com/ryanbigg/status/1379259002731646979?ref_src=twsrc%5Etfw">April 6, 2021</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>A few days ago, I started experimenting with the right ways to pass translations down to these React components from Ruby.</p>

<p>A few replies to the above tweet were along the lines of “just load all 644kb of JSONified I18n translations on every page load! Your users will love you!” and if this is supposed to be the latest-and-greatest of web development please let me off this wild ride.</p>

<p>Having a view component means that we have somewhere that we can run calls to <code>I18n.t</code>, and then pass these as strings through to our React component. Here, let’s have a look:</p>

<pre><code class="language-ruby">class UserPickerComponent &lt; ViewComponent::Base
  attr_reader :users, :selected_user_ids

  def initialize(users:, selected_user_ids:)
    @users = users
    @selected_user_ids = selected_user_ids
  end

  def props
    user_props = @users.map { |user| { value: user.id, label: user.name } }

    {
      users: user_props,
      selectedUserIds: @selected_user_ids
      translations: translations
    }
  end

  private

  def translations
    scope = "users.picker"

    {
      selectAUser: helpers.t("select_a_user", scope: scope)
    }
  end
end
</code></pre>

<p>In the component file, we’re now defining an extra method called <code>translations</code>. This is then going to add one extra prop to our React component, and definitely <em>won’t</em> be sending 664kb of JSONified I18n translations to our users.</p>

<p>To access these translations in the component, we access them the same as any other property:</p>

<pre><code class="language-tsx">const UserPicker = ({ translations, users, seelectedUserIds}) =&gt; {

  return (
    // ...
    &lt;p&gt;{translations.selectAUser}&lt;/p&gt;
  )
}
</code></pre>
]]></content>
 </entry>
 
 <entry>
   <title>The Bikeshed</title>
   <link href="http://ryanbigg.com/2021/03/the-bikeshed"/>
   <updated>2021-03-29T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/03/the-bikeshed</id>
   <content type="html"><![CDATA[<p>Hello.</p>

<p>This is a meeting to discuss the bike shed project. I called this 2.5hr long meeting (running until 1pm) on a Monday so we can start the week by deciding the way forward for the bike shed project.</p>

<p>As the senior consultant here I have some ideas.</p>

<p>The previous bike shed colour did not test well with our beta users and we were particularly ravaged by that one guy on Twitter in an extensive 46-tweet thread. Turns out, chatruese is his ex-wife’s favourite colour. Due to the above reasons, we will be deciding on a new colour for the bike sheds.</p>

<p>We are A/B testing new colours with a focus group that is including not only bike riders but also drivers, motorbike riders and those people with the electronic skateboards. The upcoming Bike Shed 2.0 project will be catering for their needs too.</p>

<p>Dave 3 from our consulting team has determined that the previous consultants did a poor job architecting the bike shed and as such it is not up to code. Daves 2 through 5 recommend a rebuild, while Daves 1 and 6 are still on the fence. That is, they’re on BAU work for the Fence Alpha release that was due out a week and a half ago.</p>

<p>Dave 3 estimates the rebuild of the bike shed will take approximately 3 months, which coincidentally is two weeks longer than our contract lasts for. We will talk to the management here about renewing our contract for another 12 months.</p>

<p>Are there any questions before we begin?</p>
]]></content>
 </entry>
 
 <entry>
   <title>Maintainable Rails</title>
   <link href="http://ryanbigg.com/2021/03/maintainable-rails"/>
   <updated>2021-03-23T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/03/maintainable-rails</id>
   <content type="html"><![CDATA[<p><em>This is the Preface from my book, <a href="https://leanpub.com/maintain-rails">Maintainable Rails</a>, available on Leanpub for half-price ($10USD) for the next month. Maintainable Rails demonstrates how to separate out the distinct responsibilities of a Rails application into smaller classes, leading to a more maintainable Rails application architecture.</em></p>

<hr />

<p>When Rails came out, it was revolutionary. There was an order to everything.</p>

<p>Code for your business logic or code that talks to the database <em>obviously</em>
belongs in the model.</p>

<p>Code that presents data in either HTML or JSON formats <em>obviously</em> belongs in
the view.</p>

<p>Any special (or complex) view logic goes into helpers.</p>

<p>The thing that ties all of this together is <em>obviously</em> the controller.</p>

<p>It was (and still is) neat and orderly. Getting started with a Rails
application is incredibly easy thanks to everything having a pre-assigned home.</p>

<p>The Rails Way™ enforces these conventions and suggests that this is the
One True Way™ to organise a Rails application. This Rails Way™ suggests that,
despite there being over a decade since Rails was crafted, that there still is
no better way to organise an application than the MVC pattern that Rails
originally came with.</p>

<p>While I agree that this way is still extremely simple and great for <em>getting
started</em> within a Rails application, I do not agree that this is the best way to
organise a Rails application in 2021 with long-term maintenance in mind.</p>

<p>As a friend of mine, <a href="https://twitter.com/bjeanes">Bo Jeanes</a> put it neatly once:</p>

<blockquote>
  <p>Code is written for the first time only once.</p>

  <p>Then there is anywhere between 0 and infinite days of having to change that code, understand that code, move that code, delete that code, document that code, etc. Rails makes it easy to write that code and to do some of those things early on, but often harder to do all the those things on an ongoing basis.</p>

  <p>We benefit by being patient in that first period and maybe trading off some of that efficiency for a clarity and momentum for the <em>life</em> of the project.</p>
</blockquote>

<p>A decade of Ruby development has produced some great alternatives to Rails’
MVC directory structure that are definitely worthwhile to consider.</p>

<p>In this book, I want to show an <em>alternative</em> viewpoint on how a Rails
application should be organised in order to increase its maintainability.</p>

<p>These are the best pieces that I’ve found to work for me and others.</p>

<p>This research for how to construct a better Rails application comes out of 15 years worth of developing Rails applications.</p>

<p>To best understand why this alternative architecture is a better approach, we must first understand the ways in which Rails has failed.</p>

<h2 id="where-rails-falls-down">Where Rails falls down</h2>

<p>The Original Rails Way™ falls down in at least three major areas in my opinion. Three major areas that have to do with organization. Coincidentally (or not), these three areas are the major highlights of the way Rails suggests you organize applications: models, controllers, and views.</p>

<p>Let’s start with controllers.</p>

<h2 id="messy-controllers">Messy controllers</h2>

<p>The controller’s actions talk to the model, asking the model to create, read, update or delete records in a database. And then this controller code might do more: send emails, enqueue background jobs, make requests to external services. There is no pre-determined, widely agreed-upon location for this logic; the controller is the de facto place. A controller action can often have request logic, business logic, external API calls and response logic all tied up in the one method, typically inside the action itself.</p>

<p>If this logic is not inside of the actions themselves, it is then likely found in private methods at the bottom of the controller. This leads to a common anti-pattern seen in Rails applications, one called the “iceberg controller”. What appears to be a small handful of clean actions is actually masking 100+ lines of private methods defined underneath. It is not immediately clear from scanning through these private methods which private method is used in which action. Or even if they <em>are</em> used at all!</p>

<p>Testing all these intertwining parts individually is hard work. To make sure that it all works together, you often have to write many feature and/or request tests to test the different ways that the controller action is called and utilized. The logic of the controller’s actions – those calls out to the model – get intimately acquainted with the logic for handling the request and response for that action. The lines between the incoming request, the business logic and the outgoing response become blurred. The controller’s responsibilities are complex because there is no other sensible place for this code to go.</p>

<h2 id="the-problems-with-active-record-models">The problems with Active Record Models</h2>

<p>Controllers are bad, but models are worse. In order to remove complexity from controllers, it has been suggested to move that logic to the models instead – the “Fat model, skinny controller” paradigm.</p>

<p>An Active Record model is responsible for <em>at least</em> the following things:</p>

<ul>
  <li>Mapping database rows to Ruby objects</li>
  <li>Containing validation rules for those objects</li>
  <li>Managing the CRUD operations of those objects in the database (through
inheritance from <code>ActiveRecord::Base</code>)</li>
  <li>Providing a place to put code to run before those CRUD operations (callbacks)</li>
  <li>Containing complicated database queries</li>
  <li>Containing business logic for your application</li>
  <li>Defining associations between different models</li>
</ul>

<p>If you were to colour each responsibility of your model, it might look something like this:</p>

<p><img src="/images/maintainable_rails/normal_model_clean.png" alt="Normal model" /></p>

<p>Or really, it might look like this:</p>

<p><img src="/images/maintainable_rails/normal_model.png" alt="Normal model" /></p>

<p>In traditional Rails models, all of this gets muddled together in the model,
making it very hard to disentangle code that talks to the database and code
that is working with plain-Ruby objects.</p>

<p>For instance, if you saw this code:</p>

<pre><code>class Project &lt; ApplicationRecord
has_many :tickets

  def contributors
    tickets.map(&amp;:user).uniq
  end
end
</code></pre>

<p>You might know <em>instinctively</em> that this code is going to make a database call
to the <code>tickets</code> association for the <code>Project</code> instance, and then for each of
these <code>Ticket</code> objects it’s going to call its <code>user</code> method, which will load a
<code>User</code> record from the database.</p>

<p>Someone unfamiliar with Rails – like, say, a junior Ruby developer with very
little prior Rails exposure – might think this is bog-standard Ruby code
because that’s <em>exactly</em> what it looks like. That is what Rails is designed to look like. There’s something called
<code>tickets</code>, and you’re calling a <code>map</code> method on it, so they might guess that
<code>tickets</code> is an array. Then <code>uniq</code> further indicates that. But <code>tickets</code> is an
association method, and so a database query is made to load all the associated
tickets.</p>

<p>This kind of code is very, very easy to write in a Rails application because
Rails applications are intentionally designed to be easy. <a href="http://youtu.be/Gzj723LkRJY">“Look at all the
things I’m <em>not</em> doing”</a> and <a href="http://rubyonrails.org/doctrine/#provide-sharp-knives">“provide sharp
knives”</a> and all that.</p>

<p>However, this code executes one query to load all the <code>tickets</code>, and then one
query <em>per ticket</em> to fetch its users. If we called this method in the console, then the query output might look like this:</p>

<pre><code>Project Load (0.2ms)  SELECT  "projects".* FROM "projects" ORDER BY "projects"."id" ASC LIMIT ?  [["LIMIT", 1]]
Ticket Load (0.1ms)  SELECT "tickets".* FROM "tickets" WHERE "tickets"."project_id" = ?  [["project_id", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 1], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 2], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 3], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 1], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 2], ["LIMIT", 1]]
User Load (0.1ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = ? LIMIT ?  [["id", 3], ["LIMIT", 1]]
</code></pre>

<p>This is a classic N+1 query, which Rails does not stop you from doing. It’s a
classic Active Record footgun / sharp knife. And this is all because Active Record makes it
<em>much</em> too easy to call out to the database. This code
for <code>Project#contributors</code> combines business logic intent (“find me all the
contributors to this project”) with database querying and it’s <em>the</em> major
problem with Active Record’s design.</p>

<p>What’s worse, is that you can make a database call <em>wherever a model is used in a Rails application</em>. If you use a model in a view, a view can make a database call. A view helper can. Anywhere! Rails’ attitude to this is one of “this is fine”, because they provide sharp knives and you’re supposed to trust the “omakase chefs” of the Rails core team. Constant vigilance can be exhausting, however.</p>

<p>Database queries are cheap to make because Active Record makes it so darn
easy. When looking at the performance of a large, in-production Rails
application, the number one thing I come across is slow database queries
caused by methods just like this. Programmers writing innocent looking Ruby
code that triggers not-so-innocent database activity is something that I’ve
had to fix too many times within a Rails application.</p>

<p>Active Record makes it way too easy to make calls to the database. Once these
database calls are ingrained in the model like this and things start depending
on those calls being made, it becomes hard to refactor this code to reduce
those queries. Even tracking down where queries are being made can be
difficult due to the natural implicitness that <em>some</em> method calls produce
database queries.</p>

<p>Thankfully, there are tools like <a href="https://appsignal.com">AppSignal</a>, <a href="https://skylight.io">Skylight</a> and <a href="https://newrelic.com">New
Relic</a> that point directly at the “smoking guns” of
performance hits in a Rails application. Tools like these are invaluable. It
would be nice to not need them so much in the first place, however.</p>

<p>The intention here with the <code>contributors</code> method is very innocent: get all the
users who have contributed to the project by iterating through all the tickets
and finding their users. If we had a <code>Project</code> instance (<a href="https://github.com/rails/rails">with thousands of
tickets</a>), running that contributors method
would cause thousands of database queries to be executed against our database.</p>

<p>Of course, there is a way to make this all into two queries through Rails:</p>

<pre><code>class Project &lt; ApplicationRecord
  def contributors
    tickets.includes(:user).map(&amp;:user).uniq
  end
end
</code></pre>

<p>This will load all the tickets <em>and</em> their users in two separate queries,
rather than one for tickets and then one for each ticket’s user, thanks to the
<em>power of eager loading</em>. (Which you can <a href="http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">read more about in the Active Record
Querying
guide</a>.)</p>

<p>The queries look like this:</p>

<pre><code>Ticket Load (0.4ms)  SELECT "tickets".* FROM "tickets" WHERE "tickets"."project_id" = ?  [["project_id", 1]]
User Load (0.4ms)  SELECT "users".* FROM "users" WHERE "users"."id" IN (1, 5)
</code></pre>

<p>Active Record loads all the ticket objects that it needs to, and then it issues
a query to find all the users that match the <code>user_id</code> values from all the
tickets.</p>

<p>You can of course not load all the tickets at the start either, you could load
only the 100 most recent tickets:</p>

<pre><code>class Project &lt; ApplicationRecord
  def contributors
    tickets.recent.includes(:user).map(&amp;:user).uniq
  end
end

class Ticket &lt; ApplicationRecord
  scope :recent, -&gt; { limit(100) }
end
</code></pre>

<p>But I think this is still too much of a mish-mash of database querying and
business logic. Where is the clear line between database querying and business
logic in this method? It’s hard to tell. This is because Active
Record <em>allows</em> us to do this sort of super-easy querying; intertwining
Active Record’s tentacles with our business logic.</p>

<h2 id="views">Views</h2>

<p>Views in a typical Rails application are used to define logic for how to present data from models once this data has been fetched by controllers.</p>

<p>We’ve already discussed how Active Record allows you to execute additional queries in any context that a model is used. Typically additional queries like the <code>tickets</code> and <code>contributors</code> ones above will be executed in a view. There’s no clear barrier between models and views to prevent this from happening.</p>

<p>This sort of “leakage” makes it very hard for views to be used in complete isolation from a database. The moment a view uses a model is the moment that the view is now potentially tied to a database. For example: could you look at a view and quickly know how many, if any, database queries were being executed? Probably not.</p>

<p>To define any sort of Ruby logic for views, Rails recommends using view helpers. Perhaps we want to render a particular avatar for users:</p>

<pre><code>module UsersHelper
  def avatar
    image_tag(user.avatar_url || "anonymous.png")
  end
end
</code></pre>

<p>And then we were to use this in our view over at <code>app/views/projects/show.html.erb</code>:</p>

<pre><code>&lt;ul&gt;
  &lt;% @project.tickets.each do |ticket| %&gt;
    &lt;li&gt;&lt;%= avatar(ticket.author) %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This code is defined in a helper file at <code>app/helpers/users_helper.rb</code>, but is used in a completely separate directory, under a completely different namespace. The distance between where the code is <em>defined</em> and where it is <em>used</em> is very far apart.</p>

<p>On top of all that, helpers are then shared across <em>all</em> views. So while the helper is defined in <code>UsersHelper</code>, it will be available for <em>all</em> views. If you define a helper in <code>UsersHelper</code>, then it is also available under views at <code>app/views/tickets</code>, or <code>app/views/projects</code>, too.</p>

<p>Because of this “wide sharing” of view helpers, we don’t know if changing it is going to have ramifications elsewhere in our application. If we change it for this <em>one</em> context, will it potentially break other areas? We cannot know without looking through our code diligently.</p>

<h3 id="presenters">Presenters</h3>

<p>A common way to approach solving this problem is through the <em>presenter</em> pattern. Presenters define classes that then “accentuate” models. They’re typically used to include presentational logic for models – things that would be “incorrect” to put in a model, but okay to put in a view.</p>

<p>By using a presenter, we have a clear indicator of where the presenter’s method is used: look for things like <code>UserPresenter.new(user)</code>, and then that’ll be where it is used.</p>

<p>Here’s our <code>avatar</code> example, but this time in a presenter:</p>

<pre><code>class UserPresenter
  def avatar
    image_tag(user.avatar_url || "anonymous.png")
  end
end
</code></pre>

<p>To use this, we would then need to initialize a new instance of this presenter per user object:</p>

<pre><code>&lt;ul&gt;
  &lt;% @project.tickets.each do |ticket| %&gt;
    &lt;li&gt;&lt;%= UserPresenter.new(ticket.author).avatar %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This then muddles together the Ruby and HTML code of our view. A way to solve this could be to move that preparation of the data into a helper:</p>

<pre><code>module TicketsHelper
  def author_avatar(author)
    UserPresenter.new(author).avatar
  end
end
</code></pre>

<p>Then in the view:</p>

<pre><code>&lt;ul&gt;
  &lt;% @project.tickets.each do |ticket| %&gt;
    &lt;li&gt;&lt;%= author_avatar(ticket.author) %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>We have now got the logic for rendering an avatar spread over three different points:</p>

<ol>
  <li>The view</li>
  <li>The presenter</li>
  <li>The helper</li>
</ol>

<p>This is not a very clear way to organize this code, and the more this pattern is used, the more confusing your application will get.</p>

<p>Views in a default Rails application leave us with no alternative other than to create a sticky combined mess of logic between our ERB files and helper files that are globally shared.</p>

<h2 id="we-can-do-better">We can do better</h2>

<p>It should be possible to render a view without relying on a model to be connected to a database. Being
able to reach into the database from your views <em>should</em> be hard work.
Your business logic should have everything it needs to work by the stage a view is being rendered. This will then make it easier to test the view in isolation from the other components of your application.</p>

<p>The source of these frustrations is the Active Record pattern and Rails’ strict adherence to it. A class containing only business logic and being passed some data should not need
to know also about how that data is validated, any “callbacks” or how that data
is persisted too. If a class knows about all of those things, it has too many
responsibilities.</p>

<p>The Single Responsibility Principle says that a class or a module should only
be responsible for one aspect of the application’s behaviour. It should only
have one reason to change. An Active Record model of any meaningful size has
many different reasons to change. Maybe there’s a validation that needs
tweaking, or an association to be added. How about a scope, a class method or a
plain old regular method, like the contributors one? All more reasons why
changes could happen to the class.</p>

<p>An Active Record model flies in the face of the Single Responsibility
Principle. I would go as far as to say this: Active Record leads you to writing
code that is hard to maintain from the very first time you set foot in a Rails
application. Just look at any sizable Rails application. The models are
usually the messiest part and I really believe Active Record – both the
design pattern and the gem that implements that pattern – is the cause.</p>

<p>Having a well-defined boundary between different pieces of code makes it easier
to work with each piece. Active Record does not encourage this.</p>

<p>Validations and persistence should be their own separate responsibilities and separated into
different classes, as should business logic. There should be specific, dedicated classes that only
have the responsibility of talking to the database. Clear lines between the
responsibilities here makes it so much easier to work with this code.</p>

<p>It becomes easier then to say: this class works with only validations and this
other class talks to the database. There’s no muddying of the waters between
the responsibilities of the classes. Each class has perhaps not <em>one</em> reason to
change, but at least <em>fewer</em> reasons to change than Active Record classes.</p>

<p>It’s possible to build a Rails application with distinct classes for validations, persistence and logic that concerns itself with data from database records. It’s possible to build one that does not combine a heap of messy logic in a controller action, muddling it in with request and response handling.</p>

<p>Just because DHH &amp; friends decided in 2006 that there was One True Way™ to build a Rails application – it does not mean that now in 2021, a full 15 years later, that we need to hew as close to that as possible.</p>

<p>We can explore other pathways. This is a book dedicated to charting that exploration, leading to a brighter future for your Rails application.</p>

<p>The way we’re going to <em>improve</em> upon the default Rails architecture is with two suites of gems: those from the <a href="https://dry-rb.org/">dry-rb</a> suite, and those from the <a href="https://rom-rb.org">rom-rb</a> suite.</p>

<p>We’ll be using these gems to clearly demarcate the lines between responsibilities for our application.</p>

<p>We’ll have particular classes that will separate the code that validates user input from the code that talks to a database.</p>

<p>We’ll take apart the intermingling of request-response handling and business logic from within our controllers, and move that out to another set of distinct classes.</p>

<p>We’ll move code that would typically be in a view or a helper, into yet another type of distinct class: one called a <em>view component</em>.</p>

<p>And with this, we’ll move forward into that bright future that’ll lead to your Rails applications being maintainable.</p>

<hr />

<p>_If you want to find out how to build maintainable Rails applications, read my book: <a href="https://leanpub.com/maintain-rails">Maintainable Rails</a>, available on Leanpub for $10 for the next month.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Contracting as a developer in Australia</title>
   <link href="http://ryanbigg.com/2021/03/getting-started-with-contracting-in-australia"/>
   <updated>2021-03-04T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/03/getting-started-with-contracting-in-australia</id>
   <content type="html"><![CDATA[<p>(All advice in this blog post is of a general nature and comes with the regular disclaimers, such as: “I am not a lawyer / tax agent”, etc. etc. If you have questions about the law or your tax obligations, talk to real lawyers, tax agents or even the people at the ATO.)</p>

<p>(This blog post will be updated as I find out more things about contracting – there is definitely more to learn!)</p>

<p>After working as a developer full-time for a number of years, I’ve decided to give that a break. And instead I’m now working full-time as a sole-trader contractor instead.</p>

<p>Maybe it was the two redundancies and then being fired. Maybe it was the “ride or die” / undying loyalty that companies want from their employees now. Who knows what truly led to this ridiculous decision to work as a solo contractor.</p>

<p>It wasn’t supposed to be full-time – but having two months off work does <em>nasty</em> things to your bank account. Alas. So I’m working full-time (for now) as a contractor, hoping to reduce that to 4 days in the near future.</p>

<p>Another developer by the name of Susan Pan asked these questions on an Australian web developer Slack group recently:</p>

<blockquote>
  <p>Hey everyone, was wondering if there are any people here with contracting experience? I’m new to the industry and also new to contracting so I have no idea about the logistics of it all (working out a salary, need an abn?, legal protections, etc). I’d be super appreciative if anyone has any time to chat/dm about their experience? Thanks!</p>
</blockquote>

<p>Here’s my (slightly edited) answers to those questions, and I’ll add a bit extra here too that I didn’t include there. Just for you!</p>

<h2 id="abn">ABN</h2>

<p>If you’re working as a contractor within Australia it’s likely that you’ll need an ABN. You can <a href="https://abr.gov.au/ABRWeb/Default.aspx?Target=CheckAbnEntitlement&amp;pid=71">check your ABN eligibility here</a>. I have an ABN. You can look it up!</p>

<p>An ABN helps identify transactions between businesses within Australia. The government will <em>probably</em> require you to have one, so I would suggest getting one as a first point of call. But! Check your eligibility first.</p>

<h2 id="money">Money</h2>

<h3 id="working-out-a-daily-rate">Working out a daily rate</h3>

<p>I contract out at a daily rate that was worked out based on what I was previously paid ($150k as a senior Ruby / JavaScript dev), plus a bit of extra padding to account for things like 1) making my own tax + super contributions 2) giving myself annual leave and sick leave.</p>

<p>I am now charging out at [redacted] as a contractor, working 8 hour days (with an hour lunch break somewhere in there, unpaid). This works out to [redacted]/day, which is a nice round number that makes me happy.</p>

<p>This base-hour number is a point-in-time sample and may vary, depending on circumstances. Someone else on that same Slack group gave this advice:</p>

<blockquote>
  <p>The best advice I ever got for setting your rate is “think of the highest number you can say with a straight face, then say that number”</p>
</blockquote>

<p>That’s essentially how I work out my number, too. What I will say is that if I was working full-time at this rate that I would make somewhere north of $200k/yr, pre-tax. The overall plan is to <em>not</em> work full-time, and to work part-time instead.</p>

<p>What clients get for that number is someone with a decade and a half of web development experience in many different teams of different shapes and sizes, with a good knowledge across many different languages. And: “he wrote <em>the book on Rails!</em>”</p>

<h3 id="invoicing">Invoicing</h3>

<p>Invoicing: get yourself a <a href="https://xero.com">Xero</a> subscription and hook it up to your bank account. Dedicate a time on a particular morning each week to track expenses in Xero and issue invoices or to follow up unpaid invoices.</p>

<p>Expense tracking is incredibly helpful for depreciating things around tax time like the “tools of the trade”: laptops, chairs, desks, pencils, pens, rulers… if you use it for a job, keep the receipt (in Xero) and list it under business expenses.</p>

<p>On that same topic: talk to a tax agent around tax time. Again, this is another couple-of-hundred-dollars worth of expenses but the good ones will save you more than what you pay them in raw time-value. The tax agent bill can then be expensed the next financial year. Your tax agent’s job is to sift through the data you’ve diligently collected in Xero and to help you pay the correct amount of tax, or even in some cases to get a tax refund if you’ve overpaid in your tax obligations.</p>

<h3 id="gst">GST</h3>

<p>Speaking of tax: if you’re earning over $75k, you’ll need to <a href="https://www.ato.gov.au/Business/GST/Registering-for-GST/">register for GST as well</a>. The ATO purports to have the facilities to do this online, but when I tried using their app it shit the bed (maybe they need to hire more contractors?) and so I had to call them up. Even though I had to wait a while, the agent was super helpful and guided me through all the steps.</p>

<p>I’m now registered for GST, which means that I need to <em>collect</em> GST from the clients that I charge, and then pay that money every quarter to the government, through a process called a Business Activity Statement. You take <em>all</em> the money you charged for GST, <em>minus</em> the GST on purchases you’ve paid for the business, and that’s then your BAS payment for the quarter.</p>

<p>Xero has a great automatic tool for calculating BAS.</p>

<h3 id="whats-it-going-to-take-to-run-the-business-this-month">What’s it going to take to run the business this month?</h3>

<p>Once I’ve invoiced the client, received the money and correctly set aside the GST amount, it’s math time.</p>

<p>For the sole-tradership that I operate, there are business expenses that need to be taken of on usually a monthly recurring rate. There are some that are <em>yearly</em> as well. These provide me with a baseline cost of what it’s going to take to run the business this month. The yearly ones get divided by 12 and treated like a monthly cost, except the money is transferred into the business savings account.</p>

<h3 id="pay-yourself">Pay yourself</h3>

<p>Using that base number, I can then work out that my <a href="https://www.ato.gov.au/rates/individual-income-tax-rates/">income tax rate</a> is somewhere in the range of 37c-45c in the dollar (after certain amounts), depending on if I end up making more than $180k this year or not. This depends on how many weeks I can work this year. This is impossible to predict, given the nature of contracting work. Tide goes in, tide goes out.</p>

<p>So I err on the side of it being 45c instead of 37c. To make the mental math easy, I take whatever I get paid and put away half (50%) of that into a savings account that is then, essentially, untouchable. That then goes to paying my quarterly BAS bills that I get from the government with the money set aside for tax reasons listed in the BAS as a “tax withheld” amount.</p>

<p>Previously, I was on a Pay-as-you-go quarterly payment plan with the government thanks to my <a href="https://leanpub.com">Leanpub royalties</a> – but that’ll be changing to a quarterly Business Activity Statement soon due to the increased nature of my “business’s” earnings.</p>

<p>My effective tax rate is not exactly 37c or 45c on the dollar for every dollar – it’s important to note here that it’s 37c on every dollar <em>over</em> $120,000. So if my annual income was $150,000, the tax would not be $55,500 ($150k x 0.37). It would be more like: $150,000 - $120,000 = $30,000. Then that $30,000 x 0.37 = $11,100, plus the base rate of $29,467, or $40,567, or about 27% of $150k. An important distinction to make here!</p>

<p>By the time tax time comes around and I talk to my tax agent (below), we do some math and work out how much additional tax I need to pay. Hopefully this amount is zero, and that there’s also a nice tax return attached to that. If it’s not, no sweat: the money in the business savings account will cover it.</p>

<p>If there’s still leftover money in the savings account after all that then that gets rolled into the general transaction account for the business and I’ll spend it on things that I need, or transfer it into my family’s accounts as an extra bonus.</p>

<p>I then take 9.5% of whatever I get paid and put that directly into my superannuation. When I retire, I want money to be able to live, so this is a sensible choice. I could contribute more here.</p>

<p>I also take 5% out of this total amount for leave entitlements. I am (unfortunately) not invulnerable, so I will need paid sick leave from <em>somewhere</em>, and occasionally I might like to leave my computer so annual leave needs to be accounted for too. This really should be somewhere in the range of 11-12%, as annual + sick leave entitlements are usually in the range of 6 weeks of the year (11.5% of the year)… but I’m bootstrapping my consulting business now and I’m choosing to take fewer leave days for the moment.</p>

<p>By this point I’ve deducted these things from my business’s income:</p>

<ul>
  <li>Running the business expenses</li>
  <li>Tax obligations (both GST + personal income tax)</li>
  <li>Superannuation</li>
  <li>Leave entitlements</li>
</ul>

<p>The rest of this money then goes into my family’s bank accounts.</p>

<h2 id="get-it-in-writing">Get it in writing</h2>

<p>Next up: contracts!</p>

<p>My wife is an ex-lawyer and read over a contract that I drafted using my significant (read: completely lacking) legal expertise.</p>

<p>Having a Real Lawyer™ look over the contract ensures that I’m not missing obvious things (like including GST in payments, dummy!). Get yourself a contract lawyer who can do the same.</p>

<p>The contract is designed to answer the who, what, why, where, when, how questions:</p>

<ol>
  <li>Who’s this contract between?</li>
  <li>What’s this contract about?</li>
  <li>Why are we entering into this agreement?</li>
  <li>Where are we gonna be doing the work?</li>
  <li>For how long is this work going to happen?</li>
  <li>How are we going to work together?</li>
</ol>

<p>Get a contract. Get it signed.</p>

<p><strong>You cannot be a contractor without a contract. You will be an “or”. Nobody wants an “or”</strong>. Get it in writing. Get it signed. Dated. As the wise Jeff Casimir once said, contracts are written while in love, but only ever used in hate. You will want a good one for when shit hits the fan. And it will hit the fan.</p>

<p>If you agree to some work, it’s in writing <em>in your personal email account, not in their company’s Slack</em>. It’s timestamped, filed away and easily accessible. Can you find that documentation with minimal effort? You better be able to.</p>

<h2 id="getting-paid">Getting paid</h2>

<p>In order to make it ridiculously easy for people to pay me, I work with Australian-only clients <em>and</em> I offer two different payment methods: bank transfer or PayPal. Anyone who’s adulted a single day in Australia will know how to do a bank transfer between Australian bank accounts. Australian-only clients means that I don’t need to worry about international transfer fees, currency conversions or tracking alternative income for tax purposes. PayPal is for the occasional international client, and for Leanpub royalties.</p>

<p>I issue invoices (through Xero) fortnightly for one week gone, and one week coming. For example, if I was issuing an invoice on next Monday, the 8th of March, that invoice would cover all my work for the week of the 1st-5th of March <em>and also</em> the work that I would do during the week of the 8th-12th March. If I (unexpectedly) take time off that week, it would be deducted from the following invoice. That invoice would be on the 22nd of March, and would cover 15th-19th and 22nd-26th March, and so on and so on.</p>

<p>On the topic of getting paid: all my invoices are 14 days payable. This means that if an invoice is issued on, say, the 8th of March, then it must be paid by the time the 22nd of March comes around.</p>

<p>If the invoice is not paid by that time, then I will stop working. No exceptions. No “check is in the mail”, no “I’ll pay you next week”. If the money is not in the bank account by the very day the invoice says it is due, the work does not get done. Absofuckinglutely not.</p>

<p>Why am I so bullish on this point? Because I’ve been dicked around before, and I <em>will not</em> let it happen again. As a contractor, I rely on a steady stream of income to support my family and the moment that is cut off is the very moment I will need to start finding a new stream.</p>

<p>Take pride in yourself as a contractor and have the same rules.</p>

<h3 id="billable-hours">Billable hours</h3>

<p>On a related topic: billable hours. Did you spend time working for a client between the hours of 9am and 5pm? That’s billable time. Did you spend time outside of those hours working for the client? Maybe you had an on-call incident in the middle of the night or had to work a weekend? That’s billable too. Get it in writing in the contract that it’s a thing that <em>might</em> happen, and <em>bill for it</em>.</p>

<p>Conversely: did you spend an hour at a dentist appointment? That’s not billable. Haircut? Unbillable. Had a case of the “dunwannas” and needed to lie on the couch? Don’t you dare think about billing for it.</p>

<p>When it comes to invoicing clients for hours worked, keep it honest in <em>both directions</em>. Bill for the hours you’ve worked (even if they’re slightly outside of the agreed time) and do not bill for the hours you did not work for them. Honesty is the best policy here.</p>

<h2 id="leave-the-campsite-better-than-how-you-found-it">Leave the campsite better than how you found it</h2>

<p>The header of this section is a Scouts motto. After attending the scouts for precisely zero days of my life, this statement <em>still</em> resonates with me.</p>

<p>I care about the long-term viability of your codebase, company and team, not just the money coming in the door. The money in the door helps me keep my family alive and happy. The work I deliver at your company keeps <em>your</em> families alive and happy, and I want that to remain that way long-term. If it remains that way, it’s likely you’ll keep me as a contractor or at least recommend me to your favourite people.</p>

<p>I’ve had to work on codebases where contractors who <em>didn’t</em> care about those things (“oh fuck we’ve only got 2 weeks shipitshipitshipit”) and it was miserable. I don’t want misery – I want happiness. I want people to go “yeah, you should hire Ryan because he came in for 3 months and did X, Y and Z and rocked our socks.” Yeah it’s nice being paid, but the <em>success</em> of doing a good job is what counts.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Twist V2 - Live Coding</title>
   <link href="http://ryanbigg.com/2021/01/twist-v2-live-coding"/>
   <updated>2021-01-13T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2021/01/twist-v2-live-coding</id>
   <content type="html"><![CDATA[<p>This year, I’ve been continuing on my work on <a href="https://github.com/radar/twist-v2">Twist</a>. As the README says:</p>

<blockquote>
  <p>This is a rewrite of my <a href="http://github.com/radar/twist">Rails-based book review app</a> in <a href="https://rom-rb.org/">rom-rb</a>, <a href="https://dry-rb.org/">dry-rb</a>, (some parts of) <a href="https://hanamirb.org/">Hanami</a>, <a href="https://sidekiq.org/">Sidekiq</a>, <a href="https://graphql.org/">GraphQL</a>, <a href="https://reactjs.org/">React</a>, <a href="https://reach.tech/router/">Reach Router</a>, <a href="https://www.apollographql.com/">Apollo</a>, <a href="https://www.typescriptlang.org/">TypeScript</a>, <a href="https://graphql-code-generator.com/">GraphQL Code Generator</a>, <a href="https://tailwindcss.com/">Tailwind</a>, and whatever other Cool Hipster Tech™ I can get my grubby hands on.</p>
</blockquote>

<p>This application is a hybrid application, consisting of two distinct parts: a Ruby backend, and a TypeScript frontend. They communicate over GraphQL.</p>

<p>To demonstrate what working on this application is like, I’m doing some live coding sessions on it, every Wednesday morning.</p>

<h2 id="episode-1-starting-the-invitations-feature">Episode 1: Starting the invitations feature</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/qWdyo3icsjU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="episode-2-continuing-the-invitations-feature">Episode 2: Continuing the invitations feature</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/RKQLEEGIPyE" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="episode-3-checking-for-permissions-on-the-invitations">Episode 3: Checking for permissions on the invitations</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Bg1W8-SzbHw " frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

]]></content>
 </entry>
 
 <entry>
   <title>React Select + Capybara + Selenium</title>
   <link href="http://ryanbigg.com/2020/09/react-select-capybara-selenium"/>
   <updated>2020-09-23T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/09/react-select-capybara-selenium</id>
   <content type="html"><![CDATA[<p>Today, I was adding a <a href="https://react-select.com/home">React Select</a> element to a page, and I really wanted to test it.</p>

<p>This is, surprisingly, <a href="https://github.com/JedWatson/react-select/issues/856">not the first time I’ve attempted this</a>.</p>

<p>Since 2016, React Select has undergone some changes, released a brand-new (and much better!) version. One of these big features is that it uses <a href="https://emotion.sh/docs/introduction">Emotion</a> for styling. A consequence of this is that React Select no longer has <code>.Select</code>, or <code>.Select-input</code> classes that you could use as selectors in the tests. Instead, it will generate hashed CSS selectors, like <code>css-2b097c-container</code> and <code>css-1rhbuit-multiValue</code>. These have the potential to change: if the underlying CSS changes, then the hash will change. So they are not reliable in tests.</p>

<p>To fix this, I used another prop of <code>ReactSelect</code> called <code>classNamePrefix</code>:</p>

<pre><code class="language-tsx">import CreatableSelect from "react-select/creatable";

// ...

const options = [
  { label: "Admin", value: "Admin" },
  { label: "HIU", value: "HIU" },
  { label: "Organisational", value: "Organisational" },
  { label: "Paid", value: "Paid" },
];

// "tags" here comes from a prop on this component
const selectedOptions = options.filter(({ value }) =&gt; tags.includes(value));

return (
  &lt;CreatableSelect
    options={options}
    defaultValue={selectedOptions}
    isMulti
    classNamePrefix="tags"
  /&gt;
);
</code></pre>

<p>This prop adds additional classes to the React Select component, such as <code>.tags__control</code> and <code>.tags__multi-value</code> – values that <em>are</em> reliable and predictable!</p>

<p>This means that in the Capybara test, I can now use these to interact with this React Select component, like this:</p>

<pre><code class="language-ruby"># spec/support/filter_helpers.rb
module FilterHelpers
  class SelectControl
    include Capybara::DSL

    attr_reader :prefix

    def initialize(prefix:)
      @prefix = prefix
    end

    def select(option)
      within_control do
        find("input").fill_in(with: option)
      end

      find(".#{prefix}__option", text: option).click
    end

    def value
      find(single_value_selector).text
    end

    def blank?
      page.has_no_selector?(single_value_selector)
    end

    def values
      all(multi_value_selector).map(&amp;:text)
    end

    def remove(label)
      value = find(multi_value_selector, text: label)
      within(value) do
        find("#{multi_value_selector}__remove").click
      end
    end

    def visible?
      page.has_selector?(control_selector)
    end

    def hidden?
      !visible?
    end

    private

    def single_value_selector
      ".#{prefix}__single-value"
    end

    def multi_value_selector
      ".#{prefix}__multi-value"
    end

    def control_selector
      ".#{prefix}__control"
    end

    def within_control(&amp;block)
      within(control_selector, &amp;block)
    end
  end

  module TagFilterControl
    def tag_filter_control
      SelectControl.new(prefix: "tags")
    end

    def add_new_tag(tag)
      tags_control.select(tags)
    end

    def expect_tags_selected(tags)
      expect(tags_control.value).to eq(tags)
    end

    def expect_no_tags_selected
      expect(tags_control).to be_blank
    end

    def remove_tags(*tags)
      tags.each do |tag|
        tags_control.remove(tag)
      end
    end
  end
end

# spec/features/updating_tags_spec.rb

RSpec.describe "Updating tags" do
  include TagFilterControl

  scenario "Can update a User's tags", js: true do
    visit edit_admin_user_path(user)

    expect_tags_selected("Existing tag")
    remove_tag("HIU")
    add_new_tag("Paid")
    add_new_tag("Custom tag")
  end
end
</code></pre>

<p>I have the following helpers:</p>

<ol>
  <li><code>expect_selected_tag</code>: When the page loads, the Select element should contain a tag that is <em>already</em> assigned to the user.</li>
  <li><code>remove_tag</code>: Used to remove a tag that appears in the Select element.</li>
  <li><code>add_new_tag</code>: Used to add either a tag from the list of options, or to create a brand new tag.</li>
</ol>

<p>With these helpers, I can effectively test React Select within Capybara and Selenium.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Selenium, Capybara, ChromeDriver: connection refused error debugging</title>
   <link href="http://ryanbigg.com/2020/08/selenium-capybara-chromedriver-connection-refused-error-debugging"/>
   <updated>2020-08-29T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/08/selenium-capybara-chromedriver-connection-refused-error-debugging</id>
   <content type="html"><![CDATA[<p>A few days ago, we started seeing this exception happening for <em>some</em> of our Capybara feature tests:</p>

<pre><code>1.1) Failure/Error: visit(sign_out_path)

      Selenium::WebDriver::Error::UnknownError:
        java.net.ConnectException: Connection refused (Connection refused)
      # [remote server] org.openqa.selenium.remote.server.WebDriverServlet(WebDriverServlet.java):240:in `lambda$handle$0'
      # [remote server] java.util.concurrent.Executors$RunnableAdapter(Executors.java):511:in `call'
      # [remote server] java.util.concurrent.FutureTask(FutureTask.java):266:in `run'
      # [remote server] java.util.concurrent.ThreadPoolExecutor(ThreadPoolExecutor.java):1149:in `runWorker'
      # [remote server] java.util.concurrent.ThreadPoolExecutor$Worker(ThreadPoolExecutor.java):624:in `run'
      # [remote server] java.lang.Thread(Thread.java):748:in `run'
      # ./spec/support/pages/login.rb:5:in `login'
      # ./spec/concepts/extraction/keyboard_shortcuts_spec.rb:84:in `block (2 levels) in &lt;main&gt;'
      # ./spec/spec_helper.rb:69:in `block (2 levels) in &lt;main&gt;'
      # ./spec/support/elasticsearch_spec_helper.rb:42:in `block (3 levels) in &lt;main&gt;'
      # ./spec/support/elasticsearch_spec_helper.rb:38:in `block (2 levels) in &lt;main&gt;'
</code></pre>

<p>Connection refused, fine. But connection refused to <em>what</em>? This error message doesn’t give us much to go on.</p>

<p>Seemingly nothing that we changed had caused this issue – it was one of those types of issues that just popped up spontaneously.</p>

<p>It turns out that this is due to a bug within Google ChromeDriver <code>85.0.4183.83</code>. Here’s the bug report for ChromeDriver: <a href="https://bugs.chromium.org/p/chromedriver/issues/detail?id=3578">Issue 3578</a>.</p>

<h2 id="debugging-steps">Debugging steps</h2>

<p>After quite a lot of playing around with our Docker container setup, building EC2 instances and testing things out there… I was able to track it down to this issue by adding this line to the configuration for our tests:</p>

<pre><code>Selenium::WebDriver.logger.level = Logger::DEBUG
</code></pre>

<p>I knew of this trick by having to debug Selenium issues in the past – it’s a very helpful trick to get messages out of Selenium WebDriver that you wouldn’t otherwise see.</p>

<p>When I did this, I saw these messages come through:</p>

<pre><code>2020-08-30 08:39:15 INFO Selenium &lt;- {"value":{"data":{"text":"{Alert text : "},"error":"unexpected alert open","message":"unexpected alert open: {Alert text : }\n  (Session info: chrome=85.0.4183.83)","stacktrace":"0   chromedriver                        0x000000010a9261b9 chromedriver + 4911545\n1   chromedriver                        0x000000010a8c5e03 chromedriver + 4517379\n2   chromedriver                        0x000000010a533da6 chromedriver + 773542\n3   chromedriver                        0x000000010a4c4072 chromedriver + 315506\n4   chromedriver                        0x000000010a4b7c23 chromedriver + 265251\n5   chromedriver                        0x000000010a491720 chromedriver + 108320\n6   chromedriver                        0x000000010a492693 chromedriver + 112275\n7   chromedriver                        0x000000010a8eef72 chromedriver + 4685682\n8   chromedriver                        0x000000010a8fcb3a chromedriver + 4741946\n9   chromedriver                        0x000000010a8fc801 chromedriver + 4741121\n10  chromedriver                        0x000000010a8d225e chromedriver + 4567646\n11  chromedriver                        0x000000010a8fd061 chromedriver + 4743265\n12  chromedriver                        0x000000010a8e3d0a chromedriver + 4640010\n13  chromedriver                        0x000000010a9160ba chromedriver + 4845754\n14  chromedriver                        0x000000010a92c387 chromedriver + 4936583\n15  libsystem_pthread.dylib             0x00007fff67652109 _pthread_start + 148\n16  libsystem_pthread.dylib             0x00007fff6764db8b thread_start + 15\n"}}
</code></pre>

<p>Well that looks like a crash!</p>

<p>An unexpected alert open? What does that mean?</p>

<p>This lead me to look through the issue logs for Capybara first, as these were tests using Capybara. The final “exit” point from our code uses Capybara code. When I looked on Capybara’s issue tracker I saw that there’s an issue for this problem: <a href="https://github.com/teamcapybara/capybara/issues/2382">Capybara Issue #2382</a>. This then links to a Selenium issue: <a href="https://github.com/SeleniumHQ/selenium/issues/8638">Selenium Issue #8638</a>, which itself then links to <a href="https://bugs.chromium.org/p/chromedriver/issues/detail?id=3578">Issue 3578</a>.</p>

<p>These are pretty good pieces of evidence that indicate it was a chromedriver issue. I then recalled that a colleague of mine, Luiz, mentioned that Chrome had updated a few days ago. An update of Chrome leads to an update in Chromedriver, and since it was Chromedriver that was breaking, I thought to check that.</p>

<p>On the Capybara issue, there are some good steps to reproduce the issue with a minimal test case. I used this to lock Chromedriver to the more modern version:</p>

<pre><code>Webdrivers::Chromedriver.required_version = '85.0.4183.87'
</code></pre>

<p>The issue reported on Capybara wasn’t happening with that <code>.87</code> release, but it <em>does</em> happen with this:</p>

<pre><code>Webdrivers::Chromedriver.required_version = '85.0.4183.83'
</code></pre>

<p>So this then indicates that it’s a particular version of Chromedriver that causes the issue.</p>

<p>There are at least two ways to fix this issue.</p>

<p>The first is to lock Chromedriver using <code>Webdrivers::Chromedriver.required_version</code> to a particular version. But that means we need to remember to update that.</p>

<p>The second way is to dismiss the alert before finishing the test:</p>

<pre><code class="language-ruby">require 'bundler/inline'

gemfile do
  source 'https://rubygems.org'
  gem 'capybara'
  gem 'puma'
  gem 'selenium-webdriver'
  gem 'webdrivers'
  gem 'byebug'
  gem 'pry'
end

require 'selenium-webdriver'
require 'capybara/dsl'

Webdrivers::Chromedriver.required_version = '85.0.4183.83'
Selenium::WebDriver.logger.level = Logger::DEBUG

html = &lt;&lt;~HTML
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;

    &lt;script type="text/javascript"&gt;
      window.addEventListener('beforeunload', (event) =&gt; {
        event.preventDefault();
        event.returnValue = '';
      });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;&lt;a href="https://google.com"&gt;Hello World&lt;/a&gt;&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
HTML

app = proc { |env| [200, { "Content-Type" =&gt; "text/html" }, [html] ] }

session = Capybara::Session.new(:selenium_chrome, app)
session.visit '/'
session.click_on 'Hello World' # interact with the page, to get Chrome to fire `beforeunload`
session.driver.browser.switch_to.alert.accept
session.visit '/'
</code></pre>

<p>It’s the third-to-last and second-to-last lines here that will work around the issue here – we need to attempt to navigate away from the page and then click the alert. Then we can carry on testing after that point.</p>
]]></content>
 </entry>
 
 <entry>
   <title>How to tidy up Git Pull Requests</title>
   <link href="http://ryanbigg.com/2020/04/how-to-tidy-up-git-pull-requests"/>
   <updated>2020-04-23T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/04/how-to-tidy-up-git-pull-requests</id>
   <content type="html"><![CDATA[<p><strong>This post will cover how to break up a commit on a Git branch into two separate commits all from the terminal.</strong></p>

<p>Sometimes, developers can get carried away when they make commits. For instance, take <a href="https://github.com/radar/twist-v2/commit/19a513a6ae33ed0de3fb8ce426e7c7ec99449f0d">this commit</a> from yours truly. It <em>claims</em> to be fixing a particular issue, but there’s <em>a lot</em> of code there to fix that issue. Is all of it really necessary?</p>

<p>I’ll save you the spelunking: just the <code>frontend/src/styles.css</code> and <code>frontend/src/tailwind.css</code> files are the only things required to fix this issue. This commit <em>really</em> should’ve just been changes to those two files. The storybook changes should’ve been in a <em>separate</em> commit.</p>

<p>But the work has been done! Isn’t it now set in stone? No, this is Git! We can rewrite history.</p>

<p>So let’s pretend like this commit <em>hasn’t been committed to master yet</em>. I can do this by checking out a new branch to the commit before that one:</p>

<pre><code>git checkout 19a513a6~1 -b tidy-up-git-example
</code></pre>

<p>Here, <code>~1</code> means “1 before”. You could put any number here. You can see what this branch looks like <a href="https://github.com/radar/twist-v2/tree/tidy-up-git-example">on GitHub</a>. The latest commit will be <code>bb36d9b</code>, “Add back image missing”.</p>

<p>We now want to apply that <code>19a513a6</code> commit, the one that fixes Issue #22, to this branch. To do this, we’ll open a pull request against this <code>tidy-up-git-example</code> branch.</p>

<p>First, we need to switch to a new branch:</p>

<pre><code class="language-plaintext">git switch -c fix/issue-22
</code></pre>

<p><code>switch</code> is a recent sub-command of Git, and <a href="https://github.blog/2019-08-16-highlights-from-git-2-23/">was added in 2.23.0</a>. You can think of it behaving like <code>checkout</code>.</p>

<p>We’ll now bring in that commit to this branch, applying it on top of the current history with <code>cherry-pick</code>:</p>

<pre><code class="language-bash">git cherry-pick 19a513a6
</code></pre>

<p>When we run <code>git log --oneline</code>, we’ll see this:</p>

<pre><code class="language-text">f20de41 (HEAD -&gt; fix/issue-22) Fixes #22
bb36d9b (origin/tidy-up-git-example) Add back image missing
</code></pre>

<p>This shows us that the top-most / latest commit is that one we just cherry picked, and that the next most recent commit is the latest from the <code>origin/tidy-up-git-example</code> branch.</p>

<p>Next, you’ll need to push this branch up to GitHub:</p>

<pre><code class="language-text">git push origin fix/issue-22
</code></pre>

<p>If you don’t have permission to push to this repository (and most of you won’t!), you’ll need to fork it on GitHub first, then:</p>

<pre><code class="language-text">git remote add your-username git@github.com:your-username/twist-v2.git
git push your-username fix/issue-22
</code></pre>

<p>When this branch has been pushed to GitHub, you should now be able to create a pull request from that branch. You can do this by going to https://github.com/your-username/twist-v2/pull/new/fix/issue-22. On this page, under “Open a pull request” you’ll see two dropdowns: one for a “base” branch and one for “compare” branch:</p>

<p><img src="/images/tidy-up-github/base-and-compare.png" alt="Base &amp; Compare" /></p>

<p>The base branch is the branch you will be applying your pull request to. The changes in your pull request come from the compare branch. The “Able to merge” here indicates that there are no conflicts between the branches, and so this PR would be mergeable onto the base branch without trouble.</p>

<p>If we go ahead and create this PR now, we’ll see this:</p>

<p><img src="/images/tidy-up-github/big-diff.png" alt="Big Diff" /></p>

<p>How many lines?! If I was reviewing a PR of this length I would make sure to grab at least <em>one</em> cup of coffee and have slept well the night before too. Does this PR need to be so <em>massive</em>? We answered that before: no.</p>

<p>So we now have got ourselves a little bit stuck. We want to have the changes to fix Issue #22, but we also care about the storybook changes too. Let’s now work on how we can separate these two into two separate PRs.</p>

<h2 id="separating-out-issue-22">Separating out Issue #22</h2>

<p>Let’s start with just the CSS changes from <code>frontend/src/styles.css</code> and <code>frontend/src/tailwind.css</code>. We want just these changes to be in the PR’s commit. To do that, we need to <em>undo</em> and <em>redo</em> this commit.</p>

<p>To <em>undo</em> a commit, we use a Git operation called a <em>soft reset</em>:</p>

<pre><code class="language-text">git reset --soft HEAD~1
</code></pre>

<p>You can think of this like the opposite of <code>git commit</code>; it resets the Git repository’s state back to how it was right before <code>git commit</code> was run. All of changes from this commit will be staged for commit:</p>

<p><img src="/images/tidy-up-github/staged-for-commit.png" alt="Staged for commit" /></p>

<p>But our latest commit will show up as the one from <code>tidy-up-git-example</code>:</p>

<pre><code class="language-text">git log --oneline
</code></pre>

<pre><code>bb36d9b (HEAD -&gt; fix/issue-22, origin/tidy-up-git-example) Add back image missing
</code></pre>

<p>Now that we’re back to our pre-<code>git commit</code> stage, we need to go back one more step, back to before <code>git add</code> was run to stage these files. To do that, we need to run:</p>

<pre><code>git reset HEAD
</code></pre>

<p>This command will unstage all the changes in our repository:</p>

<p><img src="/images/tidy-up-github/unstaged-files.png" alt="Unstaged files" /></p>

<p>Now we want to just add the changes from <code>frontend/src/styles.css</code> and <code>frontend/src/tailwind.css</code>. We can do this with:</p>

<pre><code>git add frontend/src/styles.css
git add frontend/src/tailwind.css
</code></pre>

<p>(Or if we were wanting to pick-and-choose changes from these files, we could do <code>git add -p &lt;file&gt;</code> instead)</p>

<p>This will stage these two files:</p>

<p><img src="/images/tidy-up-github/two-staged-files.png" alt="Two staged files" /></p>

<p>Next, we can commit these changes:</p>

<pre><code>git commit -m "Fixes #22"
</code></pre>

<p>We’ve now re-written the history of the <code>fix/issue-22</code> branch. The latest commit on this branch, according to our local computer, is different to the latest one on GitHub. We need to tell GitHub that our history is correct, and we can do this with:</p>

<pre><code>git push &lt;your username&gt; fix/issue-22 --force-with-lease
</code></pre>

<p>This option will force-push your changes to GitHub, updating GitHub with the simpler changes.</p>

<p>If you refresh the GitHub pull request window, you’ll now see a much, much smaller diff number:</p>

<p><img src="/images/tidy-up-github/small-diff.png" alt="Small Diff" /></p>

<p>Much better! Our PR is now just focussed on the small changes that we needed to make to fix Issue #22.</p>

<p>We can then merge this PR to the branch, confident that the commit is small.</p>

<h2 id="storybook">Storybook</h2>

<p>Next up, we still need to pull in those storybook changes. Because we’ve reset and unstaged all the changes, those storybook changes will still be tracked as unstaged in our Git repository:</p>

<p><img src="/images/tidy-up-github/unstaged-storybook-files.png" alt="Unstaged storybook files" /></p>

<p>We can check out to a new branch for these changes, add these files, make a new commit and push these changes to GitHub:</p>

<pre><code>git switch -c update-storybook
git add .
git commit -m "Update Storybook + separate stories"
git push origin update-storybook
</code></pre>

<p>We can then go about creating a pull request for these changes if we like by going to https://github.com/your-username/twist-v2/pull/new/update-storybook. Remember to change the base branch here to <code>tidy-up-git-example</code>!</p>

<p>Once the PR is created, we can choose to merge it to that base branch. The base branch will then have both sets of changes on it: one (small one) to fix Issue #22, and one (large one) to upgrade storybook.</p>

<p>The storybook changes <em>could</em> probably be split out into smaller commits too, but I’ll leave that one as an exercise to the reader.</p>
]]></content>
 </entry>
 
 <entry>
   <title>The Stand Down</title>
   <link href="http://ryanbigg.com/2020/04/the-stand-down"/>
   <updated>2020-04-06T00:00:00+10:00</updated>
   <id>http://ryanbigg.com/2020/04/the-stand-down</id>
   <content type="html"><![CDATA[<p>Two weeks ago, I was moved from a teaching position into a “curriculum development” position at Coder Academy. Instead of facing students and teaching them directly, I was to work with my teacher’s assistant on improving curriculum for <em>all of Coder Academy</em>. I absolutely love writing, and so this was an amazing opportunity to apply my craft.</p>

<p>We set to work on updating curriculum for all Coder Academy’s bootcamps, revising content a week or two ahead of where they were all at.</p>

<p>At the start of the week last week, an email went out from Coder Academy’s parent company that announced they were standing down some staff. This was at 9:50am on Monday morning. This email did not mention how many staff it was, but <a href="https://www.theguardian.com/australia-news/live/2020/mar/30/coronavirus-update-live-australia-news-nsw-qld-victoria-scott-morrison-press-conference-covid-19-restrictions-public-gatherings-cruise-lockdown-app-latest-updates?page=with:block-5e8138d38f0878a2a48aca93#block-5e8138d38f0878a2a48aca93">The Guardian helpfully reported that the number would be 235 staff</a>.</p>

<p>I was told that Monday that “don’t worry, it’s not academic staff”, meaning I would not be affected. They let some of the admin staff go, or reduced their hours. Some people went from working 5 days a week to only working two.</p>

<p>I didn’t receive word at all if I still had my job or not until Friday. On Friday, at about 3pm, I received a phone call not from my Coder Academy manager, but from the head of HR at RedHill: Ruby Biscuit. She told me that I would be stood down immediately.</p>

<p>It was almost an entire business week of waiting and anxiety. I still tried working through it and, surprisingly, got a lot done.</p>

<p>13 minutes after that phone call, I was locked out of Coder’s GitHub and Slack accounts. My direct bosses did not know this phone call was going to happen. The call came from Ruby instead.</p>

<hr />

<p>Then there was a standard “Stand Down” form letter. It’s brutal. An older version of this post contained the text, but I’ll save you the brutality here.</p>

<p>The letter says that I can come back to my job once this whole COVID thing blows over. That’s all well-and-good, but to be honest I will likely have another job by then.</p>

<p>The letter also says that I remain an employee, but the dictionary definition of “employee” is:</p>

<blockquote>
  <p>a person employed for wages or salary, especially at non-executive level.</p>
</blockquote>

<p>And I am not getting wages or a salary, nor am I being required to do any work. So I am not sure how this still makes me an employee.</p>

<p>The letter says that I can draw down on my annual leave entitlements, but there are only 7 days of those. So I get a week and a half of runway before my money dries up.</p>

<p>The letter goes on to say that I should look into government benefits, but neglects to mention if RedHill has applied for the <a href="https://www.business.gov.au/risk-management/emergency-management/coronavirus-information-and-support-for-business/jobkeeper-payment">JobKeeper program</a>, or even if I would qualify for it. Doing my own research, yes I probably would. Do I know if they’ve applied for the program? Nope.</p>

<p>The letter at one point says:</p>

<blockquote>
  <p>We anticipate that the stand down will apply for a period of 3 months, but that timeframe may change pending the company’s ongoing review of pandemic circumstances.</p>
</blockquote>

<p>And later:</p>

<blockquote>
  <p>At the end of the stand down period, you will return to your role and your employment agreement will continue.</p>
</blockquote>

<p>But does not take into account my contract was due to run out on the 7th of July. The stand down came into effect on the 6th of April, Monday of this week. If it’s indeed <em>exactly</em> 3 months, it means that I would return to work on the 6th of July only for my contract to then run out on the 7th.</p>

<hr />

<p>How you let people go <em>matters</em>. More than ever in these COVID-19 times. We need to stick together; to be kind to one another. This letter and process is devoid of feeling and it threw me for a big loop. 13 minutes from phone call to cut off from my colleagues is too harsh. Especially when I did nothing wrong other than be in the wrong team.</p>

<p>Two simple ways they could’ve improved this process are:</p>

<ul>
  <li><strong>Let people know <em>immediately</em> on Monday morning if they had their job or not</strong>. The anxiety I had throughout the week would’ve been reduced massively.</li>
  <li><strong>Given me a week’s notice</strong> (as per the contract I signed when I joined). I would’ve liked to have (proverbially) packed my desk and (not proverbially) said my goodbyes. As it stands now, I have LinkedIn / Whatsapp / insert-26-other-chat-programs here messages to do that. It would’ve also allowed me to hand over any work or knowledge that I had to other people.</li>
</ul>

<p>Just these two things would’ve been a big help and really helped me transition out of there. Instead, I and many, many others have been cast out like detritus. It really hurts.</p>

<p>Anyway, I’m now looking for a new job. Go to <a href="https://ryanbigg.com/work">my /work page</a> to see what I’m interested in doing. I’m (obviously) available immediately.</p>
]]></content>
 </entry>
 
 <entry>
   <title>ROM and Dry Showcase: Part 4</title>
   <link href="http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-4"/>
   <updated>2020-02-20T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-4</id>
   <content type="html"><![CDATA[<p>This is the 4th (and final) part of a 4 part series covering the <a href="https://rom-rb.org/">rom-rb</a> and <a href="https://dry-rb.org/">dry-rb</a> suites of gems.</p>

<ul>
  <li>Part 1: <a href="/2020/02/rom-and-dry-showcase-part-1">Application + Database setup</a></li>
  <li>Part 2: <a href="/2020/02/rom-and-dry-showcase-part-2">Validations + Transactions</a></li>
  <li>Part 3: <a href="/2020/02/rom-and-dry-showcase-part-3">Testing</a></li>
</ul>

<p>In this last part, we’re going to make it so that our application can receive and respond to HTTP requests.</p>

<p>So far, we’ve been seeing how to use gems either from the <code>dry-rb</code> suite of gems, or the <code>rom-rb</code> suite of gems. In this part though, we’re going to be using a gem from a <em>different</em> suite, a suite called Hanami.</p>

<p>Hanami is first and foremost a web framework. It has routes, controllers, actions, views and models. Just like your <em>other</em> favourite web framework – Rails. But the big difference between Hanami and Rails is that with Hanami we can pick and choose the parts of the framework that we want to use.</p>

<p>Hanami is a <em>modular</em> web framework, and if all we want to use is the router, controllers and actions, then we can. In this part of this showcase, we’re going to look at how we can use two gems from Hanami called <code>hanami-router</code> and <code>hanami-controller</code>. These gems will provide us with the features our application needs to receive and respond to HTTP requests.</p>

<p>Our application will take a request to <code>POST /users</code> with a JSON body shaped like this:</p>

<pre><code class="language-json">{
  "first_name": "Ryan",
  "last_name": "Bigg",
  "age": 32,
}
</code></pre>

<p>And the <em>response</em> will indicate if the request was successful or not. If it was successful, we will see a JSON response:</p>

<pre><code class="language-json">{
  "id": 1,
  "first_name": "Ryan",
  "last_name": "Bigg",
  "age": 32
}
</code></pre>

<p>Let’s go!</p>

<h2 id="installing-the-hanami-gems">Installing the Hanami gems</h2>

<p>Let’s add these gems to our Gemfile:</p>

<pre><code class="language-ruby">gem "hanami-controller", "~&gt; 1.3"
gem "hanami-router", "~&gt; 1.3"
</code></pre>

<p>To install these gems, we can run <code>bundle install</code>.</p>

<p>In order to make sure that whatever we build with this application is performing correctly, we’ll add a third gem called <code>rack-test</code>:</p>

<pre><code class="language-ruby">gem "rack-test"
</code></pre>

<p>We’re going to be using this gem to test our application in conjunction with RSpec. You might be thinking: why <code>rack-test</code>? That’s because the part of our application that will recieve and respond to HTTP requests will be a <em>Rack</em> application! Just like every other Ruby web framework out there.</p>

<h2 id="setting-up-the-test-environment">Setting up the test environment</h2>

<p>Before we can write our any code, we need to write tests for it. It’ll make sure that our application is working correctly! But before we can write tests, there’s a bit of setup we need to do first. We’re going to create a new file called <code>spec/web_helper.rb</code>. This file will setup how our tests can speak to our Rack application:</p>

<pre><code class="language-ruby">require "spec_helper"
require "rack/test"

module RequestHelpers
  def app
    Bix::Web.app
  end

  def post_json(path, data)
    post path, data.to_json, "CONTENT_TYPE" =&gt; "application/json"
  end

  def parsed_body
    JSON.parse(last_response.body)
  end
end

RSpec.configure do |config|
  config.define_derived_metadata(file_path: %r{/spec/requests/}) do |metadata|
    metadata[:request] = true
  end

  config.include Rack::Test::Methods, request: true
  config.include RequestHelpers, request: true
end
</code></pre>

<p>We set the <code>web</code> metadata flag on any tests that will go in <code>spec/requests</code>. This allows us to specify that the <code>Rack::Test::Methods</code> and <code>RequestHelpers</code> modules are included <em>only</em> into tests under that particular directory.</p>

<p>The <code>Rack::Test::Methods</code> module will include methods that we can use to make requests to our app, like <code>get</code>, <code>post</code> and so on.</p>

<p>The <code>RequestHelpers</code> module defines one method so far, called <code>app</code>. This <code>app</code> method is what the <code>rack-test</code> gem uses to know what application to talk to when we use those <code>get</code> / <code>post</code> / etc. methods.</p>

<p>We’ve defined the <code>app</code> value here to be a small Rack application that compiles a few parts. The first is <code>Hanami::Middleware::BodyParser</code>. This is a piece of middleware, that will convert our JSON input into parameters that our controller can access. The second part is <code>Bix::Web::Router</code>, which will be the main Ruby entrypoint for our application. That doesn’t exist right now, but we’ll create it in a moment. We’ll see both of these parts again a little later on again.</p>

<p>The <code>post_json</code> method in <code>RequestHelpers</code> will allow us to make a <code>POST</code> request to our application and to send through JSON data with that request. Remember: the web part of application here is going to take JSON as input during a request, <em>and</em> it will also return JSON in a response. The <code>parsed_body</code> method will give us a Ruby hash of the response’s body, and we can use this later on to assert the returned data is what we expect.</p>

<p>Before we create our router and all of the other parts, let’s write a couple of simple tests to make sure it will behave as we wish.</p>

<h2 id="writing-our-first-test">Writing our first test</h2>

<p>Currently, our application has a single transaction for creating users. We’re going to use this transaction very soon, using it when a request to <code>POST /users</code> is made. We’re going to add two tets now. These two tests will ensure that the application behaves correctly for valid and invalid input to <code>POST /users</code>. Let’s add these new tests to <code>spec/requests/users_spec.rb</code>:</p>

<pre><code class="language-ruby">require "web_helper"

RSpec.describe "/users" do
  context "POST /" do
    context "with valid input" do
      let(:input) do
        {
          first_name: "Ryan",
          last_name: "Bigg",
          age: 32,
        }
      end

      it "succeeds" do
        post_json "/users", input
        expect(last_response.status).to eq(200)
        user = parsed_body
        expect(user["id"]).not_to be_nil
        expect(user["first_name"]).to eq("Ryan")
        expect(user["last_name"]).to eq("Bigg")
        expect(user["age"]).to eq(32)
      end
    end

    context "with invalid input" do
      let(:input) do
        {
          last_name: "Bigg",
          age: 32,
        }
      end

      it "returns an error" do
        post_json "/users", input
        expect(last_response.status).to eq(422)
        user = parsed_body
        expect(user["errors"]["first_name"]).to include("is missing")
      end
    end
  end
end
</code></pre>

<p>These tests should look pretty familiar! They are essentially the same tests for our transaction, just with rack-test methods being the primary difference.</p>

<p>When we attempt to run these tests, we’ll see that we’re missing a part of our application:</p>

<pre><code>  1) /users POST / with valid input succeeds
     Failure/Error: Bix::Web.app

     NoMethodError:
       undefined method `app' for Bix::Web:Module
</code></pre>

<p>Oh right! We need to setup this Web thing!</p>

<h2 id="building-the-web-component">Building the Web component</h2>

<p>To setup this web part of our application, we’re going to add a new file to <code>system/boot</code>, called <code>web.rb</code>. In this file, we’ll need to require all the gems that we’ll be using for the web part of our application:</p>

<pre><code class="language-ruby">Bix::Application.boot(:web) do |app|
  init do
    require "hanami-router"
    require "hanami-controller"
  end
end
</code></pre>

<p>This two lines will require the hanami gems that we’re going to be using here. Where we’ll use these gems is in a couple of files.</p>

<p>The first is a file called <code>lib/bix/web/application.rb</code>. This is where we’ll define the different Rack pieces for our application:</p>

<pre><code class="language-ruby">require "hanami/middleware/body_parser"

module Bix
  module Web
    def self.app
      Rack::Builder.new do
        use Hanami::Middleware::BodyParser, :json
        run Bix::Web::Router
      end
    end
  end
end
</code></pre>

<p>This file is defines the <code>Bix::Web.app</code> method that our test is looking for! This method returns a <code>Rack::Builder</code> object, which is to say it returns a <em>Rack application</em>.</p>

<p>This Rack application uses a single piece of middleware: <code>Hanami::Middleware::BodyParser</code>. This middleware is used to take in any JSON request body, and to transform it into parameters for our actions.</p>

<p>The <code>run</code> line at the of the builder’s block directs Rack to the application that will be serving our requests. Let’s build this part now in <code>lib/bix/web/router.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Web
    Router = Hanami::Router.new do
      post "/users", to: Controllers::Users::Create
    end
  end
end
</code></pre>

<p>This file allows us to define routes for the web side of our application. This route defines a <code>POST /users</code> request to go to <code>Controllers::Users::Create</code>. What is this mythical constant? It’s going to be the action that serves this request.</p>

<p>In this application, we’re going to put actions inside their own classes. This will keep the code for each action more clearly isolated from other actions.</p>

<p>We’ll define this action inside <code>lib/bix/web/controllers/users/create.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Web
    module Controllers
      module Users
        class Create
          include Hanami::Action

          def call(params)
            self.body = "{}"
          end
        end
      end
    end
  end
end
</code></pre>

<p>This action class includes the <code>Hanami::Action</code> module from the <code>hanami-controller</code> gem. This gives us access to a number of helpful methods, but the only one of these we’re using now is <code>self.body=</code>, which we’re using to set the response body to an empty JSON hash. What’s also worth mentioning here is that due to us not specifying a status, this action will return a <code>200</code> status.</p>

<p>With our router and controller now setup correctly, let’s switch back to looking at our tests.</p>

<h2 id="running-our-tests">Running our tests</h2>

<p>When we run these tests with <code>bundle exec rspec spec/requests</code> we’ll see they’re both failing:</p>

<pre><code>  1) /users POST / with valid input succeeds
     Failure/Error: expect(user["id"]).not_to be_nil

       expected: not nil
            got: nil
     # ./spec/requests/users_spec.rb:18:in `block (4 levels) in &lt;top (required)&gt;'

  2) /users POST / with invalid input returns an error
    Failure/Error: expect(last_response.status).to eq(422)

      expected: 422
          got: 200

      (compared using ==)
    # ./spec/requests/users_spec.rb:36:in `block (4 levels) in &lt;top (required)&gt;'
</code></pre>

<p>This is happening because all our action returns is an empty JSON body. Let’s work on changing this.</p>

<p>We’ll change the action to use the transaction class:</p>

<pre><code class="language-ruby">module Bix
  module Web
    module Controllers
      module Users
        class Create
          include Hanami::Action
          include Import["transactions.users.create_user"]
          include Dry::Monads[:result]

          def call(params)
            case create_user.call(params.to_h)
            in Success(result)
              self.body = result.to_h.to_json
              self.status = 200
            in Failure(result)
              self.body = { errors: result.errors.to_h }.to_json
              self.status = 422
            end
          end
        end
      end
    end
  end
end
</code></pre>

<p>At the top of this controller action, we import the <code>create_user</code> transaction by using the <code>Import</code> constant that we made a few parts ago – this is from <code>dry-auto_inject</code>.</p>

<p>Then we include <code>Dry::Moands[:result]</code> – this gives us access to the <code>Success</code> and <code>Failure</code> methods we use inside the action.</p>

<p>Inside the action itself, we call the transaction and then use Ruby 2.7’s new pattern matching to decide what to do. In the case of a successful transaction, we return the body of the result. If it fails, we return the errors and set the status to 422.</p>

<p>This should be exactly what our test is expecting. Let’s run them again and find out:</p>

<pre><code>2 examples, 0 failures
</code></pre>

<p>Good! Our tests for our router are now passing. But this only means that our router is working, not that we can serve HTTP requests yet! We need one final piece for that to work.</p>

<h2 id="racking-up-the-server">Racking up the server</h2>

<p>To run our HTTP server, we’ll use a gem called <code>puma</code>. Let’s add that gem to the <code>Gemfile</code> now:</p>

<pre><code>gem "puma"
</code></pre>

<p>And we’ll run <code>bundle install</code> to install it.</p>

<p>To run the Puma server, we can use the command by the same name:</p>

<pre><code>puma
</code></pre>

<p>When we do this, we get an error:</p>

<pre><code>Puma starting in single mode...
* Version 3.12.1 (ruby 2.7.0-p0), codename: Llamas in Pajamas
* Min threads: 0, max threads: 16
* Environment: development
ERROR: No application configured, nothing to run
</code></pre>

<p>This is because Puma hasn’t been told what to run yet. The good thing for us is that Puma will look for a special file to know what to run. That file is called <code>config.ru</code>. Let’s create that file now:</p>

<pre><code class="language-ruby">require_relative "config/application"

Bix::Application.finalize!

run Bix::Web.app
</code></pre>

<p>This file looks a lot like <code>bin/console</code>:</p>

<pre><code class="language-ruby">#!/usr/bin/env ruby

require_relative '../config/application'

Bix::Application.finalize!

require 'irb'
IRB.start
</code></pre>

<p>The difference is that we’re starting a server, instead of starting a console session.</p>

<p>Let’s try <code>puma</code> again:</p>

<pre><code>Puma starting in single mode...
* Version 3.12.1 (ruby 2.7.0-p0), codename: Llamas in Pajamas
* Min threads: 0, max threads: 16
* Environment: development
* Listening on tcp://0.0.0.0:9292
</code></pre>

<p>Great! We now have a HTTP server listening on port 9292.</p>

<p>To test this out, we can do one of two things. If you have the marvellous <a href="http://httpie.org">httpie</a> installed, you can run this command:</p>

<pre><code>http --json post http://localhost:9292/users first_name=Ryan last_name=Bigg
</code></pre>

<p>Otherwise, if you’re using <code>curl</code>, it’s a little more verbose:</p>

<pre><code>curl --request 'POST' \
-i \
--header 'Content-Type: application/json' \
--data '{"first_name":"Ryan"}' \
'http://localhost:9292/users'
</code></pre>

<p>(Use HTTPie!)</p>

<p>Either way, what we’ll see returned here is a validation error message indicating that our input was not quite complete:</p>

<pre><code>HTTP/1.1 422 Unprocessable Entity
Content-Length: 39
Content-Type: application/json; charset=utf-8

{
    "errors": {
        "last_name": [
            "is missing"
        ]
    }
}
</code></pre>

<p>Note here that the HTTP status is 422 as well.</p>

<p>Great, so that means the <em>failure</em> case for our action is now working as we wished it would.</p>

<p>Let’s see if we can test out the success case too with this <code>http</code> call:</p>

<pre><code>http --json post http://localhost:9292/users first_name=Ryan last_name=Bigg
</code></pre>

<p>Or this <code>curl</code> one:</p>

<pre><code>curl --request 'POST' \
-i \
--header 'Content-Type: application/json' \
--data '{"first_name":"Ryan", "last_name": "Bigg"}' \
'http://localhost:9292/users'
</code></pre>

<p>Now we will see a successful response:</p>

<pre><code>HTTP/1.1 200 OK
Content-Length: 140
Content-Type: application/json; charset=utf-8

{
    "age": null,
    "created_at": "[timestamp]",
    "first_name": "Ryan",
    "id": 6,
    "last_name": "Bigg",
     "updated_at": "[timestamp]"
}

</code></pre>

<p>And that’s all now working!</p>

<h2 id="summary">Summary</h2>

<p>In this fourth and final part of the ROM and Dry showcase, we barely looked at either Rom or Dry! Instead, we looked at some pieces of the Hanami web framework.</p>

<p>The Hanami web framework is a great alternative to the Rails framework that <a href="https://ryanbigg.com/2018/03/my-thoughts-on-hanami">I’ve loved for a few years</a>. What’s been great about Hanami in this series is that we were able to opt-in to using Hanami’s <code>hanami-router</code> and <code>hanami-controller</code> gems without having to opt-in to absolutely everything else from Hanami too.</p>

<p>These gems, along with the <code>puma</code> and <code>rack</code> gems, have allowed us to build a HTTP interface to our application. Our application is now capable of receiving and responding to HTTP requests.</p>

<p>I hope that this series has given you a great demonstration of what the rom-rb, dry-rb and Hanami gems are capable of. I strongly believe that these are viable, new-age alternatives to Rails for building modern Ruby applications.</p>

<p>I hope you continue to explore what these gems can offer and how you can approach building better, easier to maintain applications with them.</p>
]]></content>
 </entry>
 
 <entry>
   <title>ROM + Dry Showcase: Part 3 - Testing</title>
   <link href="http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-3"/>
   <updated>2020-02-03T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-3</id>
   <content type="html"><![CDATA[<p>This is the 3rd part of a 4 part series covering the <a href="https://rom-rb.org/">rom-rb</a> and <a href="https://dry-rb.org/">dry-rb</a> suites of gems.</p>

<ul>
  <li>Part 1: <a href="/2020/02/rom-and-dry-showcase-part-1">Application + Database setup</a></li>
  <li>Part 2: <a href="/2020/02/rom-and-dry-showcase-part-2">Validations + Transactions</a></li>
</ul>

<p>In this 3rd part, we’re going to look at how we can test the application that we’ve built so far. In particular, we’ll test three classes:</p>

<ul>
  <li>The contract – to ensure it validates input correctly</li>
  <li>The repository – to ensure we can insert data into our database correctly and that we could find data once it is inserted</li>
  <li>The transaction – to ensure that we can process the whole transaction correctly</li>
</ul>

<p>When we get up to the transaction part, we’ll see how we can use one more feature of <code>dry-auto_inject</code> to stub out the repository dependency in this particular test. Why would we want to stub out this dependency? Because we already have tests that make sure that our repository works! We don’t need to test it again a second time in the transaction class.</p>

<p>Let’s get started!</p>

<h2 id="adding-rspec">Adding RSpec</h2>

<p>First things first! We will need to set up the RSpec testing framework, and a gem called <code>database_cleaner-sequel</code>. The database cleaner gem will ensure that our database is kept pristine across the different tests in our application. If we have data “leaking” across tests, that data may influence the outcome of other tests.</p>

<p>Let’s add these gems to our <code>Gemfile</code> now:</p>

<pre><code class="language-ruby">group :test do
  gem 'rspec'
  gem 'database_cleaner-sequel'
end
</code></pre>

<p>We’ve put these gems in a “test” group, as we will not want them installed when we deploy to production.</p>

<p>Then we’ll install these gems locally with <code>bundle install</code>.</p>

<p>Next up, we can initialize RSpec by running:</p>

<pre><code>bundle exec rspec --init
</code></pre>

<p>This will create us a <code>spec</code> directory with a file called <code>spec_helper.rb</code> in it. Here’s that file with the comments removed <em>and</em> with the database cleaner configuration added:</p>

<pre><code class="language-ruby">RSpec.configure do |config|
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups

  config.before do
    DatabaseCleaner.clean
  end
end

require_relative '../config/application'
Bix::Application.finalize!

require 'database_cleaner/sequel'
DatabaseCleaner.strategy = :truncation
</code></pre>

<p>At the bottom of this file, I’ve also added two lines to require <code>config/application.rb</code> and to finalize our application. This will ensure that by
the time the tests run everything for our application has been loaded.</p>

<p>At the bottom of the <code>configure</code> block, we clean the database to ensure that each and every test starts out with a completely empty database. How that database gets cleaned is defined by the final two lines in this file: it’s a <code>truncation</code> strategy meaning that each table in our database will be truncated before the test runs.</p>

<p>That’s all the setup that we’ll need to do here. Let’s write our first couple of tests for the contract.</p>

<h2 id="testing-the-contract">Testing the contract</h2>

<p>When we go to test a contract, we want to be sure that both the valid <em>and</em> invalid paths are covered effectively. Let’s start off with the invalid paths first and we’ll finish with the valid one. We’ll create a new file in <code>spec/contracts/users/create_user_spec.rb</code>:</p>

<pre><code class="language-ruby">require 'spec_helper'

RSpec.describe Bix::Contracts::Users::CreateUser do
  context "requires first_name" do
    let(:input) do
      {
        last_name: "Bigg",
        age: 32
      }
    end

    let(:result) { subject.call(input) }

    it "is invalid" do
      expect(result).to be_failure
      expect(result.errors[:first_name]).to include("is missing")
    end
  end

  context "requires last_name" do
    let(:input) do
      {
        first_name: "Ryan",
        age: 32
      }
    end

    let(:result) { subject.call(input) }

    it "is invalid" do
      expect(result).to be_failure
      expect(result.errors[:last_name]).to include("is missing")
    end
  end
end
</code></pre>

<p>In both of these tests, we’re setting up some invalid input for the contract. And also in both of these tests, we’re asserting that the contract shows us an error indicating either the <code>first_name</code> or <code>last_name</code> fields are missing.</p>

<p>We can run this test with <code>bundle exec rspec</code>. When we do this, we’ll see that the contract is working as intended:</p>

<pre><code>2 examples, 0 failures
</code></pre>

<p>This is good to see, and will now provide us with a safety net. If someone was to delete one of the lines from the contract <em>perhaps accidentally</em>, then our tests would catch that.</p>

<p>Let’s add another test for the happy path, the path of successful validation, to this file too:</p>

<pre><code class="language-ruby">RSpec.describe Bix::Contracts::Users::CreateUser do
  context "given valid parameters" do
    let(:input) do
      {
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32
      }
    end

    let(:result) { subject.call(input) }

    it "is valid" do
      expect(result).to be_success
    end
  end

  ...
</code></pre>

<p>In this test, we provide all the correct values for the input and therefore our contract should be successful. Let’s run the tests again and see:</p>

<pre><code>3 examples, 0 failures
</code></pre>

<p>Great!</p>

<p>We’re able to test our contract just like a standard Ruby class. We initialize the contract, and then depending on the input it is given, the contract with either succeed or fail.</p>

<h2 id="testing-the-repository">Testing the repository</h2>

<p>To test the repository, we can take the same kind of path. For this repository’s tests, we need to assert that the <code>create</code> method for <code>Bix::Repos::UserRepo</code> does a few things. What things? Well, let’s look at our code for the repository:</p>

<pre><code class="language-ruby">module Bix
  module Repos
    class UserRepo &lt; ROM::Repository[:users]
      include Import["container"]

      struct_namespace Bix

      commands :create,
        use: :timestamps,
        plugins_options: {
          timestamps: {
            timestamps: %i(created_at updated_at)
          }
        }

      def all
        users.to_a
      end
    end
  end
end
</code></pre>

<p>The repository has a <code>create</code> method and with this method we need to make sure:</p>

<ul>
  <li>The method returns a <code>Bix::User</code> object – because <code>struct_namespace</code> has configured the repository to use the <code>Bix</code> namespace for all structs.</li>
  <li>That the <code>Bix::User</code> object returned has an <code>id</code> attribute – this ID is automatically set by the database</li>
  <li>That both <code>created_at</code> and <code>updated_at</code> are set automatically – based on how we’ve configured the command at the top of the repository.</li>
</ul>

<p>The repository also has an <code>all</code> method, and just to be thorough we can add a simple test for this method to assert that <code>Bix::User</code> objects are returned.</p>

<p>Let’s add the tests for the <code>create</code> method first. We’ll create a new file at <code>spec/repos/user_repo_spec.rb</code> for these tests:</p>

<pre><code class="language-ruby">require "spec_helper"

RSpec.describe Bix::Repos::UserRepo do
  context "#create" do
    it "creates a user" do
      user = subject.create(
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32,
      )

      expect(user).to be_a(Bix::User)
      expect(user.id).not_to be_nil
      expect(user.first_name).to eq("Ryan")
      expect(user.last_name).to eq("Bigg")
      expect(user.created_at).not_to be_nil
      expect(user.updated_at).not_to be_nil
    end
  end
end
</code></pre>

<p>This test asserts that when we call <code>create</code> on our repository that it will return a <code>Bix::User</code> object and that the object has values for <code>id</code>, <code>first_name</code>, <code>last_name</code>, <code>created_at</code> and <code>updated_at</code>.</p>

<p>If we run this test with <code>bundle exec rspec</code>, we’ll see that it passes:</p>

<pre><code>4 examples, 0 failures
</code></pre>

<p>Good! We’ve now asserted that at least the <code>struct_namespace</code> and <code>commands</code> methods from our repository are working as they should. If a mistake was to be made, like accidentally removing the <code>struct_namespace</code> method from the repository, our test would break:</p>

<pre><code>  1) Bix::Repos::UserRepo#create creates a user
     Failure/Error: expect(user).to be_a(Bix::User)
       expected #&lt;ROM::Struct::User ...&gt; to be a kind of Bix::User
</code></pre>

<p>The issue with this repository returning a <code>ROM::Struct::User</code> object instead of a <code>Bix::User</code> object is that the <code>ROM::Struct::User</code> objects will not have access to any of <code>Bix::User</code>’s methods, like <code>full_name</code>. If we had this mistake in our application, and we tried using <code>User#full_name</code> then our application would break. This demonstrates why it’s important to have tested that <code>struct_namespace</code> is working.</p>

<p>Let’s add another quick test to our repository to test <code>all</code>:</p>

<pre><code class="language-ruby">context "#all" do
  before do
    subject.create(first_name: "Ryan", last_name: "Bigg", age: 32)
  end

  it "returns all users" do
    users = subject.all
    expect(users.count).to eq(1)
    expect(users.first).to be_a(Bix::User)
  end
end
</code></pre>

<p>This test uses <code>create</code> to setup a user in our database, and then asserts that when we call <code>all</code> we get a user back.</p>

<p>If we run this test, we’ll see that it’s already working:</p>

<pre><code>5 examples, 0 failures
</code></pre>

<p>This means that our <code>all</code> method now has some test coverage. If this method was to break <em>somehow</em>, then our test would indicate that the method was faulty and then we wwould know to fix it.</p>

<h2 id="testing-the-transaction">Testing the transaction</h2>

<p>So far, our testing of contracts and repositories has been very straightforward Ruby class tests. We have relied on <code>subject</code> from RSpec which is a method that behaves like this:</p>

<pre><code>def subject
  &lt;described class&gt;.new
end
</code></pre>

<p>Now we’re going to look at how to test a transaction, and here’s where things are going to get more interesting. Rather than relying on RSpec’s own <code>subject</code>, we’re going to define our own. And when we define our own, we’re going to use a feature of <code>dry_auto-inject</code>, called <em>dependency injection</em>. This feature will allow us to inject a stubbed repository into our transaction, so that we don’t have to hit the database for our transaction’s test.</p>

<p>Not hitting the database means that we will save time on this test: there’s no need to make a request to a system outside of our Ruby code, and that’ll also mean that <code>database_cleaner</code> will not need to clean anything from the database. Ultimately, by injecting the repository dependency into our application’s transactions when we’re testing them means that we can have fast transcation tests.</p>

<p>Let’s look at how to do this by creating a new file at <code>spec/transactions/users/create_user_spec.rb</code>:</p>

<pre><code class="language-ruby">require 'spec_helper'

RSpec.describe Bix::Transactions::Users::CreateUser do
  let(:user_repo) { double("UserRepo") }
  let(:user) { Bix::User.new(id: 1, first_name: "Ryan") }

  subject { described_class.new(user_repo: user_repo) }

  context "with valid input" do
    let(:input) do
      {
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32,
      }
    end

    it "creates a user" do
      expect(user_repo).to receive(:create) { user }
      result = subject.call(input)
      expect(result).to be_success
      expect(result.success).to eq(user)
    end
  end
end
</code></pre>

<p>In this test, we define our own <code>subject</code> block, which will override RSpec’s default. We inject the <code>user_repo</code> dependency into the transaction object by passing a <code>user_repo</code> key in the <code>new</code> method. This works because <code>dry-auto_inject</code> re-defines <code>initialize</code> for classes when we use this syntax:</p>

<pre><code class="language-ruby">include Import[
  "contracts.users.create_user",
  "repos.user_repo"
]
</code></pre>

<p>By default, <code>dry-auto_inject</code> will load the contract class <code>Bix::Contracts::Users::CreateUser</code>, as well as the repo class <code>Bix::Repos::UserRepo</code> and provide them to the class through the <code>create_user</code> and <code>user_repo</code> methods automatically. The keys that we provide to <code>Import[]</code> here match the keys that are automatically defined by <code>dry-system</code> when it automatically registers the components for our application.</p>

<p>If we want to swap in something else for either the contract or the repository, we can do that by passing in a key matching the name (either <code>create_user</code> or <code>user_repo</code>) when we initialize this class. Just like we do in our test!</p>

<p>If we wanted to do this ourselves, without any sort of dry gem magic, it would look like this:</p>

<pre><code class="language-ruby">attr_reader :user_repo, :create_user

def initialize(
  user_repo: Bix::Repos::UserRepo.new,
  create_user: Bix::Contracts::Users::CreateUser.new
)
  @user_repo = user_repo
  @create_user = create_user
end
</code></pre>

<p>As we can see, by using <code>dry-auto_inject</code> along with <code>dry-system</code> we get to save a lot of typing.</p>

<p>Let’s look at that test again:</p>

<pre><code class="language-ruby">require 'spec_helper'

RSpec.describe Bix::Transactions::Users::CreateUser do
  let(:user_repo) { double(Bix::Repos::UserRepo) }
  let(:user) { Bix::User.new(id: 1, first_name: "Ryan") }

  subject { described_class.new(user_repo: user_repo) }

  context "with valid input" do
    let(:input) do
      {
        first_name: "Ryan",
        last_name: "Bigg",
        age: 32,
      }
    end

    it "creates a user" do
      expect(user_repo).to receive(:create) { user }
      result = subject.call(input)
      expect(result).to be_success
      expect(result.success).to eq(user)
    end
  end
end
</code></pre>

<p>The test asserts that when we use <code>subject.call</code> that the repository receives the <code>create</code> method once. We’ve stubbed this method to return a <code>Bix::User</code> object, and that’s what we’ll see when we call <code>result.success</code> at the end of the test.</p>

<p>Let’s run this test and we’ll see how it goes:</p>

<pre><code>6 examples, 0 failures
</code></pre>

<p>Success! We’re able to test our transaction without it hitting the database at all. This means that our transaction test is isolated from the database, leading to it being quick. While we only have one transaction test <em>now</em>, as this application grows and we add further transaction tests this quickness will quickly pile-up to a big benefit.</p>

<p>There’s also another benefit of this isolation: if we had database constraints then we would have to cater for those in this test.  Imagine for instance that when we created users that they had to be associated with a “Group” and that Groups had to be associated with an “Account”. In a normal application to test such a thing, we would need to create three separate objects our database: an account, a group, and a user.</p>

<p>For one test, it won’t matter too much. But if accounts, groups and users are the <em>core</em> of our application, it would quickly stack up to lots of database calls. By stubbing out the user repository dependency while testing this transaction, we have isolated that test from any database concern. A better place to test that sort of database concern would be in the repository test, anyway.</p>

<p>To finish up, let’s add one more test for what happens when this transaction fails due to invalid input:</p>

<pre><code class="language-ruby">context "with invalid input" do
  let(:input) do
    {
      last_name: "Bigg",
      age: 32,
    }
  end

  it "does not create a user" do
    expect(user_repo).not_to receive(:create)
    result = subject.call(input)
    expect(result).to be_failure
    expect(result.failure.errors[:first_name]).to include("is missing")
  end
end
</code></pre>

<p>This <code>input</code> is missing a <code>first_name</code> key, and so our transaction should fail. This means that the <code>user_repo</code> should <em>never</em> receive a <code>create</code> method, because our transaction will only call that if the <code>validate</code> step passes. When the validation fails, we would expect the result from this transaction to be a failure, and that failure to contain errors indicating what went wrong.</p>

<p>When we run this test with <code>bundle exec rspec</code>, we’ll see it pass:</p>

<pre><code>7 examples, 0 failures
</code></pre>

<h2 id="summary">Summary</h2>

<p>In this 3rd part of the ROM and Dry showcase, we’ve seen how easy it is to add tests to our application to ensure that the individual parts of the application are working.</p>

<p>We saw that in order to test a contract and a repository, we can initialize either class and call the methods we want to test. There’s nothing particularly special that we’ve had to do to test these classes; we treat them like the plain Ruby classes they are.</p>

<p>When testing the transaction, we’ve chosen to isolate those tests from the database by injecting a stubbed <code>UserRepo</code> object in place of the real thing. This isolation will mean that our tests will not have to concern themselves with setting up database state – for instance, if we had foreign key constraints – and over time it will mean that our transaction tests will be lightning fast.</p>

<p>In the next part of this series, we’ll add the final piece of our application to our stack: a way to make HTTP requests. And we’ll <em>definitely</em> be adding tests for this too!</p>
]]></content>
 </entry>
 
 <entry>
   <title>ROM + Dry Showcase: Part 2 - Validations &amp; Transactions</title>
   <link href="http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-2"/>
   <updated>2020-02-02T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-2</id>
   <content type="html"><![CDATA[<p>This is the 2nd part of a 4 part series covering the <a href="https://rom-rb.org/">rom-rb</a> and <a href="https://dry-rb.org/">dry-rb</a> suites of gems.</p>

<ul>
  <li>Part 1: <a href="/2020/02/rom-and-dry-showcase-part-1">Application + Database setup</a></li>
</ul>

<p>In this part, we’re going to look at how to add data validation to our application. Our application currently has a way of creating users, but there’s nothing preventing those users being created without their <code>first_name</code> or <code>last_name</code> set. In this part, we’ll add some code to validate that both of these fields are set. We’re going to add this code by using a gem called <code>dry-validation</code>.</p>

<p>When we’ve added this code, it’s going to sit apart from the repositories and relations that we’ve built already, and we will need a way of connecting these pieces. The way that we will connect these pieces is through the <code>dry-monads</code> gem.</p>

<p>When we’re done here, we’ll have a class that encapsulates all the actions of creating a user:</p>

<ol>
  <li>Validates <code>first_name</code> and <code>last_name</code> are present</li>
  <li>If they aren’t present, returns an error.</li>
  <li>If they are present, the user data is persisted to the database</li>
</ol>

<p>We’ll call this class a <em>transaction</em>, as it will contain all the logic for performing a particular <em>transaction</em> with our system; the transaction of creating a new user.</p>

<p>If you’d like to see the code for this application, it’s at <a href="https://github.com/radar/bix">github.com/radar/bix</a>, and each part of this series has its own branch.</p>

<p>Let’s begin!</p>

<h2 id="adding-validations">Adding validations</h2>

<p>Validations are a key part of any application. We need to make sure that before data is stored in our database that it is valid. In our currently very small application, we so far have just one type of data: users. Still, in this tiny application it doesn’t really make much sense to create users that don’t have a name. In this section we’re going to add a class that will validate a particular input for user data is valid.</p>

<p>To start with, we’ll need to add the <code>dry-validation</code> gem to our <code>Gemfile</code>:</p>

<pre><code class="language-ruby">gem 'dry-validation', '~&gt; 1.4'
</code></pre>

<p>Next up, we’ll need to install the gem:</p>

<pre><code class="language-bash">bundle install
</code></pre>

<p>We’ll need to require this gem somewhere too, so that it is loaded in our application. To load this gem and other gems that we’ll add in the future, we’ll create a new file at <code>system/boot/core.rb</code>.</p>

<pre><code class="language-ruby">Bix::Application.boot(:core) do
  init do
    require "dry-validation"
  end
end
</code></pre>

<p>This new file will include any sort of setup logic that we will need for the <em>core</em> part of our application. This is going to be everything that we’ll need when running the plain Ruby code for our application. We have a <code>db.rb</code> and <code>persistence.rb</code> file in this same directory that contains logic for anything we want to do with a database. n the last part of this guide, we’ll add a fourth file in this directory called <code>web.rb</code> and that file will contain setup logic for anything to do with handling web requests.</p>

<p>The <code>dry-validation</code> gem allows us to create classes to encapsulate validation logic, and this gem uses another dry-rb gem under the hood called <a href="https://dry-rb.org/gems/dry-schema/1.4"><code>dry-schema</code></a></p>

<p>These classes are called <em>contracts</em>. We’ll create our first contract at <code>lib/bix/contracts/users/create_user.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Contracts
    module Users
      class CreateUser &lt; Dry::Validation::Contract
        params do
          required(:first_name).filled(:string)
          required(:last_name).filled(:string)
          optional(:age).filled(:integer)
        end
      end
    end
  end
end
</code></pre>

<p>This class defines a contract that says that when we’re creating users, there has to be at least two parameters – <code>first_name</code> and <code>last_name</code>, and they both have to be <code>filled</code> (present) strings. This contract also says that an <code>age</code> parameter is optional, but when it’s specified it’s an integer. Let’s try using this contract now in <code>bin/console</code>:</p>

<pre><code class="language-ruby">create_user = Bix::Contracts::Users::CreateUser.new
result = create_user.call({})
</code></pre>

<p>To use this contract, we need to initialize a new object from the class and then use the <code>call</code> method on that new object. The argument that we pass it are the parameters for the contract, which in this case is just an empty Hash.</p>

<p>When we call this contract, we see the validation errors returned:</p>

<pre><code>=&gt; #&lt;Dry::Validation::Result{} errors={:first_name=&gt;["is missing"], :last_name=&gt;["is missing"]}&gt;
</code></pre>

<p>The returned object is a <code>Result</code> object, and with that result object we can determine if the validation was successful by calling the <code>success?</code> method:</p>

<pre><code class="language-ruby">result.success?
# =&gt; false
</code></pre>

<p>If we wanted to display these error messages (for example, as feedback to a user) we could call:</p>

<pre><code class="language-ruby">result.errors.to_h
=&gt; {:first_name=&gt;["is missing"], :last_name=&gt;["is missing"]}
</code></pre>

<p>Let’s look at what happens when we pass valid data, but with a twist: all of our values are strings. This is the kind of data you would get from a form submission through a web application:</p>

<pre><code class="language-ruby">create_user = Bix::Contracts::Users::CreateUser.new
result = create_user.call(first_name: "Ryan", last_name: "Bigg", age: "32")
=&gt; #&lt;Dry::Validation::Result{:first_name=&gt;"Ryan", :last_name=&gt;"Bigg", :age=&gt;32} errors={}&gt;
result.success?
# =&gt; true
</code></pre>

<p>Great, our contract is correctly validating input! What’s interesting to note here is that the <code>age</code> parameter is being correctly typecast from a String to an Integer. This is because we have defined that field to be an <code>integer</code> in our contract:</p>

<pre><code class="language-ruby">module Bix
  module Contracts
    module Users
      class CreateUser &lt; Dry::Validation::Contract
        params do
          required(:first_name).filled(:string)
          required(:last_name).filled(:string)
          optional(:age).filled(:integer)
        end
      end
    end
  end
end
</code></pre>

<p>If we pass data from a form submission through our contract before we work through it, the data will have all the correct types and we don’t need to coerce that data when we’re working with – dry-validation has done that for us. After this point, our data will always be in the correct type.</p>

<p>Another thing to note with our new contract is that it will only return the specified fields. Extra fields will be ignored:</p>

<pre><code class="language-ruby">create_user = Bix::Contracts::Users::CreateUser.new
result = create_user.call(first_name: "Ryan", last_name: "Bigg", age: "32", admin: true)
# =&gt; #&lt;Dry::Validation::Result{:first_name=&gt;"Ryan", :last_name=&gt;"Bigg", :age=&gt;32} errors={}&gt;
</code></pre>

<p>The <code>admin</code> field doesn’t appear here at all, even though we’ve specified it as an input to this contract.</p>

<p>So in summary, here’s what we’re given by using a <code>dry-validation</code> contract:</p>

<ul>
  <li>Validations to ensure fields meet certain criteria</li>
  <li>Automatic type coercion of fields into their correct types</li>
  <li>Automatic limiting of input to just the fields we have specified</li>
</ul>

<h2 id="intro-to-dry-monads">Intro to Dry Monads</h2>

<p>Now that we have a way to create user records (the <code>Bix::Repos::UserRepo</code>) and a way to validate that data before it gets into the database <code>(Bix::Contracts::Users::CreateUser</code>), we can combine them to ensure data is valid before it reaches out database.</p>

<p>To do this combination, we could write a class like this:</p>

<pre><code class="language-ruby">class CreateUser
  def call(input)
    create_contract = Bix::Contracts::Users::Create.new
    result = create_contract.call(input)
    if result.success?
      user_repo = Bix::Repos::User.new
      user_repo.create(input)
    else
      result
    end
  end
end
</code></pre>

<p>From the start, this class doesn’t look so bad. But if we added one more <code>if</code> condition or perhaps some code to send a “successful sign up” email to a user, this class would get longer and more complex.</p>

<p>To avoid that kind of complexity, the <code>dry-rb</code> suite of gems provides another gem called <code>dry-monads</code>. Among <a href="https://dry-rb.org/gems/dry-monads/1.3/getting-started/">other things</a>, this <code>dry-monads</code> gem provides us with a feature called “Do Notation”. This feature will allow us to write our <code>CreateUser</code> class in a much cleaner way that will also allow for extensibility later on – if we want that.</p>

<p>Let’s add this gem to our <code>Gemfile</code> now:</p>

<pre><code class="language-ruby">gem 'dry-monads', '~&gt; 1.3'
</code></pre>

<p>And we’ll run <code>bundle install</code> to install it.</p>

<p>Next up, we will need to require this gem in <code>system/boot/core.rb</code>:</p>

<pre><code class="language-ruby">Bix::Application.boot(:core) do
  init do
    require "dry-validation"
    require "dry/monads"
    require "dry/monads/do"
  end

  start do
    Dry::Validation.load_extensions(:monads)
  end
end
</code></pre>

<p>We’ve changed <code>core.rb</code> here to require <code>dry/monads</code> and <code>dry/monads/do</code>. The second file will give us access to Dry Monad’s <em>Do Notation</em> feature. We’ve added a <code>start</code> block here, which will run when our application is finalized. This will add an extra <code>to_monad</code> method to our validation results. We’ll see this used in a short while.</p>

<p>Before we get there, we need to talk about two things. One is called the <em>Result Monad</em>, and the other is the <em>Do Notation</em>.</p>

<h3 id="result-monad">Result Monad</h3>

<p>The Result Monad is a type of object that can represent whether an action has succeeded or failed. Where it comes in handy is when you have a chain of actions that you might want to stop if one of those things goes wrong. For instance, in the above code when the user is invalid, we want the code to not persist the user to the database.</p>

<p>To do this with <code>dry-monads</code>, we would return one of two types of the result monad, a <code>Success</code> or <code>Failure</code>. Here’s a flowchart showing what would go on when we use a Result monad:</p>

<p><img src="/images/rom/dry-monads.png" alt="Result monad diagram" /></p>

<p>Here we have a “Create User” action that has two steps: a “Validate User” and a “Persist User” step. When our “Create User” action receives some parameters, it passes them to the “Validate User” step. When this step runs, there can be one of two results: success or failure.</p>

<p>When the validation succeeds, that step returns a <code>Success</code> result monad which will contain the validated (and type-casted!) parameters.</p>

<p>If the validation fails, the step returns a <code>Failure</code> result monad. This monad contains the validation errors.</p>

<p>When our code sees a <code>Failure</code> Result Monad returned, it will not execute the remaining steps. In the above diagram, the validation of a user <em>must</em> succeed before persistence happens. Just like in the earlier code we wrote too.</p>

<h3 id="do-notation">Do Notation</h3>

<p>The Result Monad is used in conjunction with that other feature of <code>dry-monads</code> I mentioned earlier: Do Notation. Let’s take the above <code>CreateUser</code> class and re-write it using <code>dry-monads</code>’ Do Notation. We’ll put this class at <code>lib/bix/transactions/users/create_user.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Transactions
    module Users
      class CreateUser
        include Dry::Monads[:result]
        include Dry::Monads::Do.for(:call)


        def call(input)
          values = yield validate(input)
          user = yield persist(values)

          Success(user)
        end

        def validate(input)
          create_contract = Contracts::Users::Create.new
          create_contract.call(input).to_monad
        end

        def persist(result)
          user_repo = Bix::Repos::UserRepo.new
          Success(user_repo.create(result.values))
        end
      end
    end
  end
end
</code></pre>

<p>This code is a bit longer than the code we had previously. However, it comes with a few benefits. The first of these is that each step is clearly split out into its own method.</p>

<aside>
  <header>The <code>call</code> dumping ground anti-pattern</header>

  <p>
    No longer are we just throwing <em>everything</em> into the <code>call</code> function.
  </p>

  <p>
    This is a common trap for developers who adopt this kind of <em>transaction</em> (or "service") pattern. They split out a class from a controller, and then dump everything into the <code>call</code> method! The code is no cleaner when you've done this, it has simply been swept under the proverbial rug.
  </p>

  <p>
    A much better approach is a call method that delegates to <em>other</em> methods.
  </p>
</aside>

<p>The <code>call</code> method here is responsible for ordering the steps of our transaction. It takes our initial <code>input</code> for this transaction and runs it through the validator. All of that validation logic is neatly gathered together in the <code>validate</code> method:</p>

<pre><code class="language-ruby">def validate(input)
  create_contract = Contracts::Users::CreateUser.new
  create_contract.call(input).to_monad
end
</code></pre>

<p>In this method, we use our contract that we built earlier. When we call this contract, it will return a <code>Dry::Validation::Result</code> object. To use this in conjunction with <code>dry-monads</code>’ Do Notation, we need to convert this object to a Result Monad. We do this by calling <code>to_monad</code> on the result.</p>

<p>If the validation succeeds, we’ll get back a <code>Success(validated_input)</code> result monad, otherwise a <code>Failure(validation_result)</code> result monad will be returned.</p>

<p>If it fails at this point, the transaction will stop and return the validation failure.</p>

<p>If it succeeds however, the transaction to the next step: <code>create_user</code>:</p>

<pre><code class="language-ruby">def create_user(result)
  user_repo = Bix::Repos::UserRepo.new
  Success(user_repo.create(result.values))
end
</code></pre>

<p>This step takes a <code>result</code> argument, which will be the <code>validated_input</code> returned from our validation step. We then initialise a new repo, and use that to create a user, taking the <code>result.values</code>. These values will be the validated and type-casted values from the validation’s result.</p>

<p>Let’s try using this class now in <code>bin/console</code>:</p>

<pre><code class="language-ruby">create_user = Bix::Transactions::Users::CreateUser.new
result = create_user.call(first_name: "Ryan", last_name: "Bigg", age: 32)
# =&gt; Success(#&lt;Bix::User id=4 first_name="Ryan" last_name="Bigg" age=32 ...&gt;)
</code></pre>

<p>When we use this transaction, it runs the validation and persistence steps for us. If everything goes well, like in the above example, then we get back a <code>Success</code> result monad.</p>

<p>Let’s see what happens if the validation fails in this transaction:</p>

<pre><code class="language-ruby">create_user = Bix::Transactions::Users::CreateUser.new
result = create_user.call(first_name: "Ryan", last_name: "", age: 32)
# =&gt; Failure(#&lt;Dry::Validation::Result{:first_name=&gt;"Ryan", :last_name=&gt;"", :age=&gt;32} errors={:last_name=&gt;["must be filled"]}&gt;)
</code></pre>

<p>This time, we get back a <code>Failure</code> result monad, which is wrapping our <code>Dry::Validation::Result</code>. This will mean that the persistence won’t happen at all.</p>

<p>Our transaction class so far has only two methods, but <em>could</em> be expanded out to include more. Perhaps we would want to send an email to the user to confirm that they’ve signed up?</p>

<p>Or what if we had a transaction class that handled account signup, where both an account <em>and</em> a user had to be created? A flowchart for that transaction class would look like this:</p>

<p><img src="/images/rom/dry-monads-complex.png" alt="More complex transaction diagram" /></p>

<p>A transaction class is a great way of grouping together all these steps into small, discrete methods.</p>

<h2 id="handling-success-or-failure">Handling success or failure</h2>

<p>Let’s now think about how we would actually use this <code>CreateUser</code> transaction class in a real context, something a bit more specialised than a simple <code>bin/console</code> session. For this section, we’ll create a new file at the root of the Bix application, called <code>transaction_test.rb</code>. In this file, we’ll put this content:</p>

<pre><code class="language-ruby">require_relative "config/application"

Bix::Application.finalize!

include Dry::Monads[:result]

input = {
  first_name: "Ryan",
  last_name: "Bigg",
  age: 32
}

create_user = Bix::Transactions::Users::CreateUser.new
case create_user.call(input)
when Success
  puts "User created successfully!"
when Failure(Dry::Validation::Result)
  puts "User creation failed:"
  puts result.failure.errors.to_h # TODO variable result is not defined
end
</code></pre>

<p>This file starts out the same way as <code>bin/console</code>: we require <code>config/application.rb</code> and then “finalize” our application. This finalization step will load all the application’s files and start all of the application’s dependencies.</p>

<p>Next up, we include <code>Dry::Monads[:result]</code>. This gives us access to the <code>Success</code> and <code>Failure</code> result monad classes that we use at the end of this file.</p>

<p>Once we’ve set everything up, we define an input hash for our transaction, and the transaction itself. When we call the transaction, we can use a <code>case</code> to match on the outcome of the transaction. If it is successful, we output a message saying as much. If it fails, and the failure is a validation failure (indicated by the failure being a <code>Dry::Validation::Result</code> failure), we output the validation error messages.</p>

<p>Here we’ve seen a very simple way of handling the success or failure of a transaction. This code is very similar to how we would use the transaction in another context, such as a controller. The great thing about a transaction is that we aren’t limited to using it just within a controller – we could use it anywhere we pleased. This example is just a small one showing us how we could use it.</p>

<p>In Part 4 of this guide, we’ll re-visit how to use this transaction in a different context.</p>

<h2 id="automatically-injecting-dependencies">Automatically injecting dependencies</h2>

<p>Before we finish up this part of the showcase, I would like to demonstrate one additional piece of cleanup that we could do. Let’s re-visit our transaction’s code:</p>

<pre><code class="language-ruby">module Bix
  module Transactions
    module Users
      class CreateUser
        include Dry::Monads[:result]
        include Dry::Monads::Do.for(:call)

        def call(params)
          values = yield validate(params)
          user = yield persist(values)

          Success(user)
        end

        def validate(params)
          create_user = Bix::Contracts::Users::CreateUser.new
          create_user.call(params).to_monad
        end

        def persist(result)
          user_repo = Bix::Repos::UserRepo.new
          Success(user_repo.create(result.values))
        end
      end
    end
  end
end
</code></pre>

<p>This code looks pretty clean as it stands. But there’s one extra thing we can do to make it even tidier, and that thing is to use <code>dry-auto_inject</code>’s import feature. When we define things like the <code>CreateUser</code> contract or the <code>UserRepo</code> within our application, these classes are automatically registered with <code>Bix::Application</code>, because we’ve directed the application to <code>auto_register</code> things in <code>lib</code>. This happened over in <code>config/application.rb</code>:</p>

<pre><code class="language-ruby">require_relative "boot"

require "dry/system/container"
require "dry/auto_inject"

module Bix
  class Application &lt; Dry::System::Container
    configure do |config|
      config.root = File.expand_path('..', __dir__)
      config.default_namespace = 'bix'

      config.auto_register = 'lib'
    end

    load_paths!('lib')
  end

  Import = Dry::AutoInject(Application)
end
</code></pre>

<p>We saw earlier that we could refer to the ROM container with the syntax <code>include Import["container"]</code> within our <code>UserRepo</code> class. Well, we can do the same thing with our contract and repository in this transaction class too.</p>

<p>Here’s how we’ll do it. At the top of the class, we’ll put these two <code>include</code> lines:</p>

<pre><code class="language-ruby">module Bix
  module Transactions
    module Users
      class CreateUser
        include Dry::Monads[:result]
        include Dry::Monads::Do.for(:call)

        include Import["contracts.users.create_user"]
        include Import["repos.user_repo"]
...
</code></pre>

<p>By using <code>include</code> like this, we will be able to access our contract and repository in a simpler fashion. To do that, we can change our <code>validate</code> and <code>persist</code> methods in this transaction to this:</p>

<pre><code class="language-ruby">def validate(params)
  create_user.call(params).to_monad
end

def persist(result)
  Success(user_repo.create(result.values))
end
</code></pre>

<p>That’s a lot cleaner, isn’t it? We’re now able to refer to the contract as simply <code>create_user</code>, and the repository as <code>user_repo</code>, without putting in those ugly namespaces into these methods. This syntax also more clearly defines the other class dependencies this transaction has, right at the top of the class. We don’t need to scan through the class to figure out what they are anymore.</p>

<p>To make sure that things are working again, let’s try running <code>ruby transaction_test.rb</code> again. If the <code>input</code> hash at the top of this file contains valid input, then we should see the successful message still:</p>

<pre><code>User created successfully!
</code></pre>

<p>If this transaction class went on to use other classes from our application, we could import them with very little effort, thanks to the <code>dry-system</code> and <code>dry-auto_inject</code> gems.</p>

<h2 id="summary">Summary</h2>

<p>In this 2nd part of the ROM and Dry showcase, we have used the <code>dry-validation</code> gem to add a  <em>contract</em> to our application. A contract is a class that contains validation logic. It’s a way of saying that incoming data must meet some criteria before our application can use it.</p>

<p>In the second half of this guide, we used <code>dry-monads</code> to define a <em>transaction</em> class within our application for creating users. This class is a collection of all the actions that our application would have to take to create a user. So far, there are only two of them: <code>validate</code> and <code>persist</code>. This class uses the contract to first validate the input, and then if that validation succeeds, the class will create a user in the database by using the repo.</p>

<p>In the final part of this guide, we used <code>dry-auto_inject</code> once more to automatically inject the repository and contract into our transaction class, allowing us to tidy up the code very slightly, but still noticeably.</p>

<p>In the next part, we’re going to look at how we can test the parts of the application that we’ve built so far by using the RSpec testing framework. We’ll also see <em>another</em> advantage of <code>dry-auto_inject</code> in this part.</p>
]]></content>
 </entry>
 
 <entry>
   <title>ROM + Dry Showcase: Part 1 - Application + Database setup</title>
   <link href="http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-1"/>
   <updated>2020-02-01T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2020/02/rom-and-dry-showcase-part-1</id>
   <content type="html"><![CDATA[<p>The <a href="https://rom-rb.org/">rom-rb</a> and <a href="https://dry-rb.org/">dry-rb</a> sets of gems have come out in the last couple of years. These gems allow an alternative take on building a Ruby application, separate from Rails or Sinatra, or anything else like that.</p>

<p>In this <em>series</em> of blog posts, I am going to show you how to build a simple application that I’m calling “Bix” using some of these gems. By the end of this series, the application will:</p>

<ul>
  <li>Part 1 (you are here) - Interact with a database using ROM</li>
  <li><a href="/2020/02/rom-and-dry-showcase-part-2">Part 2 - Have validation and transaction classes</a></li>
  <li><a href="/2020/02/rom-and-dry-showcase-part-3">Part 3 - Test our application with RSpec</a></li>
  <li><a href="/2020/02/rom-and-dry-showcase-part-4">Part 4 - Have a router and a series of actions</a></li>
</ul>

<p>This part will cover how to start building out an application’s architecture. We’ll also work on having this application speak to a database. For this, we’ll use the following gems:</p>

<ul>
  <li><code>dry-system</code> – Used for loading an application’s dependencies automatically</li>
  <li>rom, <a href="https://rom-rb.org/5.0/learn/sql/">rom-sql</a> + pg – We’ll use these to connect to a database</li>
  <li><code>dotenv</code> – a gem that helps load <code>.env</code> files that contain environment variables</li>
  <li><code>rake</code> – For running Rake tasks, like migrations!</li>
</ul>

<p>In this part, we will setup a small Ruby application that talks to a PostgreSQL database, by using the <code>dry-system</code>, <code>rom</code>, <code>rom-sql</code> and <code>pg</code> gems. At the end of this guide, we will be able to insert and retrieve data from the database.</p>

<p>If you’d like to see the code for this application, it’s at <a href="https://github.com/radar/bix">github.com/radar/bix</a>, and each part of this series has its own branch.</p>

<h2 id="a-word-on-setup-costs">A word on setup costs</h2>

<p>In these guides, you may get a sense that the setup of rom-rb and dry-rb libraries takes a long time – maybe you’ll think thoughts like “this is so easy in Rails!” These are normal and understandable thoughts. The setup of this sort of thing in Rails <em>is</em> easier, thanks to its generators.</p>

<p>However, Rails leads you into an application architecture that paints you into a corner, for reasons I explained in <a href="https://www.youtube.com/watch?v=04Kq_9scT1E">my “Exploding Rails” talk in 2018</a>.</p>

<p>The setup of ROM and dry-rb things <em>is</em> harder, but leads you ultimately into a better designed application with clearer lines drawn between the classes’ responsibilties.</p>

<p>It might help to think of it in the way my friend Bo Jeanes put it:</p>

<blockquote>
  <p>Setup cost is a cost that you pay <em>once</em>, whereas ease-of-application-maintenance is a cost that you pay <em>every single day</em>.</p>
</blockquote>

<p>So in the long run, this will be better. I promise.</p>

<h2 id="installing-gems">Installing Gems</h2>

<p>To get started, we’ll create an empty directory for our application. I’ve called mine <code>bix</code>. Inside this directory you will need to create a basic <code>Gemfile</code>:</p>

<pre><code>source 'https://rubygems.org'

ruby '2.7.0'

gem 'dry-system'
gem 'rom'
gem 'rom-sql'
gem 'pg'

gem 'dotenv'
gem 'rake'
</code></pre>

<p>Once we have created that <code>Gemfile</code>, we’ll need to run <code>bundle install</code> to install all of those dependencies.</p>

<h2 id="boot-configuration">Boot Configuration</h2>

<p>Next up, we will create an environment for our application that will allow us to load dependencies of the application, such as files in <code>lib</code> or other dependencies like database configuration. We’re going to use the <code>dry-system</code> gem for this.</p>

<p>Before we get to using that gem, let’s create a file called <code>config/boot.rb</code>. This file will contain this code to load up our application’s primary gem dependencies:</p>

<pre><code class="language-ruby">ENV['APP_ENV'] ||= "development"

require "bundler"
Bundler.setup(:default, ENV["APP_ENV"])

require "dotenv"
Dotenv.load(".env", ".env.#{ENV["APP_ENV"]}")
</code></pre>

<p>The first line of code sets up an <code>APP_ENV</code> environment variable. Our application will use this environment variable to determine what dependencies to load. For instance, when we’re developing our application locally we may want to use development gems like <code>pry</code>. However, when we deploy the application to production, we will not want to use those gems. By setting <code>APP_ENV</code>, we can control what gems are loaded by our application.</p>

<p>The first block of code here will setup Bundler, which adds our gem dependencies’ paths to the load path, so that we can require them when we need to. Note that <code>Bundler.setup</code> is different from <code>Bundler.require</code> (like in a Rails application) – <code>Bundler.setup</code> only adds to the load path, and does not require everything at the beginning.</p>

<p>The two args passed here to <code>Bundler.setup</code> tell Bundler to include all gems outside of a group, and all gems inside of a group named after whatever <code>APP_ENV</code> is set to, which is <code>development</code>.</p>

<p>The first one that we require is <code>dotenv</code>, and that is just so we can load the <code>.env</code> or <code>.env.{APP_ENV}</code> files. When we’re working locally, we’ll want to have a <code>.env.development</code> file that specifies our local database’s URL. Let’s create this file now: <code>.env.development</code>:</p>

<pre><code>DATABASE_URL=postgres://localhost/bix_dev
</code></pre>

<p>This file specifies the database we want to connect to when we’re developing locally. To create that database, we will need to run:</p>

<pre><code>createdb bix_dev
</code></pre>

<h2 id="application-environment-setup">Application Environment Setup</h2>

<p>To setup our application’s environment and use this database configuration, we’re going to use that <code>dry-system</code> gem. To do this, we’ll create a new file called <code>config/application.rb</code> and put this code in it:</p>

<pre><code class="language-ruby">require_relative "boot"

require "dry/system/container"

module Bix
  class Application &lt; Dry::System::Container
    configure do |config|
      config.root = File.expand_path('..', __dir__)
      config.default_namespace = 'bix'

      config.auto_register = 'lib'
    end

    load_paths!('lib')
  end
end
</code></pre>

<p>This code is responsible for loading our <code>boot.rb</code> file and defining a <code>Bix::Application</code> <em>container</em>. This container is responsible for automatically loading dependencies in from <code>lib</code> (when we have them!). This container is also responsible for handling how system-level dependencies for our application are loaded – like how our application connects to a database.</p>

<p>To set that database connection up, we’re going to create a new file over in <code>system/boot/db.rb</code>:</p>

<pre><code class="language-ruby">Bix::Application.boot(:db) do
  init do
    require "rom"
    require "rom-sql"

    connection = Sequel.connect(ENV['DATABASE_URL'], extensions: %i[pg_timestamptz])
    register('db.connection', connection)
    register('db.config', ROM::Configuration.new(:sql, connection))
  end
end
</code></pre>

<p>This <code>system/boot</code> directory is where we put system-level dependencies when using <code>dry-system</code>. This new file that we’ve created configures how our application defines its database connection.</p>

<p>To connect to the database, we need to use the <code>rom</code> and <code>rom-sql</code> gems. These will automatically require the <code>Sequel</code> gem, and we build a database connection there using <code>Sequel.connect</code>.</p>

<p>The <code>extensions</code> option passed here tells the underlying database gem, Sequel, to load an extension called <code>pg_timestamptz</code>. This extension will create <code>timestamp with time zone</code> columns in our database, rather than the default, which is <code>timestamp without time zone</code>. This means that times will be stored with time zone information in the database and this means when we retrieve them Ruby won’t add the system’s timezone on the end. To demonstrate what I mean here, compare these three lines:</p>

<pre><code class="language-ruby">&gt;&gt; Time.parse("2020-10-14 14:23:07.155221")
=&gt; 2020-10-14 14:23:07.155221 +1100
&gt;&gt; Time.parse("2020-10-14 14:23:07.155221 UTC")
=&gt; 2020-10-14 14:23:07.155221 UTC
&gt;&gt; Time.parse("2020-10-14 14:23:07.155221 +0100")
=&gt; 2020-10-14 14:23:07.155221 +0100
</code></pre>

<p>A time <em>without</em> a timezone will have the local system’s timezone applied to the end. I’m in Melbourne and it’s Daylight Savings Time, so my timezone is +1100.</p>

<p>However, if the time comes back out of the database with a time zone (shown here to either be <code>UTC</code> or <code>+0100</code>), then the time will be parsed correctly!</p>

<p>Now that we have our database connection defined and our database itself created, we will need to create tables in that database. If this was a Rails app, we would use migrations to do such a thing. Fortunately for us, ROM “borrowed” that idea and so we can use migrations with ROM too.</p>

<p>To create migrations with ROM, we will need to create another file to define the Rake tasks, called <code>Rakefile</code>:</p>

<pre><code class="language-ruby">require_relative 'config/application'
require 'rom-sql'
require 'rom/sql/rake_task'

namespace :db do
  task :setup do
    Bix::Application.start(:db)
    config = Bix::Application['db.config']
    config.gateways[:default].use_logger(Logger.new($stdout))
  end
end
</code></pre>

<p>This file loads the <code>config/application.rb</code> file that we created earlier and that will make it possible to require the other two files we use here.</p>

<p>In order to tell ROM’s Rake tasks where our database lives, we’re required to setup a Rake task of our own: one called <code>db:setup</code>. This configuration starts the system-level dependency <code>:db</code> by calling <code>start</code> on <code>Bix::Application</code>. This will run the code inside the <code>init</code> block defined within <code>system/boot/db.rb</code>. This <code>init</code> block registers a <code>db.config</code> with our application, and we can retrieve that value by using <code>Bix::Application['db.config']</code> here. ROM will then use this value to talk to our database.</p>

<p>Using this configuration, we configure something called the <em>default gateway</em>, which is the simply the default database connection that ROM has been configured with. We <em>could</em> configure multiple gateways, but we’re only going to be using the one in this series. On this gateway, we tell it to use a new <code>Logger</code> instance, which will log SQL output for our Rake tasks.</p>

<h3 id="migrations">Migrations</h3>

<p>Like a lot of database frameworks, ROM also comes with <a href="https://rom-rb.org/5.0/learn/sql/migrations/">migrations</a>. We can use these to create the tables for our application.</p>

<p>To generate a migration with ROM, we can run:</p>

<pre><code>
rake "db:create_migration[create_users]"

</code></pre>

<p>This will create us a new file under <code>db/migrate</code> and it’ll be almost empty:</p>

<pre><code class="language-ruby"># frozen_string_literal: true

ROM::SQL.migration do
  change do
  end
end
</code></pre>

<p>It’s up to us to fill this out. Let’s do so:</p>

<pre><code class="language-ruby"># frozen_string_literal: true

ROM::SQL.migration do
  change do
    create_table :users do
      primary_key :id
      column :first_name, String
      column :last_name, String
      column :age, Integer

      column :created_at, :datetime, null: false
      column :updated_at, :datetime, null: false
    end
  end
end
</code></pre>

<p>In this migration, we’ve specified six columns. We’ve had to specify the <code>primary_key</code> here, because ROM does not assume that all primary keys are <code>id</code> by default.</p>

<p>To run this migration, we will need to run:</p>

<pre><code>rake db:migrate
</code></pre>

<p>If we see this:</p>

<pre><code>... INFO -- : Finished applying migration [timestamp]_create_users.rb, direction: up, took [duration] seconds
&lt;= db:migrate executed
</code></pre>

<p>Then the migration has been successfully applied.</p>

<h3 id="repositories">Repositories</h3>

<p>In order to get data into and out of database tables with ROM, we need to create something called a <em>repository</em>. A repository is a class that is used to define a clear API between your database and your application.</p>

<p>To create one of these, we’ll create a new file inside a new directory structure at <code>lib/bix/repos/user_repo.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Repos
    class UserRepo &lt; ROM::Repository[:users]

    end
  end
end
</code></pre>

<p>To use this class (and others that we will create later on), we’ll need to create a new file at <code>system/boot/persistence.rb</code> to setup our database configuration for our application:</p>

<pre><code class="language-ruby">Bix::Application.boot(:persistence) do |app|
  start do
    register('container', ROM.container(app['db.config']))
  end
end
</code></pre>

<p>This file uses the <code>rom</code> gem to define a database configuration container and registers it with our application under the <code>container</code> key.</p>

<p>Next up, we’ll create a new file over at <code>bin/console</code> with this in it:</p>

<pre><code class="language-ruby">#!/usr/bin/env ruby

require_relative '../config/application'

Bix::Application.finalize!

require 'irb'
IRB.start
</code></pre>

<p>This file will load our application’s <code>config/application.rb</code> file. When this file is loaded, all the files in <code>lib</code> will be required. This includes our new <code>lib/bix/repos/user_repo.rb</code> file.</p>

<p>We call <code>Bix::Application.finalize!</code> here to start our application and all of its dependencies, this includes the two system-level dependencies specified in <code>system/boot</code>.</p>

<p>Once those classes are loaded and the application is finalized <code>bin/console</code> will start an IRB prompt.</p>

<p>To make it so that we can run <code>bin/console</code>, let’s run this command:</p>

<pre><code>chmod +x bin/console
</code></pre>

<p>We can now launch our console by running:</p>

<pre><code>bin/console
</code></pre>

<p>When we’re in this console, we can use our repository:</p>

<pre><code>&gt;&gt; Bix::Repos::UserRepo.new(Bix::Application['container'])
</code></pre>

<p>This code will tell our user repository to connect to the database specified by the configuration contained within <code>Bix::Application['container']</code>. But unfortunately for us, another key part of configuration is missing and so we’re going to see an error when we run this code:</p>

<pre><code>ROM::ElementNotFoundError (:users doesn't exist in ROM::RelationRegistry registry)
</code></pre>

<p>For this code to work, we’re going to need one extra class: a <em>relation</em>.</p>

<h3 id="relations">Relations</h3>

<p>A <em>relation</em> class is used to represent data returning from a database, and is used most often by the repository itself. If we had a need for complex methods for working with data, they would go in “messy” relation methods, and then the repository would call those methods.</p>

<p>Here’s an example from an app that I’ve worked on recently. I want to have a function that works on a <code>notes</code> table, counting up all the notes for a particular set of <em>elements</em>. In my relation, I have this code:</p>

<pre><code class="language-ruby">module Twist
  module Relations
    class Notes &lt; ROM::Relation[:sql]
      schema(:notes, infer: true)

      def counts_for_element_ids(element_ids)
        where(element_id: element_ids)
        .select { [element_id, function(:count, :id).as(:count)] }
        .group(:element_id)
        .order(nil)
        .to_a
      end
    end
  end
end
</code></pre>

<p>The <code>counts_for_elements</code> method defines a <em>query</em> that will run against my database, and the final <code>to_a</code> on that query will return a <em>dataset</em>; an array of elements with their note counts.</p>

<p>However, this query will only return counts for elements that have counts, rather than all specified elements. In this particular application, I want a count for all elements specified in <code>element_ids</code>, regardless if they have notes or not. The place for this particular logic is in the <em>repository</em>:</p>

<pre><code class="language-ruby">module Twist
  module Repositories
    class NoteRepo &lt; Twist::Repository[:notes]
      def count(element_ids)
        counts = notes.counts_for_elements(element_ids)

        missing = element_ids.select { |id| counts.none? { |c| c.element_id == id } }
        counts += missing.map { |m| NoteCount.new(element_id: m, count: 0) }
        counts.map { |element_id:, count:| [element_id, count] }.to_h
      end
    end
  end
end
</code></pre>

<p>The repository’s code is all about working with the data. It does not know how to build the query for the data – that responsibility is the relation’s.</p>

<p>In short: relations run queries to get data out of a database, repositories define methods to work data returned by relations.</p>

<p>Back to Bix!</p>

<p>Let’s define our relation now at <code>lib/bix/relations/users.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Relations
    class Users &lt; ROM::Relation[:sql]
      schema(:users, infer: true)
    end
  end
end
</code></pre>

<p>This relation class inherits from <code>ROM::Relation[:sql]</code>, and that will meant hat our relation is used to talk to an SQL database.</p>

<p>Inside the class itself, there’s a method called <code>schema</code>. This method says that our relation class is for a table called <code>users</code> and that we should <em>infer</em> the attributes for that schema – meaning ROM will look at the table to define the attributes for this relation.</p>

<p>This <em>almost</em> gets us past the error we saw previously:</p>

<pre><code>ROM::ElementNotFoundError (:users doesn't exist in ROM::RelationRegistry registry)
</code></pre>

<p>However, we will need to register relations with our application’s database container. To do this, we can change <code>system/boot/persistence.rb</code>:</p>

<pre><code class="language-ruby">Bix::Application.boot(:persistence) do |app|
  start do
    config = app['db.config']
    config.auto_registration(app.root + "lib/bix")

    register('container', ROM.container(app['db.config']))
  end
end

</code></pre>

<p>This file will now automatically register this relation under <code>lib/bix</code>, and any other ROM things we add in later. This means that our <code>User</code> repository will be able to find the <code>Users</code> relation.</p>

<p>Let’s run <code>bin/console</code> again and try working with our repository again:</p>

<pre><code>&gt;&gt; user_repo = Bix::Repos::UserRepo.new(Bix::Application['container'])
&gt;&gt; user_repo.all
NoMethodError (undefined method `all' for #&lt;Bix::Repos::User struct_namespace=ROM::Struct auto_struct=true&gt;)
</code></pre>

<p>Oops! Repositores are intentionally bare-bones in ROM; they do not come with very many methods at all. Let’s exit the console and then we’ll define some methods on our repository. While we’re here, we’ll add a method for finding all the users, and one for creating users. Let’s open <code>lib/bix/repos/user_repo.rb</code> and add these methods:</p>

<pre><code class="language-ruby">module Bix
  module Repos
    class UserRepo &lt; ROM::Repository[:users]
      commands :create,
        use: :timestamps,
        plugins_options: {
          timestamps: {
            timestamps: %i(created_at updated_at)
          }
        }

      def all
        users.to_a
      end
    end
  end
end
</code></pre>

<p>The <code>commands</code> class method defines built-in commands that we can use on our repository. ROM comes with three: <code>:create</code>, <code>:update</code> and <code>:delete</code>.</p>

<p>This one tells ROM that we want a method called <code>create</code> that will let us create new records. The <code>use :timestamps</code> at the end tells ROM that we want <code>create</code> to set <code>created_at</code> and <code>updated_at</code> when our records are created.</p>

<p>The <code>all</code> method here calls the <code>users</code> relation, and the <code>to_a</code> will run a query to fetch all of the users.</p>

<p>With both of these things in place, let’s now create and retrieve a user from the database through <code>bin/console</code>:</p>

<pre><code>user_repo = Bix::Repos::UserRepo.new(Bix::Application['container'])
user_repo.create(first_name: "Ryan", last_name: "Bigg", age: 32)
=&gt; #&lt;ROM::Struct::User id=1 first_name="Ryan" last_name="Bigg" age=32 ...&gt;

user_repo.all
=&gt; [#&lt;ROM::Struct::User id=1 first_name="Ryan" last_name="Bigg" age=32 ...&gt;]
</code></pre>

<p>Hooray! We have now been able to add a record and retrieve it. We have now set up quite a few components for our application:</p>

<ul>
  <li><code>config/boot.rb</code> - Requires boot-level pieces of our application – such as Bundler and <code>dotenv</code></li>
  <li><code>config/application.rb</code> - Defines a Container for our application’s configuration</li>
  <li><code>system/boot/db.rb</code> - Specifies how our application connects to a database</li>
  <li><code>system/boot/persistence.rb</code> - Defines a ROM container that defines how the ROM pieces of our application connect to and interact with our database</li>
  <li><code>lib/bix/relations/users.rb</code> - Defines a class that can contain query logic for our <code>users</code> table</li>
  <li><code>lib/bix/repos/user_repo.rb</code> - A class that contains methods for interacting with our relation, allowing us to create + retrieve data from the databse.</li>
</ul>

<p>ROM and Dry separate our application into small, clearly defined pieces with individual responsibilities. While this setup cost feels large <em>now</em>, it’s a cost that we’re only going to be paying once; Setup cost is one-time, maintenance cost is forever.</p>

<h3 id="entities">Entities</h3>

<p>Now what happens if we want to add a custom method on to the objects returned by our database? Let’s say, a <code>full_name</code> method that would let us combine a user’s <code>first_name</code> and <code>last_name</code> attributes. Currently these are <code>ROM::Struct::User</code> objects, returned from ROM. There isn’t a place to define these methods in our application yet. So let’s create one!</p>

<p>To be able to define custom methods like <code>full_name</code> for users, we’re going to need a class. For this, ROM has a feature called <em>entities</em>. These are simple classes that can be considered as super-powered structs. Let’s build a new one by creating it in a new directory called <code>lib/bix/entities</code>, and calling it <code>user.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  class User &lt; ROM::Struct
    def full_name
      "#{first_name} #{last_name}"
    end
  end
end
</code></pre>

<p>Ignoring <a href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">the falsehoods programmers believe about names</a>, this method will combine a user’s <code>first_name</code> and <code>last_name</code> attributes.</p>

<p>To use this class though, we need to configure the repository further over in <code>lib/bix/repos/user_repo.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Repos
    class UserRepo &lt; ROM::Repository[:users]
      struct_namespace Bix

      ...
    end
  end
end
</code></pre>

<p>This <code>struct_namespace</code> method tells the repository that when it builds structs, it can use the <code>Bix</code> namespace for those structs. The class name will be the singularised version of the relation specified in the <code>ROM::Repository</code> class inheritance: <code>Bix::User</code>.</p>

<p>Let’s go back into <code>bin/console</code> and try this out:</p>

<pre><code class="language-ruby">user_repo = Bix::Repos::UserRepo.new(Bix::Application['container'])
user_repo.all.first.full_name
# =&gt; "Ryan Bigg"
</code></pre>

<p>Great! We’re now able to have a class that contains custom Ruby logic for the data that is returned from the database.</p>

<h2 id="specifying-the-container-automatically">Specifying the container automatically</h2>

<p>When we initialize our repository, we have to use some really long code to do that:</p>

<pre><code class="language-ruby">user_repo = Bix::Repos::UserRepo.new(Bix::Application['container'])
</code></pre>

<p>What if we were able to do this instead?</p>

<pre><code class="language-ruby">user_repo = Bix::Repos::UserRepo.new
</code></pre>

<p>Wouldn’t that be much nicer?</p>

<p>Well, with another one of the <code>dry-rb</code> set of gems, we can indeed do this. The last gem that we’ll use in this part is one called <code>dry-auto_inject</code>. This gem will make it so that the <em>dependency</em> of the <em>database container</em> will be <em>auto(matically) injected</em> into the <code>Bix::Repos::User</code> class.</p>

<p>Let’s get started with this gem by adding the <code>dry-auto_inject</code> gem into our <code>Gemfile</code>:</p>

<pre><code class="language-ruby">gem 'dry-auto_inject'
</code></pre>

<p>Then we’ll run <code>bundle install</code> to install this gem.</p>

<p>Next up we’ll add two lines to <code>config/application.rb</code>. The first one is to require this gem:</p>

<pre><code class="language-ruby">require "dry/auto_inject"
</code></pre>

<p>Next, we’ll need to define a new constant in this file:</p>

<pre><code class="language-ruby">module Bix
  class Application &lt; Dry::System::Container
    ...
  end

  Import = Dry::AutoInject(Application)
end
</code></pre>

<p>This <code>Import</code> constant will allow us to import (or <em>inject</em>) anything registered with our application into other parts. Let’s see this in action now by adding this line to <code>lib/repos/user_repo.rb</code>:</p>

<pre><code class="language-ruby">module Bix
  module Repos
    class UserRepo &lt; ROM::Repository[:users]
      include Import["container"]

      ...
    end
  end
end
</code></pre>

<p>This line will use the <code>Import</code> constant to inject the <code>container</code> dependency into this class. This works by passing in a <code>container</code> keyword argument to <code>initialize</code> for this class.</p>

<p>Let’s try initializing a repository again in <code>bin/console</code>:</p>

<pre><code class="language-ruby">user_repo = Bix::Repos::UserRepo.new
# =&gt; #&lt;Bix::Repos::User struct_namespace=Bix auto_struct=true&gt;
user_repo.all.first.full_name
# =&gt; "Ryan Bigg"
</code></pre>

<p>Everything seems to be working correctly!</p>

<h3 id="summary">Summary</h3>

<p>In this first part of the ROM + Dry showcase, we’ve seen how to setup a small application that can talk to a database.</p>

<p>We have created files that allow us to bootstrap our application’s environment – <code>config/boot.rb</code> and <code>config/application.rb</code>. Along with this, we have created <code>system/boot</code>, a directory that contains system-level dependencies for our application’s boot process.</p>

<p>In the <code>lib</code> directory, we have setup three directories:</p>

<ul>
  <li><code>entities</code> - Classes that represent specific data types returned from our database.</li>
  <li><code>relations</code> - Classes that can contain custom methods for querying the database</li>
  <li><code>repos</code> - Classes that provide a place for defining a public API between relations and our application code</li>
</ul>

<p>This separation of concerns across our application will make it easier to work with in the long run. One more time: the setup cost is paid <em>once</em>, the maintenance cost is paid <em>forever</em>.</p>

<p>In the last part of this guide, we used the <code>dry-auto_inject</code> gem to inject the ROM container dependency into our <code>Repos::User</code> class. This will allow us to reduce the code that we need to write whenever we want to initialize the repository.</p>

<p>In the next part, we’re going to look at how to use more dry-rb gems to add validations to our application, and we’ll see another benefit of <code>dry-auto_inject</code> demonstrated.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Getting Started with Rails: Extended Edition</title>
   <link href="http://ryanbigg.com/2020/01/getting-started-with-rails-extended-edition"/>
   <updated>2020-01-19T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2020/01/getting-started-with-rails-extended-edition</id>
   <content type="html"><![CDATA[<p>This guide is an <em>extended edition</em> of the offical <a href="https://guides.rubyonrails.org/getting_started.html">Getting Started with Rails</a> guide.</p>

<p>This extended version has the following additions:</p>

<ul>
  <li>A re-worked introduction to routing, showing clearer matching between routes and controllers.</li>
  <li>Creates and uses a model right after building the first route.</li>
  <li>Examples of HTML output generated by Rails helpers such as <code>link_to</code>, <code>form_with</code> and <code>text_field</code>.</li>
  <li>Beef up explainations of routing helpers, especially <code>article_comment_path</code>.</li>
  <li>Beef up explainations in general.</li>
</ul>

<hr />

<p>This guide covers getting up and running with Ruby on Rails.</p>

<p>After reading this guide, you will know:</p>

<ul>
  <li>How to install Rails, create a new Rails application, and connect your
application to a database.</li>
  <li>The general layout of a Rails application.</li>
  <li>The basic principles of MVC (Model, View, Controller) and RESTful design.</li>
  <li>How to quickly generate the starting pieces of a Rails application.</li>
</ul>

<hr />

<h2 id="guide-assumptions">Guide Assumptions</h2>

<p>This guide is designed for beginners who want to get started with a Rails
application from scratch. It does not assume that you have any prior experience
with Rails.</p>

<p>Rails is a web application framework running on the Ruby programming language.
If you have no prior experience with Ruby, you will find a very steep learning
curve diving straight into Rails. There are several curated lists of online resources
for learning Ruby:</p>

<ul>
  <li><a href="https://www.ruby-lang.org/en/documentation/">Official Ruby Programming Language website</a></li>
  <li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md#ruby">List of Free Programming Books</a></li>
</ul>

<p>Be aware that some resources, while still excellent, cover versions of Ruby as old as
1.6, and commonly 1.8, and will not include some syntax that you will see in day-to-day
development with Rails.</p>

<h2 id="what-is-rails">What is Rails?</h2>

<p>Rails is a web application development framework written in the Ruby programming language.
It is designed to make programming web applications easier by making assumptions
about what every developer needs to get started. It allows you to write less
code while accomplishing more than many other languages and frameworks.
Experienced Rails developers also report that it makes web application
development more fun.</p>

<p>Rails is opinionated software. It makes the assumption that there is a “best”
way to do things, and it’s designed to encourage that way - and in some cases to
discourage alternatives. If you learn “The Rails Way” you’ll probably discover a
tremendous increase in productivity. If you persist in bringing old habits from
other languages to your Rails development, and trying to use patterns you
learned elsewhere, you may have a less happy experience.</p>

<p>The Rails philosophy includes two major guiding principles:</p>

<ul>
  <li><strong>Don’t Repeat Yourself:</strong> DRY is a principle of software development which
states that “Every piece of knowledge must have a single, unambiguous, authoritative
representation within a system”. By not writing the same information over and over
again, our code is more maintainable, more extensible, and less buggy.</li>
  <li><strong>Convention Over Configuration:</strong> Rails has opinions about the best way to do many
things in a web application, and defaults to this set of conventions, rather than
require that you specify minutiae through endless configuration files.</li>
</ul>

<h2 id="creating-a-new-rails-project">Creating a New Rails Project</h2>
<p>The best way to read this guide is to follow it step by step. All steps are
essential to run this example application and no additional code or steps are
needed.</p>

<p>By following along with this guide, you’ll create a Rails project called
<code>blog</code>, a (very) simple weblog. Before you can start building the application,
you need to make sure that you have Rails itself installed.</p>

<p>TIP: The examples below use <code>$</code> to represent your terminal prompt in a UNIX-like OS,
though it may have been customized to appear differently. If you are using Windows,
your prompt will look something like <code>c:\source_code&gt;</code></p>

<h3 id="installing-rails">Installing Rails</h3>

<p>Before you install Rails, you should check to make sure that your system has the
proper prerequisites installed. These include Ruby and SQLite3.</p>

<p>Open up a command line prompt. On macOS open Terminal.app, on Windows choose
“Run” from your Start menu and type ‘cmd.exe’. Any commands prefaced with a
dollar sign <code>$</code> should be run in the command line. Verify that you have a
current version of Ruby installed:</p>

<pre><code class="language-bash">$ ruby -v
ruby 2.7.0
</code></pre>

<p>Rails requires Ruby version 2.5.0 or later. If the version number returned is
less than that number (such as 2.3.7, or 1.8.7), you’ll need to install a fresh copy of Ruby.</p>

<p>TIP: To quickly install Ruby and Ruby on Rails on your system in Windows, you can use
<a href="http://railsinstaller.org">Rails Installer</a>. For more installation methods for most
Operating Systems take a look at <a href="https://www.ruby-lang.org/en/documentation/installation/">ruby-lang.org</a>.</p>

<p>If you are working on Windows, you should also install the
<a href="https://rubyinstaller.org/downloads/">Ruby Installer Development Kit</a>.</p>

<p>You will also need an installation of the SQLite3 database.
Many popular UNIX-like OSes ship with an acceptable version of SQLite3.
On Windows, if you installed Rails through Rails Installer, you
already have SQLite installed. Others can find installation instructions
at the <a href="https://www.sqlite.org">SQLite3 website</a>.
Verify that it is correctly installed and in your PATH:</p>

<pre><code class="language-bash">$ sqlite3 --version
</code></pre>

<p>The program should report its version.</p>

<p>To install Rails, use the <code>gem install</code> command provided by RubyGems:</p>

<pre><code class="language-bash">$ gem install rails
</code></pre>

<p>To verify that you have everything installed correctly, you should be able to
run the following:</p>

<pre><code class="language-bash">$ rails --version
</code></pre>

<p>If it says something like “Rails 6.0.0”, you are ready to continue.</p>

<h3 id="creating-the-blog-application">Creating the Blog Application</h3>

<p>Rails comes with a number of scripts called generators that are designed to make
your development life easier by creating everything that’s necessary to start
working on a particular task. One of these is the new application generator,
which will provide you with the foundation of a fresh Rails application so that
you don’t have to write it yourself.</p>

<p>To use this generator, open a terminal, navigate to a directory where you have
rights to create files, and type:</p>

<pre><code class="language-bash">$ rails new blog
</code></pre>

<p>This will create a Rails application called Blog in a <code>blog</code> directory and
install the gem dependencies that are already mentioned in <code>Gemfile</code> using
<code>bundle install</code>.</p>

<p>NOTE: If you’re using Windows Subsystem for Linux then there are currently some
limitations on file system notifications that mean you should disable the <code>spring</code>
and <code>listen</code> gems which you can do by running <code>rails new blog --skip-spring --skip-listen</code>.</p>

<p>TIP: You can see all of the command line options that the Rails application
builder accepts by running <code>rails new -h</code>.</p>

<p>After you create the blog application, switch to its folder:</p>

<pre><code class="language-bash">$ cd blog
</code></pre>

<p>The <code>blog</code> directory has a number of auto-generated files and folders that make
up the structure of a Rails application. Most of the work in this tutorial will
happen in the <code>app</code> folder, but here’s a basic rundown on the function of each
of the files and folders that Rails created by default:</p>

<table>
  <thead>
    <tr>
      <th>File/Folder</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>app/</td>
      <td>Contains the controllers, models, views, helpers, mailers, channels, jobs, and assets for your application. You’ll focus on this folder for the remainder of this guide.</td>
    </tr>
    <tr>
      <td>bin/</td>
      <td>Contains the rails script that starts your app and can contain other scripts you use to setup, update, deploy, or run your application.</td>
    </tr>
    <tr>
      <td>config/</td>
      <td>Configure your application’s routes, database, and more. This is covered in more detail in <a href="configuring.html">Configuring Rails Applications</a>.</td>
    </tr>
    <tr>
      <td>config.ru</td>
      <td>Rack configuration for Rack based servers used to start the application. For more information about Rack, see the <a href="https://rack.github.io/">Rack website</a>.</td>
    </tr>
    <tr>
      <td>db/</td>
      <td>Contains your current database schema, as well as the database migrations.</td>
    </tr>
    <tr>
      <td>Gemfile<br />Gemfile.lock</td>
      <td>These files allow you to specify what gem dependencies are needed for your Rails application. These files are used by the Bundler gem. For more information about Bundler, see the <a href="https://bundler.io">Bundler website</a>.</td>
    </tr>
    <tr>
      <td>lib/</td>
      <td>Extended modules for your application.</td>
    </tr>
    <tr>
      <td>log/</td>
      <td>Application log files.</td>
    </tr>
    <tr>
      <td>package.json</td>
      <td>This file allows you to specify what npm dependencies are needed for your Rails application. This file is used by Yarn. For more information about Yarn, see the <a href="https://yarnpkg.com/lang/en/">Yarn website</a>.</td>
    </tr>
    <tr>
      <td>public/</td>
      <td>The only folder seen by the world as-is. Contains static files and compiled assets.</td>
    </tr>
    <tr>
      <td>Rakefile</td>
      <td>This file locates and loads tasks that can be run from the command line. The task definitions are defined throughout the components of Rails. Rather than changing <code>Rakefile</code>, you should add your own tasks by adding files to the <code>lib/tasks</code> directory of your application.</td>
    </tr>
    <tr>
      <td>README.md</td>
      <td>This is a brief instruction manual for your application. You should edit this file to tell others what your application does, how to set it up, and so on.</td>
    </tr>
    <tr>
      <td>storage/</td>
      <td>Active Storage files for Disk Service. This is covered in <a href="active_storage_overview.html">Active Storage Overview</a>.</td>
    </tr>
    <tr>
      <td>test/</td>
      <td>Unit tests, fixtures, and other test apparatus. These are covered in <a href="testing.html">Testing Rails Applications</a>.</td>
    </tr>
    <tr>
      <td>tmp/</td>
      <td>Temporary files (like cache and pid files).</td>
    </tr>
    <tr>
      <td>vendor/</td>
      <td>A place for all third-party code. In a typical Rails application this includes vendored gems.</td>
    </tr>
    <tr>
      <td>.gitignore</td>
      <td>This file tells git which files (or patterns) it should ignore. See <a href="https://help.github.com/articles/ignoring-files">GitHub - Ignoring files</a> for more info about ignoring files.</td>
    </tr>
    <tr>
      <td>.ruby-version</td>
      <td>This file contains the default Ruby version.</td>
    </tr>
  </tbody>
</table>

<h2 id="hello-rails">Hello, Rails!</h2>

<p>To begin with, let’s get some text up on screen quickly. To do this, you need to
get your Rails application server running.</p>

<h3 id="starting-up-the-web-server">Starting up the Web Server</h3>

<p>You actually have a functional Rails application already. To see it, you need to
start a web server on your development machine. You can do this by running the
following in the <code>blog</code> directory:</p>

<pre><code class="language-bash">$ bin/rails server
</code></pre>

<p>TIP: If you are using Windows, you have to pass the scripts under the <code>bin</code>
folder directly to the Ruby interpreter e.g. <code>ruby bin\rails server</code>.</p>

<p>TIP: JavaScript asset compression requires you
have a JavaScript runtime available on your system, in the absence
of a runtime you will see an <code>execjs</code> error during asset compression.
Usually macOS and Windows come with a JavaScript runtime installed.
<code>therubyrhino</code> is the recommended runtime for JRuby users and is added by
default to the <code>Gemfile</code> in apps generated under JRuby. You can investigate
all the supported runtimes at <a href="https://github.com/rails/execjs#readme">ExecJS</a>.</p>

<p>This will fire up Puma, a web server distributed with Rails by default. To see
your application in action, open a browser window and navigate to
<a href="http://localhost:3000">http://localhost:3000</a>. You should see the Rails default information page:</p>

<p><img src="/images/getting_started/rails_welcome.png" alt="Yay! You're on Rails! screenshot" /></p>

<p>TIP: To stop the web server, hit Ctrl+C in the terminal window where it’s
running. To verify the server has stopped you should see your command prompt
cursor again. For most UNIX-like systems including macOS this will be a
dollar sign <code>$</code>. In development mode, Rails does not generally require you to
restart the server; changes you make in files will be automatically picked up by
the server.</p>

<p>The “Yay! You’re on Rails!” page is the <em>smoke test</em> for a new Rails
application: it makes sure that you have your software configured correctly
enough to serve a page.</p>

<h3 id="say-hello-rails">Say “Hello”, Rails</h3>

<p>To get Rails saying “Hello”, you need to create at minimum a <em>route</em>, a <em>controller</em> and a <em>view</em>.</p>

<p>A controller’s purpose is to receive specific requests for the application.
<em>Routing</em> decides which controller receives which requests. Often, there is more
than one route to each controller, and different routes can be served by
different <em>actions</em>. Each action’s purpose is to collect information to provide
it to a view.</p>

<p>A view’s purpose is to display this information in a human readable format. An
important distinction to make is that the <em>controller</em>, not the view,
is where information is collected. The view should just display that information.
By default, view templates are written in a language called eRuby (Embedded
Ruby) which is processed by the request cycle in Rails before being sent to the
user.</p>

<p>When we make a request to our Rails applications, we do so by making a request to a particular <em>route</em>. So to start off, we’ll start with a route. Let’s create one now in <code>config/routes.rb</code>:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  get "/articles", to: "articles#index"

  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html
end
</code></pre>

<p>This is your application’s <em>routing file</em> which holds entries in a special
<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL (domain-specific language)</a> that tells Rails how to connect incoming requests to
controllers and actions.</p>

<p>The line that we have just added says that we are going to match a <code>GET /welcome</code> request to <code>welcome#index</code>. This string passed as the <code>to</code> option represents the <em>controller</em> and <em>action</em> that will be responsible for handling this request.</p>

<p>Controllers are classes that group together common methods for handling a particular <em>resource</em>. The methods inside controllers are given the name “actions”, as they <em>act upon</em> requests as they come in.</p>

<p>To create a new controller, you will need to run the “controller” generator and
tell it you want a controller called “articles” with an action called “index”,
just like this:</p>

<pre><code class="language-bash">$ bin/rails generate controller articles index
</code></pre>

<p>Rails will create several files and a route for you.</p>

<pre><code class="language-bash">create  app/controllers/articles_controller.rb
  route  get 'articles/index'
invoke  erb
create    app/views/articles
create    app/views/articles/index.html.erb
invoke  test_unit
create    test/controllers/articles_controller_test.rb
invoke  helper
create    app/helpers/articles_helper.rb
invoke    test_unit
invoke  assets
invoke    scss
create      app/assets/stylesheets/articles.scss
</code></pre>

<p>Most important of these are is of course the controller, located at
<code>app/controllers/articles_controller.rb</code>.</p>

<p>Let’s look at that controller now:</p>

<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
  def index
  end
end
</code></pre>

<p>This controller defines a single action, or “method” in common Ruby terms, called <code>index</code>. This action is where we would define any logic that we would want to happen when a request comes in to this action. Right at this moment, we don’t want this action to do anything, and so we’ll keep it blank for now.</p>

<p>When an action is left blank like this, Rails will default to rendering a view that matches the name of the controller, and the name of the action. That view is going to be <code>app/views/articles/index.html.erb</code>.</p>

<p>Open the <code>app/views/articles/index.html.erb</code> file in your text editor. Delete all
of the existing code in the file, and replace it with the following single line
of code:</p>

<pre><code class="language-html">&lt;h1&gt;Hello, Rails!&lt;/h1&gt;
</code></pre>

<p>If we go back to our browser and make a request to <a href="http://localhost:3000/articles">http://localhost:3000/articles</a>, we’ll see our text appear on the page.</p>

<h3 id="setting-the-application-home-page">Setting the Application Home Page</h3>

<p>Now that we have made the route, controller, action and view, let’s make a small change to our routes. In this application, we’re going to change it so that our message appears at <a href="http://localhost:3000/">http://localhost:3000/</a> and not just <a href="http://localhost:3000/articles">http://localhost:3000/articles</a>. At the moment, at <a href="http://localhost:3000">http://localhost:3000</a> it still says “Yay! You’re on Rails!”.</p>

<p>To change this, we need to tell our routes file where the <em>root path</em> of our application is.</p>

<p>Open the file <code>config/routes.rb</code> in your editor.</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  get "/articles", to: "articles#index"
  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html
end
</code></pre>

<p>Underneath the line that is there, add this line:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root to: "articles#index"
end
</code></pre>

<p>A slightly shorter way of writing the same thing is:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  get "/articles", to: "articles#index"
  root "articles#index"
end
</code></pre>

<p>This <code>root</code> method defines a <em>root path</em> for our application. The <code>root</code> method tells Rails to map requests to the root of the application to the <code>ArticlesController</code> <code>index</code> action.</p>

<p>Launch the web server again if you stopped it to generate the controller (<code>rails
server</code>) and navigate to <a href="http://localhost:3000">http://localhost:3000</a> in your browser. You’ll see the
“Hello, Rails!” message you put into <code>app/views/articles/index.html.erb</code>,
indicating that this new route is indeed going to <code>ArticleController</code>’s <code>index</code>
action and is rendering the view correctly.</p>

<p>TIP: For more information about routing, refer to <a href="routing.html">Rails Routing from the Outside In</a>.</p>

<h2 id="creating-a-model">Creating a model</h2>

<p>So far, we have seen routes, controllers, actions and views within our Rails application. All of these are conventional parts of Rails applications and it is done this way to follow the MVC pattern. The MVC pattern is an application design pattern which makes it easy to separate the different responsibilities of applications into easy to reason about pieces.</p>

<p>So with “MVC”, you might guess that the “V” stands for “View” and the “C” stands for controller, but you might have trouble guessing what the “M” stands for. This next section is all about that “M” part, the <em>model</em>.</p>

<p>A model is a class that is used to represent data in our application. In a plain-Ruby application, you might have a class defined like this:</p>

<pre><code class="language-ruby">class Article
  attr_reader :title, :body

  def initialize(title:, body:)
    @title = title
    @body = body
  end
end
</code></pre>

<p>Models in a Rails application are designed for this purpose too: to represent particular data.</p>

<p>Models have another purpose in a Rails application too though. They’re also used to interact with the application’s database. In this section, we’re going to use a model to put data into our database and to pull that data back out.</p>

<p>To start with, we’re going to need to generate a model. We can do that with the following command:</p>

<pre><code class="language-bash">$ bin/rails g model article title:string body:text
</code></pre>

<p>NOTE: The model name here is <em>singular</em>, because model classes are classes that are used to represent single instances. To help remember this rule, in a Ruby application to start building a new object, you would define the class as <code>Article</code>, and then do <code>Article.new</code>, not <code>Articles</code> and <code>Articles.new</code>.</p>

<p>When this command runs, it will generate the following files:</p>

<pre><code class="language-bash">invoke  active_record
create    db/migrate/[timestamp]_create_articles.rb
create    app/models/article.rb
invoke    test_unit
create      test/models/article_test.rb
create      test/fixtures/articles.yml
</code></pre>

<p>The two files we’ll focus on here are the <em>migration</em> (the file at <code>db/migrate</code>) and the <em>model</em>.</p>

<p>A migration is used to alter the structure of our database, and it is written in Ruby. Let’s look at this file now, <code>db/migrate/[timestamp]_create_articles.rb</code>.</p>

<pre><code class="language-ruby">class CreateArticles &lt; ActiveRecord::Migration[6.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :body

      t.timestamps
    end
  end
end
</code></pre>

<p>This file contains Ruby code to create a table within our application’s database. Migrations are written in Ruby so that they can be database-agnostic – regardless of what database you use with Rails, you’ll always write migrations in Ruby.</p>

<p>Inside this migration file, there’s a <code>create_table</code> method that defines how the <code>articles</code> table should be constructed. This method will create a table in our database that contains an <code>id</code> auto-incrementing primary key. That means that the first record in our table will have an <code>id</code> of 1, and the next <code>id</code> of 2, and so on.  Rails assumes by default this is the behaviour we want, and so it does this for us.</p>

<p>Inside the block for <code>create_table</code>, we have two fields, <code>title</code> and <code>body</code>. These were added to the migration automatically because we put them at the end of the <code>rails g model</code> call:</p>

<pre><code class="language-bash">$ bin/rails g model article title:string body:text
</code></pre>

<p>On the last line of the block is <code>t.timestamps</code>. This method defines two additional fields in our table, called <code>created_at</code> and <code>updated_at</code>. When we create or update model objects, these fields will be set respectively.</p>

<p>The structure of our table will look like this:</p>

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>title</th>
      <th>body</th>
      <th>created_at</th>
      <th>updated_at</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>To create this table in our application’s database, we can run this command:</p>

<pre><code class="language-bash">rails db:migrate
</code></pre>

<p>This command will show us output indicating that the table was created:</p>

<pre><code class="language-plaintext">== 20200118233119 CreateArticles: migrating ===================================
-- create_table(:articles)
   -&gt; 0.0018s
== 20200118233119 CreateArticles: migrated (0.0018s) ==========================
</code></pre>

<p>Now that we have a table in our application’s database, we can use the model to interact with this table.</p>

<p>To use the model, we’ll use a feature of Rails called the <em>console</em>. The console allows us write code like we might in <code>irb</code>, but the code of our application is available there too. Let’s launch the console with this command:</p>

<pre><code class="language-bash">rails console
</code></pre>

<p>Or, a shorter version:</p>

<pre><code class="language-bash">rails c
</code></pre>

<p>When we launch this, we should see an irb prompt:</p>

<pre><code class="language-plaintext">Loading development environment (Rails 6.0.2.1)
irb(main):001:0&gt;
</code></pre>

<p>In this prompt, we can use our model to initialize a new <code>Article</code> object:</p>

<pre><code class="language-ruby">irb(main):001:0&gt; article = Article.new(title: "Hello Rails", body: "I am on Rails!")
</code></pre>

<p>When we use <code>Article.new</code>, it will initialze a new <code>Article</code> object in the console. This object is not saved to the database at all, it’s just available in the console so far. To save the object to the database, we need to call <code>save</code>:</p>

<pre><code class="language-ruby">irb(main):002:0&gt; article.save
</code></pre>

<p>This command will show us the following output:</p>

<pre><code class="language-plaintext">(0.1ms)  begin transaction
Article Create (0.4ms)  INSERT INTO "articles" ("title", "body", "created_at", "updated_at") VALUES (?, ?, ?, ?)  [["title", "Hello Rails"], ["body", "I am on Rails!"], ["created_at", "2020-01-18 23:47:30.734416"], ["updated_at", "2020-01-18 23:47:30.734416"]]
(0.9ms)  commit transaction
=&gt; true
</code></pre>

<p>This output shows an <code>INSERT INTO "articles"...</code> database query. This means that our article has been successfully inserted into our table.</p>

<p>If we take a look at our <code>article</code> object again, an interesting thing has happened:</p>

<pre><code class="language-ruby">irb(main):003:0&gt; article
=&gt; #&lt;Article id: 1, title: "Hello Rails", body: "I am on Rails!", created_at: "2020-01-18 23:47:30", updated_at: "2020-01-18 23:47:30"&gt;
</code></pre>

<p>Our object now has the <code>id</code>, <code>created_at</code> and <code>updated_at</code> fields set. All of this happened automatically for us when we saved this article.</p>

<p>If we wanted to retrieve this article back from the database later on, we can do that with <code>find</code>, and pass that <code>id</code> as an argument:</p>

<pre><code class="language-ruby">irb(main):004:0&gt; article = Article.find(1)
=&gt; #&lt;Article id: 1, title: "Hello Rails", body: "I am on Rails!", created_at: "2020-01-18 23:47:30", updated_at: "2020-01-18 23:47:30"&gt;
</code></pre>

<p>A shorter way to add articles into our database is to use <code>Article.create</code>, like this:</p>

<pre><code class="language-ruby">irb(main):005:0&gt; Article.create(title: "Post #2", body: "Still riding the Rails!")
</code></pre>

<p>This way, we don’t need to call <code>new</code> and then <code>save</code>.</p>

<p>Lastly, models provide a method to find all of their data:</p>

<pre><code class="language-ruby">irb(main):006:0&gt; articles = Article.all
 #&lt;ActiveRecord::Relation [
   #&lt;Article id: 1, title: "Hello Rails", body: "I am on Rails!", created_at: "2020-01-18 23:47:30", updated_at: "2020-01-18 23:47:30"&gt;,
   #&lt;Article id: 2, title: "Post #2", body: "Still riding the Rails!", created_at: "2020-01-18 23:53:45", updated_at: "2020-01-18 23:53:45"&gt;]&gt;
</code></pre>

<p>This method returns an <code>ActiveRecord::Relation</code> object, which you can think of as a super-powered array. This array contains both of the topics that we have created so far.</p>

<p>As you can see, models are very helpful classes for interacting with databases within Rails applications. Models are the final piece of the “MVC” puzzle. Let’s look at how we can go about connecting all these pieces together into a cohesive whole.</p>

<h2 id="getting-up-and-running">Getting Up and Running</h2>

<p>Now that you’ve seen how to create a route, a controller, an action, a view and a model, let’s connect these pieces together.</p>

<p>Let’s go back to <code>app/controllers/articles_controller.rb</code> now. We’re going to change the <code>index</code> action here to use our model.</p>

<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end
end
</code></pre>

<p>Controller actions are where we assemble all the data that will later be displayed in the <em>view</em>. In this <code>index</code> action, we’re calling <code>Article.all</code> which will make a query to our database and retrieve all of the articles, storing them in an instance variable: <code>@articles</code>.</p>

<p>We’re using an instance variable here for a very good reason: instance variables are automatically shared from controllers into views. So to use this <code>@articles</code> variable in our view to show all the articles, we can write this code in <code>app/views/articles/index.html.erb</code>:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;&lt;%= article.title %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>We’ve now changed this file from using just HTML to using HTML and <em>ERB</em>. ERB is a language that we can use to run Ruby code.</p>

<p>There’s two types of ERB tag beginnings that we’re using here: <code>&lt;%</code> and <code>&lt;%=</code>. The <code>&lt;%</code> tag means to evalulate some Ruby code, while the <code>&lt;%=</code> means to evalulate that code, and then to output the return value from that code.</p>

<p>In this view, we do not want the output of <code>articles.each</code> to show, and so we use a <code>&lt;%</code>. But we do want each of the articles’ titles to appear, and so we use <code>&lt;%=</code>.</p>

<p>When we start an ERB tag with either <code>&lt;%</code> or <code>&lt;%=</code>, it can help to think “I am now writing Ruby, not HTML”. Anything you could write in a regular Ruby program, can go inside these ERB tags.</p>

<p>When the view is used by Rails, the embedded Ruby will be evalulated, and the page will show our list of articles. Let’s go to <a href="http://localhost:3000">http://localhost:3000</a> now and see the list of articles:</p>

<p><img src="/images/getting_started/article_list.png" alt="List of articles" /></p>

<p>If we look at the source of the page in our browser &lt;view-source:http://localhost:3000/&gt;, we’ll see this part:</p>

<pre><code class="language-html">    &lt;h1&gt;Articles&lt;/h1&gt;

&lt;ul&gt;
    &lt;li&gt;Hello Rails&lt;/li&gt;
    &lt;li&gt;Post #2&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>This is the HTML that has been output from our view in our Rails application.</p>

<p>Here’s what’s happened to get to this point:</p>

<ol>
  <li>Our browser makes a request: <code>GET http://localhost:3000</code></li>
  <li>The Rails application receives this request</li>
  <li>The router sees that the <code>root</code> route is configured to route to the <code>ArticlesController</code>’s <code>index</code> action</li>
  <li>The <code>index</code> action uses the <code>Article</code> model to find all the articles</li>
  <li>Rails automatically renders the <code>app/views/articles/index.html.erb</code> view</li>
  <li>The view contains ERB (Embedded Ruby). This code is evalulated, and plain HTML is returned.</li>
  <li>The server sends a response containing that plain HTML back to the browser.</li>
</ol>

<p>Here’s a flowchart of the above steps:</p>

<p><img src="/images/getting_started/application_flowchart.png" alt="Application flowchart" /></p>

<p>We’ve now successfully connected all the different parts of our Rails application together: the router, the controller, the action, the model and the view. With this connection, we have finished the first action of our application.</p>

<p>Let’s move on to the second action!</p>

<h3 id="viewing-an-article">Viewing an Article</h3>

<p>For our second action, we want our application to show us the details about an article, specifically the article’s title and body:</p>

<p><img src="/images/getting_started/single_article_view.png" alt="Single Article View" /></p>

<p>We’ll start in the same place we started with the <code>index</code> action, which was in <code>config/routes.rb</code>. We’ll add a new route for this page. Let’s change our routes file now to this:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"
  get "/articles", to: "articles#index"
  get "/articles/:id", to: "articles#show"
end
</code></pre>

<p>This route is another <code>get</code> route, but it has something different in it: <code>:id</code>. This syntax in Rails routing is called a <em>parameter</em>, and it will be available in the <code>show</code> action of <code>ArticlesController</code> when a request is made. A request to this action will use a route such as <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a> or <a href="http://localhost:3000/articles/2">http://localhost:3000/articles/2</a>.</p>

<p>This time, we’re still routing to the <code>ArticlesController</code>, but we’re going to the <code>show</code> action of that controller instead of the <code>index</code> action.</p>

<p>Let’s look at how to add that <code>show</code> action to the <code>ArticlesController</code>. We’ll open <code>app/controllers/articles_controller.rb</code> and add it in, under the <code>index</code> action:</p>

<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end
end
</code></pre>

<p>When a request is made to this <code>show</code> action, it will be made to a URL such as <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a>. Rails sees that the last part of that route is a dynamic parameter, and makes that parameter available for us in our controller through the method <code>params</code>. We use <code>params[:id]</code> to access that parameter, because back in the routes file we called the parameter <code>:id</code>. If we used a name like <code>:article_id</code> in the routes file, then we would need to use <code>params[:article_id]</code> here too.</p>

<p>The <code>show</code> action finds a particular article with that ID. Once it has that, it needs to then display that article’s information, which will do by attempting to use a view at <code>app/views/articles/show.html.erb</code>. Let’s create that file now and add this content:</p>

<pre><code class="language-erb">&lt;h1&gt;&lt;%= @article.title %&gt;&lt;/h1&gt;

&lt;%= @article.body %&gt;
</code></pre>

<p>Now when we go to <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a> we will see the article:</p>

<p><img src="/images/getting_started/single_article_view.png" alt="Single Article View" /></p>

<p>Excellent! We now have our second action working in our controller. But in order to navigate to it, we have to manually type in <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a>. That seems a bit silly. Let’s change our application a little, so that we can navigate to an article by clicking a link from the list of articles.</p>

<p>To add the link to an article, we need to change <code>app/views/articles/index.html.erb</code>, which currently looks like this:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;&lt;%= article.title %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This code will render an <code>li</code> element for each of the articles, and that element contains the title of the article. But we can’t click on the title to go to an article yet! To make that happen, we need to use an <code>a</code> tag:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;
      &lt;a href='/articles/&lt;%= article.id %&gt;'&gt;
        &lt;%= article.title %&gt;
      &lt;/a&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This <code>a</code> tag will provide us with a link to the specific article. If we go back to <a href="http://localhost:3000/">http://localhost:3000/</a>, we’ll see that we can now click on the articles:</p>

<p><img src="/images/getting_started/articles_list_with_links.png" alt="Articles list with links" /></p>

<p>Clicking either of these links will take us to the relevant article:</p>

<p><img src="/images/getting_started/single_article_view.png" alt="Single Article View" /></p>

<p>Now we have been able to link together the <code>index</code> and <code>show</code> pages in our application using a simple <code>a</code> tag. What could be simpler than that?</p>

<p>Well, Rails has a method called <code>link_to</code> that can make that linking a little simpler. Let’s use this in <code>app/views/articles/index.html.erb</code>:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;
      &lt;%= link_to article.title, "/articles/#{article.id}" %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>There we go, that is now a little bit cleaner. Rails has given us a way to shorten this code a little. But what you don’t know yet is that this line can be made even simpler.</p>

<p>Rails has a feature called <em>routing helpers</em>. These are methods that can be used to generate route paths like <code>"/articles/#{article.id}"</code> programatically. We’ll use one of these to generate the route for our article. To set this up, let’s go back to <code>config/routes.rb</code> and change this line:</p>

<pre><code class="language-ruby">get "/articles/:id", to: "articles#show"
</code></pre>

<p>To this:</p>

<pre><code class="language-ruby">get "/articles/:id", to: "articles#show", as: :article
</code></pre>

<p>The <code>:as</code> option here tells Rails that we want routing helpers for this article route to be available in our application. Rails will then let us use this helper to build that route.</p>

<p>Let’s look at how we can use that in <code>app/views/articles/index.html.erb</code> now, by changing the end of the <code>link_to</code> call to this:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;
      &lt;%= link_to article.title, article_path(article) %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>The <code>link_to</code> now assembles its path using the <code>article_path</code> helper. This will still generate the same <code>/articles/:id</code> route we used earlier, but now it happens programatically instead. Now there is not so much switching happening between HTML and Ruby in this code. We enter Ruby, generate a link, and exit Ruby. The code still does the same thing: it links an article’s title to the <code>show</code> page for that article.</p>

<p>TIP: To learn more about routing, read the <a href="https://guides.rubyonrails.org/routing.html">Rails Routing from the Outside In Guide</a>.</p>

<p>We now have an <code>index</code> action that lists the articles, and a <code>show</code> action that shows the title and body for a specific article. Before we move on, we’ll make one more little change: we’ll add a “Back” link in <code>app/views/articles/show.html.erb</code>:</p>

<pre><code class="language-erb">&lt;h1&gt;&lt;%= @article.title %&gt;&lt;/h1&gt;

&lt;%= @article.body %&gt;

&lt;div&gt;
  &lt;%= link_to "Back", "/" %&gt;
&lt;/div&gt;

</code></pre>

<p>This will allow us to navigate back to the list of articles easily.</p>

<p>With that small change done, let’s now look at how we can create new articles within this application.</p>

<h3 id="creating-new-articles">Creating new articles</h3>

<p>To have a place to create new articles in our application, we’re going to need create a new route, action and view. On that view, we’re going to have this form:</p>

<p>IMAGE GOES HERE</p>

<p>Let’s start with the route:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"
  get "/articles", to: "articles#index"
  get "/articles/new", to: "articles#new", as: :new_article
  get "/articles/:id", to: "articles#show", as: :article
end
</code></pre>

<p>This place to create new articles will be <code>/articles/new</code>, and the route for this has <em>very</em> intentionally been placed above the route for the <code>show</code> action. The reason for this is because routes in a Rails application are matched top-to-bottom. If we had <code>/articles/:id</code> first, that route would match <code>/articles/new</code>, and so if we went to <code>/articles/new</code>, the <code>show</code> action would serve that request, not the <code>new</code> action. And so for this reason, we put the <code>new</code> route <em>above</em> the <code>show</code> action.</p>

<p>This <code>/articles/new</code> route will send the request to the <code>new</code> action within the <code>ArticlesController</code>, which we’ll see in a minute. We’ve added the <code>:as</code> option here, as we will be using the <code>new_article_path</code> helper in a little while to provide a way to navigate to this form.</p>

<p>If we were to attempt to go to this route now, would see an error for the first time:</p>

<p><img src="/images/getting_started/unknown_action_new_for_articles.png" alt="Unknown action new for ArticlesController!" /></p>

<p>This error indicates that Rails cannot find the <code>new</code> action inside the
<code>ArticlesController</code>. No worries, we will need to define this action.</p>

<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def new
  end
end
</code></pre>

<p>We can put the <code>new</code> action under <code>show</code> in the controller, because the order of methods in classes doesn’t matter in Ruby.</p>

<p>With the <code>new</code> method defined in <code>ArticlesController</code>, if you refresh
<a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> you’ll see another error:</p>

<p><img src="/images/getting_started/template_is_missing_articles_new.png" alt="Template is missing for articles/new" /></p>

<p>You’re getting this error now because Rails expects empty actions like this one to have views associated with them to display their information. With no view available, Rails will raise an exception.</p>

<p>Let’s look at the full error message again:</p>

<blockquote>
  <p>ArticlesController#new is missing a template for request formats: text/html</p>
</blockquote>

<blockquote>
  <p>NOTE!
Unless told otherwise, Rails expects an action to render a template with the same name, contained in a folder named after its controller. If this controller is an API responding with 204 (No Content), which does not require a template, then this error will occur when trying to access it via browser, since we expect an HTML template to be rendered for such requests. If that’s the case, carry on.</p>
</blockquote>

<p>The message identifies which template is missing. In this case, it’s the
<code>articles/new</code> template. Next the message contains <code>request.formats</code> which specifies the format of template to be served in response. It is set to <code>text/html</code> as we requested this page via browser, so Rails is looking for an HTML template.</p>

<p>The simplest template that would work in this case would be one located at <code>app/views/articles/new.html.erb</code>. The extension of this file name is important: the first extension is the <em>format</em> of the template, and the second extension is the <em>handler</em> that will be used to render the template.  Think of it reading right-to-left: “I’m going to <em>execute ERB</em> to <em>generate HTML</em> for the <em><code>new</code> action</em>”.</p>

<p>So let’s now go ahead now and create a new file at <code>app/views/articles/new.html.erb</code> and write this content in it:</p>

<pre><code class="language-html">&lt;h1&gt;New Article&lt;/h1&gt;
</code></pre>

<p>To create a form within this template, you will use a <em>form
builder</em>. The primary form builder for Rails is provided by a helper
method called <code>form_with</code>. To use this method, add this code into
<code>app/views/articles/new.html.erb</code>:</p>

<pre><code class="language-html">&lt;h1&gt;New Article&lt;/h1&gt;

&lt;form action="/articles" method="post"&gt;
  &lt;p&gt;
    &lt;label for="title"&gt;Title&lt;/label&gt;&lt;br&gt;
    &lt;input type="text" id="title" name="title" /&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;label for="text"&gt;Text&lt;/label&gt;&lt;br&gt;
    &lt;textarea name="text" id="text"&gt;&lt;/textarea&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;input type="submit" value="Save Article" /&gt;
  &lt;/p&gt;
&lt;/form&gt;
</code></pre>

<p>This is an awful lot of typing for building a form. Fortunately, Rails provides helpers for us to simplify matters:</p>

<pre><code class="language-erb">&lt;h1&gt;New Article&lt;/h1&gt;

&lt;%= form_with scope: :article, local: true do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>

<p>The <code>form_with</code> helper method allows us to build a form. The first line of this provides us a block argument called <code>form</code>, and then throughout the form we use that to build labels and text inputs for our field.</p>

<p>NOTE: By default <code>form_with</code> submits forms using Ajax thereby skipping full page redirects. To make this guide easier to get into we’ve disabled that with <code>local: true</code> for now.</p>

<p>This ERB code that uses <code>form_with</code> will output a HTML form that looks very similar to the one we hand-rolled, but there are some key differences. Here’s what the <code>form_with</code> outputs:</p>

<pre><code class="language-html">&lt;form action="/articles/new" accept-charset="UTF-8" method="post"&gt;&lt;input type="hidden" name="authenticity_token" value="DIwa34..." /&gt;
  &lt;p&gt;
    &lt;label for="article_title"&gt;Title&lt;/label&gt;&lt;br&gt;
    &lt;input type="text" name="article[title]" id="article_title" /&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;label for="article_text"&gt;Text&lt;/label&gt;&lt;br&gt;
    &lt;textarea name="article[text]" id="article_text"&gt;
&lt;/textarea&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;input type="submit" name="commit" value="Save Article" data-disable-with="Save Article" /&gt;
  &lt;/p&gt;
&lt;/form&gt;
</code></pre>

<p>The first key difference is that there is a hidden field called <code>authenticity_token</code> at the top. This is a security feature of Rails and it prevents outside people from submitting your forms maliciously using a technique called Cross Site Request Forgery. <a href="https://stackoverflow.com/a/1571900/15245">This Stack Overflow answer explains further</a>.</p>

<p>The labels and fields are mostly the way they were, with a key difference: the <code>name</code> fields have an <code>article[]</code> wrapping around their values. This wrapping comes from the <code>scope</code> argument that we have passed to <code>form_with</code>. This wrapping groups all the fields of the form into one hash once they’re submitted, and that will make it easy to process once they reach our application.</p>

<p>Speaking of, let’s try and fill out this form now with a title and a body for our 3rd article:</p>

<p><img src="/images/getting_started/article_the_third.png" alt="The third article" /></p>

<p>There’s one problem with this form though. If you inspect the HTML that is generated, by viewing the source of the page, you will see that the <code>action</code> attribute for the form is pointing at <code>/articles/new</code>. This is a problem because this route goes to the very page that you’re on right at the moment, and that route should only be used to display the form for a new article.</p>

<p>The form needs to use a different URL in order to go somewhere else.
This can be done quite simply with the <code>:url</code> option of <code>form_with</code>.
Typically in Rails, the action that is used for new form submissions
like this is called “create”, and so the form should be pointed to that action.</p>

<p>Edit the <code>form_with</code> line inside <code>app/views/articles/new.html.erb</code> to look like this:</p>

<pre><code class="language-erb">&lt;%= form_with scope: :article, url: "/articles", local: true do |form| %&gt;
</code></pre>

<p>Once the form is submitted, it will send a <code>POST</code> request to <code>/articles</code>. If we hit submit on that form now, we’ll be shown a Routing Error:</p>

<p><img src="/images/getting_started/routing_error_post_articles.png" alt="Routing Error" /></p>

<p>This error means that we haven’t set up a route to handle <code>POST</code> requests to <code>/articles</code>. If we look in our <code>config/routes.rb</code> file, we’ll see that is correct:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"
  get "/articles", to: "articles#index"
  get "/articles/new", to: "articles#new", as: :new_article_path
  get "/articles/:id", to: "articles#show", as: :article
end
</code></pre>

<p>Let’s add this new route now:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"
  get "/articles", to: "articles#index"
  get "/articles/new", to: "articles#new", as: :new_article_path
  get "/articles/:id", to: "articles#show", as: :article
  post "/articles", to: "articles#create"
end
</code></pre>

<p>TIP: The <code>get</code> and <code>post</code> methods that we use in <code>config/routes.rb</code> match HTTP request methods. These methods are conventions used across all HTTP applications – not just Rails! – to clearly indicate what sort of action we want to do. A <code>GET</code> request is one that retrieves information. A <code>POST</code> request is one that <em>adds</em> information. For more detials on these, see this MDN article: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods.</p>

<p>When Rails receives a <code>POST /articles</code> request, it will now route that request to the <code>create</code> action of the <code>ArticlesController</code>. However, if we re-submit that form, we’ll see that the action cannot be found:</p>

<p><img src="images/getting_started/unknown_action_create_for_articles.png" alt="Unknown action create for ArticlesController" /></p>

<p>You now need to create the <code>create</code> action within the <code>ArticlesController</code> for this to work.</p>

<h3 id="creating-articles">Creating Articles</h3>

<p>To make the “Unknown action” go away, we can define a <code>create</code> action within the <code>ArticlesController</code> class in <code>app/controllers/articles_controller.rb</code>, underneath the <code>new</code> action, as shown:</p>

<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
  def new
  end

  def create
  end
end
</code></pre>

<p>If you re-submit the form now, you may not see any change on the page. Don’t worry!</p>

<p>This is because Rails by default returns <code>204 No Content</code> response for an action if we don’t specify what the response should be. We just added the <code>create</code> action but didn’t specify anything about how the response should be. In this case, the <code>create</code> action should save our new article to the database.</p>

<p>When a form is submitted, the fields of the form are sent to Rails as
<em>parameters</em>. Yes, there are the same parameters as we saw earlier when we used <code>params[:id]</code>. These parameters can then be referenced inside the controller actions, typically to perform a particular task. To see what these parameters look like, change the <code>create</code> action to this:</p>

<pre><code class="language-ruby">def create
  render plain: params[:article].inspect
end
</code></pre>

<p>The <code>render</code> method here is taking a very simple hash with a key of <code>:plain</code> and value of <code>params[:article].inspect</code>. The <code>params</code> method is the object which represents the parameters (or fields) coming in from the form. The <code>params</code> method returns an <code>ActionController::Parameters</code> object, which allows you to access the keys of the hash using either strings or symbols. In this situation, the only parameters that matter are the ones from the form. Thanks to the use of the <code>scope</code> option on the form, all of our form’s parameters are grouped under <code>params[:article]</code>.</p>

<p>TIP: Ensure you have a firm grasp of the <code>params</code> method, as you’ll use it fairly regularly. Let’s consider an example URL: <strong>http://www.example.com/?username=dhh&amp;email=dhh@email.com</strong>. In this URL, <code>params[:username]</code> would equal “dhh” and <code>params[:email]</code> would equal “dhh@email.com”.</p>

<p>If you re-submit the form one more time, you’ll see something that looks like the following:</p>

<pre><code class="language-ruby">&lt;ActionController::Parameters {"title"=&gt;"Article the Third", "text"=&gt;"The Trilogy Ends"} permitted: false&gt;
</code></pre>

<p>This action is now displaying the parameters for the article that are coming in from the form. However, this isn’t really all that helpful. Yes, you can see the parameters but nothing in particular is being done with them.</p>

<p>Let’s change the  <code>create</code> action to use the <code>Article</code> model to save the data in the database. Let’s change the <code>create</code> action to look like this:</p>

<pre><code class="language-ruby">def create
  article = Article.new(params[:article])
  article.save

  redirect_to article_path(article)
end
</code></pre>

<p>NOTE: We’re <em>not</em> using an instance variable in this action. This is because this action redirects at the end, and since there is a redirection there is no view. So there is no need to make these variables instance variables.</p>

<p>Here we use some familar code to create a new article – we saw this previously right after we generated the <code>Article</code> model. The call to <code>new</code> and then to <code>save</code> will create a new article record in the database.</p>

<p>The final line, a <code>redirect_to</code>, uses <code>article_path</code> to redirect back to the <code>show</code> action.</p>

<p>If you now go to <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> you’ll <em>almost</em> be able to create an article. Try it! You should get an error that looks like this:</p>

<p><img src="images/getting_started/forbidden_attributes_for_new_article.png" alt="Forbidden attributes for new article" /></p>

<p>Rails has several security features that help you write secure applications, and you’re running into one of them now. This one is called <a href="action_controller_overview.html#strong-parameters">strong parameters</a>,
which requires us to tell Rails exactly which parameters are allowed into our controller actions.</p>

<p>Why do you have to bother? The ability to grab and automatically assign all controller parameters to your model in one shot makes the programmer’s job easier, but this convenience also allows malicious use. What if this form was a bank account and we allowed just anyone to add in a new field that set their balance to whatever they wished? This would end up bad for us!</p>

<p>We have to define our permitted controller parameters to prevent wrongful mass assignment. In this case, we want to both allow and require the <code>title</code> and <code>body</code> parameters for valid use of <code>create</code>. The syntax for this introduces <code>require</code> and <code>permit</code>. The change will involve one line in the <code>create</code> action:</p>

<pre><code class="language-ruby">  @article = Article.new(params.require(:article).permit(:title, :body))
</code></pre>

<p>This code is quite long and is often pulled out into its own method so it can be reused by multiple actions in the same controller. Above and beyond mass assignment issues, the method is often made <code>private</code> to make sure it can’t be called outside its intended context. Here is the result:</p>

<pre><code class="language-ruby">def create
  @article = Article.new(article_params)

  @article.save
  redirect_to @article
end

private
  def article_params
    params.require(:article).permit(:title, :body)
  end
</code></pre>

<p>TIP: For more information, refer to the reference above and
[this blog article about Strong Parameters]
(https://weblog.rubyonrails.org/2012/3/21/strong-parameters/).</p>

<p>If we attempt to submit our form once more, this time it will succeed and we’ll see the article’s title and body. The URL should be <a href="http://localhost:3000/articles/3">http://localhost:3000/articles/3</a>, indicating that we’re now on the <code>show</code> action.</p>

<p>Before we wrap up this section, let’s add a link to <code>app/views/articles/index.html.erb</code> so that we can go to the “New Article” page from there:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;%= link_to "New Article", new_article_path %&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;
      &lt;%= link_to article.title, article_path(article) %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>Now we’ll have an easy link to go back to that page:</p>

<p><img src="/images/getting_started/three_articles.png" alt="Three articles" /></p>

<p>Great! That’s another two actions finished in our controller: <code>new</code> and <code>create</code>.</p>

<h3 id="adding-some-validation">Adding Some Validation</h3>

<p>Sometimes, in web applications, we want to make sure certain fields are filled in.</p>

<p>The model file, <code>app/models/article.rb</code> is about as simple as it can get:</p>

<pre><code class="language-ruby">class Article &lt; ApplicationRecord
end
</code></pre>

<p>There isn’t much to this file - but note that the <code>Article</code> class inherits from
<code>ApplicationRecord</code>. <code>ApplicationRecord</code> inherits from <code>ActiveRecord::Base</code> which supplies a great deal of functionality to your Rails models for free. We’ve used some of this already: <code>Article.new</code>, <code>Article.all</code>, <code>Article.find</code> and so on.</p>

<p>One of these pieces of functionality is that Active Record includes methods to help you validate the data that you send to models and it’s easy to use.</p>

<p>Open the <code>app/models/article.rb</code> file and edit it to this:</p>

<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  validates :title, presence: true,
                    length: { minimum: 5 }
end
</code></pre>

<p>These changes will ensure that all articles have a title that is at least five characters long. Rails can validate a variety of conditions in a model, including the presence or uniqueness of columns, their format, and the existence of associated objects. Validations are covered in detail in <a href="active_record_validations.html">Active Record Validations</a>.</p>

<p>This validation will now only let us save articles that have titles longer than 5 characters. Let’s open up the console now and try:</p>

<pre><code class="language-bash">rails console
</code></pre>

<pre><code class="language-ruby">irb(main):001:0&gt; invalid_article = Article.new
=&gt; #&lt;Article id: nil, title: nil, body: nil, created_at: nil, updated_at: nil&gt;
irb(main):002:0&gt; invalid_article.save
=&gt; false
</code></pre>

<p>When <code>save</code> returns <code>false</code>, it means that the object is invalid and won’t be saved to the database. To find out why, we can use this code:</p>

<pre><code class="language-ruby">irb(main):003:0&gt; invalid_article.errors.full_messages
=&gt; ["Title can't be blank", "Title is too short (minimum is 5 characters)"]
</code></pre>

<p>The <code>errors.full_messages</code> method chain shows two validation failure messages for our model:</p>

<ul>
  <li>The title can’t be blank</li>
  <li>The title is too short (minimum of 5 characters)</li>
</ul>

<p>That’s because we’ve left the title blank. Now let’s see what happens when we save an article with a valid title:</p>

<pre><code class="language-plaintext">irb(main):006:0&gt; article = Article.new title: "Getting Started"
=&gt; #&lt;Article id: nil, title: "Getting Started", body: nil, created_at: nil, updated_at: nil&gt;

irb(main):007:0&gt; article.save
   (0.1ms)  begin transaction
  Article Create (0.4ms)  INSERT INTO "articles" ("title", "created_at", "updated_at") VALUES (?, ?, ?)  [["title", "Getting Started"], ["created_at", "2020-01-19 09:56:25.693465"], ["updated_at", "2020-01-19 09:56:25.693465"]]
   (0.6ms)  commit transaction
=&gt; true
</code></pre>

<p>The <code>save</code> call here has returned <code>true</code>, indicating that the article has passed validations. Also in the console, we can see an <code>Article Create</code> message, that contains an <code>INSERT INTO</code> database query, and so we can be confident that this article has now been inserted into our database.</p>

<p>Now that we’ve seen how to handle invalid and valid articles in the console, let’s try using this same technique in our controller.</p>

<p>If you open
<code>app/controllers/articles_controller.rb</code> again, you’ll notice that we don’t check the result of calling <code>@article.save</code> inside the <code>create</code> action.</p>

<pre><code class="language-ruby">def create
  @article = Article.new(article_params)

  @article.save
  redirect_to @article
end
</code></pre>

<p>If <code>@article.save</code> fails in this situation, we need to do something different: we need to show the form again to the user so that they can correct their mistake.</p>

<p>To do this, let’s change the <code>create</code> action to either redirect to the article if the save was successful (the method returns <code>true</code>) or to show the new form again if the save failed:</p>

<pre><code class="language-ruby">def new
  @article = Article.new
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to article_path(@article)
  else
    render 'new'
  end
end
</code></pre>

<p>The first thing to note here is that we’ve now switched from using a local variable <code>article</code> to using an instance variable, <code>@article</code>. The reason for this is the <code>else</code> statement. Inside that <code>else</code> we tell Rails to <code>render 'new'</code>. This tells Rails that we want the <code>app/views/articles/new.html.erb</code> view to be rendered in the case where our save fails.</p>

<p>If you reload <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> and
try to save an article without a title, Rails will send you back to the
form, but that’s not very useful. It doesn’t tell us why something went wrong. To do that, we’ll need to modify <code>app/views/articles/new.html.erb</code> to check for error messages:</p>

<pre><code class="language-erb">&lt;h1&gt;New Article&lt;/h1&gt;

&lt;%= form_with scope: :article, url: "/articles", local: true do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;
</code></pre>

<p>At the top of this view, we’re now using <code>@article.errors</code> to check for any errors. The <code>@article</code> variable here will come from the <code>create</code> action, when the <code>app/views/articles/new.html.erb</code> view is rendered due to an invalid article.</p>

<p>Inside the check for any errors, we call <code>pluralize</code>. <code>pluralize</code> is a rails helper that takes a number and a string as its arguments. If the number is greater than one, the string will be automatically
pluralized.</p>

<p>If we attempt to go to <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> at this point, we’ll see it fail:</p>

<p><img src="images/getting_started/no_method_in_form.png" alt="NoMethodError" /></p>

<p>This is happening because we’re referring to a variable called <code>@article</code> within <code>app/views/articles/new.html.erb</code>, but the <code>new</code> action does not provide this variable at all.</p>

<p>The path to this error is:</p>

<ol>
  <li>Browser goes to http://localhost:3000/articles/new</li>
  <li>Rails sees <code>/articles/new</code> is the route, routes the request to the <code>ArticlesController</code>’s <code>new</code> action</li>
  <li>The <code>new</code> action is blank, and so Rails defaults to rendering <code>app/views/articles/new.html.erb</code>.</li>
  <li>The template attempts to reference <code>@article</code>, but it is not defined.</li>
</ol>

<p>So to make this error go away, we need to define this <code>@article</code> variable. We can do it like this in the <code>new</code> action inside <code>app/controllers/articles_controller.rb</code>:</p>

<pre><code class="language-ruby">def new
  @article = Article.new
end
</code></pre>

<p>This <code>@article</code> is a brand-new <code>Article</code> object, and will be perfect for our form. It doesn’t have any errors on it – because we haven’t tried saving it yet! – and so the form will not display any errors.</p>

<p>If we refresh this <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> page, we should see our form renders once again.</p>

<p><img src="images/getting_started/new_article.png" alt="The form works again" /></p>

<p>Now you’ll get a nice error message when saving an article without a title when
you attempt to do just that on the new article form
<a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>:</p>

<p><img src="images/getting_started/form_with_errors.png" alt="Form With Errors" /></p>

<p>And there we have it! We now have the ability to create new articles within our application.</p>

<h3 id="updating-articles">Updating Articles</h3>

<p>Now what should happen if we make a mistake when creating an article? Well, we should have a way to edit an article and correct that mistake.</p>

<p>Our edit form will look just like our new form, just with a few differences:</p>

<p><img src="/images/getting_started/edit_form.png" alt="Edit form" /></p>

<p>Firstly, the title will say “Edit Article”, not “New Article”. Secondly, the fields will be filled out with the article’s current values. And lastly, the submit button says “Update Article”, not “Save Article”.</p>

<p>To add this feature to our application, we’re going to need to add a new route, a route just for editing articles. Let’s do this now in <code>config/routes.rb</code>:</p>

<pre><code class="language-ruby">get "/articles/:id/edit", to: "articles#edit", as: :edit_article
</code></pre>

<p>This new route is another <code>get</code> route. This time, we’re routing to <code>/articles/:id/edit</code>, so that we can see that edit form for a particular article. Which article we’re editing depends on that <code>:id</code> parameter in the route.</p>

<p>The route will be handled by the <code>edit</code> action within <code>ArticlesController</code>. We’ll add that action soon.</p>

<p>The <code>as</code> option will provide us with a routing helper that we can use across our application to take us to this edit form for a specific article.</p>

<p>As a first step, let’s add an “Edit” link for each article on <code>app/views/articles/index.html.erb</code>:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;%= link_to "New Article", new_article_path %&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;
      &lt;%= link_to article.title, article_path(article) %&gt;
      &lt;%= link_to "Edit", edit_article_path(article) %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This “Edit” link will now appear next to all of the articles at <a href="http://localhost:3000/articles">http://localhost:3000/articles</a>.</p>

<p><img src="/images/getting_started/articles_with_edit.png" alt="Articles with edit links" /></p>

<p>If we click on any one of those “Edit” links, we’ll see that we haven’t yet defined the <code>edit</code> action.</p>

<p><img src="/images/getting_started/no_edit_action.png" alt="No edit action" /></p>

<p>So the next step here is to add that action to our controller. Let’s open <code>app/controllers/articles_controller.rb</code> and add that action:</p>

<pre><code class="language-ruby">def new
  @article = Article.new
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

def edit
  @article = Article.find(params[:id])
end
</code></pre>

<p>NOTE:  We’re using <code>edit</code> to render just a form to display the current values of the article. For the actual updating of the article, we’ll use a different action for this shortly called <code>update</code>.</p>

<p>The view will contain a form similar to the one we used when creating new articles. Create a file called <code>app/views/articles/edit.html.erb</code> and put this content inside:</p>

<pre><code class="language-erb">&lt;h1&gt;Edit Article&lt;/h1&gt;

&lt;%= form_with model: @article, local: true do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;
</code></pre>

<p>The only things different in this view are the <code>&lt;h1&gt;</code> at the top of the view, and the <code>form_with</code>. The <code>form_with</code> is not using <code>scope</code> or <code>url</code>, but is instead using a different key called <code>model</code>.</p>

<p>The <code>model</code> key for <code>form_with</code> takes an instance of a model’s class and builds a form for that particular object. By using <code>form_with</code> in this way, Rails will pre-populate the title and body fields in this form for us.</p>

<p>There’s one extra feature that Rails does for us that is not immediately obvious from looking at the form itself. This feature requires us to look at the HTML source of this form. Inside this source at the top of the <code>&lt;form&gt;</code> element, here’s what we’ll see:</p>

<pre><code class="language-html">&lt;form action="/articles/1" accept-charset="UTF-8" method="post"&gt;
&lt;input type="hidden" name="_method" value="patch" /&gt;
</code></pre>

<p>Firstly, the <code>action</code> attribute for this form goes to a route called <code>/articles/1</code>. This path was automatically generated by Rails; in short: it uses the <code>article_path</code> helper to generate this route. The second thing to notice is that hidden field. This hidden field is a special field that will make the form do a <code>PATCH</code> request when this form is submitted, instead of the default <code>POST</code> (as is configured in the <code>form</code> element’s <code>method</code> attribute).</p>

<p>This means that our form will make a <code>PATCH /articles/1</code> request when it is submitted. If we hit submit on the form, we’ll see that this is correct, and that this route is currently missing:</p>

<p><img src="/images/getting_started/no_route_for_patch_articles.png" alt="No route matches [PATCH] &quot;/articles/1&quot;" /></p>

<p>This route is supposed to handle the submission of our form, but the route does not exist yet. To make this form work, we’ll need to define this route. Let’s go back to <code>config/routes.rb</code> and define this route:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"
  get "/articles", to: "articles#index"
  get "/articles/new", to: "articles#new", as: :new_article
  get "/articles/:id", to: "articles#show", as: :article
  post "/articles", to: "articles#create"
  get "/articles/:id/edit", to: "articles#edit", as: :edit_article
  patch "/articles/:id", to: "articles#update"
end
</code></pre>

<p>This <code>patch</code> method will generate us a route for <code>PATCH /articles/:id</code> requests. We use the <code>PATCH</code> HTTP routing method for when we want to modify an existing resource.</p>

<p>These requests to <code>PATCH /articles/:id</code> will be routed to the <code>update</code> action in our <code>ArticlesController</code>. Let’s add that action now underneath the <code>edit</code> action:</p>

<pre><code class="language-ruby">def edit
  @article = Article.find(params[:id])
end

def update
  @article = Article.find(params[:id])

  if @article.update(article_params)
    redirect_to @article
  else
    render 'edit'
  end
end

private
  def article_params
    params.require(:article).permit(:title, :body)
  end
</code></pre>

<p>The new method, <code>update</code>, is used when you want to update a record that already exists, and it accepts a hash containing the attributes that you want to update. As before, if there was an error updating the article we want to show the form back to the user.</p>

<p>We reuse the <code>article_params</code> method that we defined earlier for the create action. We want to accept the same parameters here, and so it makes sense to use the same <code>article_params</code> method.</p>

<p>TIP: It is not necessary to pass all the attributes to <code>update</code>. For example, if <code>@article.update(title: 'A new title')</code> was called, Rails would only update the <code>title</code> attribute, leaving all other attributes untouched.</p>

<p>Let’s try this again. We’ll go to <a href="http://localhost:3000">http://localhost:3000</a>, click the “Edit” link next to one of the articles and change its title. I’m going to change the “Hello Rails” article’s title to “Hello Rails, how are you today?”. When this happens and we submit the form, we will see the new title for that article:</p>

<p><img src="/images/getting_started/how_are_you_rails.png" alt="How are you, Rails?" /></p>

<p>On this page, we’re currently missing a way to edit an article. This route that we’re currently on is <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a>, and we know that the route matches to <code>app/views/articles/show.html.erb</code>.</p>

<p>This now finishes our adventures in adding the ability to edit an article in this application.</p>

<h3 id="using-partials-to-clean-up-duplication-in-views">Using partials to clean up duplication in views</h3>

<p>Our <code>edit</code> page looks very similar to the <code>new</code> page; in fact, they both share almost same code for displaying the form. Rails has yet another great feature that we can use to reduce this duplication and this feature is called <em>partials</em>.</p>

<p>Partials allow us to extract out comon pieces of views into a file that is then shared across many different views, or in this case, just two views. Let’s remove this
duplication by using a partial. By convention, partial files are
prefixed with an underscore.</p>

<p>TIP: You can read more about partials in the
<a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a> guide.</p>

<p>Create a new file <code>app/views/articles/_form.html.erb</code>. We’re going to copy <em>most</em> of <code>app/views/articles/edit.html.erb</code> into this new partial file:</p>

<pre><code class="language-erb">&lt;%= form_with model: article, local: true do |form| %&gt;

  &lt;% if article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;
</code></pre>

<p>This partial can now be used in both the <code>new</code> and <code>edit</code> views. Let’s update the new view:</p>

<pre><code class="language-erb">&lt;h1&gt;New Article&lt;/h1&gt;

&lt;%= render 'form', article: @article %&gt;
</code></pre>

<p>Then do the same for the <code>app/views/articles/edit.html.erb</code> view:</p>

<pre><code class="language-erb">&lt;h1&gt;Edit Article&lt;/h1&gt;

&lt;%= render 'form', article: @article %&gt;

&lt;%= link_to 'Back', articles_path %&gt;
</code></pre>

<p>This <code>render</code> call in a view works differently to the <code>render</code> call in a controller. Back in the <code>create</code> action for <code>ArticlesController</code>, we have this:</p>

<pre><code>def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end
</code></pre>

<p>This <code>render</code> method call will render a <em>view</em>, not a partial. In this case, it will render the <code>app/views/articles/new.html.erb</code> view.</p>

<p>But when we call <code>render</code> inside a view, it will render a <em>partial</em>. When we call <code>render 'form', article: @article</code> inside our <code>new.html.erb</code> and <code>edit.html.erb</code> views, this will render the <code>app/views/articles/_form.html.erb</code> partial. How does Rails know that we want <em>this</em> particular form partial? It assumes we want the one in the same directory as the current view by default. This is another one of Rails’ conventions at work!</p>

<p>The <code>article: @article</code> syntax at the end of this line tells Rails that we want to pass the instance variable <code>@article</code> to the partial as a <em>local variable</em> called <code>article</code>.</p>

<p>Inside that partial, we can access whatever the current article is by using the <code>article</code> local variable.</p>

<p>Now, an interesting thing happens here. When this partial is rendered for the <code>new</code> action, the form will submit to the <code>create</code> action. But when it’s rendered for the <code>edit</code> action, it will submit to the <code>update</code> action. Go ahead and try it.</p>

<p>How can one piece of code do two things? The way this works lies in the magic of <code>form_with</code> and what it outputs, depending on its <code>model</code> option.</p>

<p>When this partial is rendered by the <code>new</code> action, the <code>@article</code> variable is set like this:</p>

<pre><code class="language-ruby">def new
  @article = Article.new
end
</code></pre>

<p>The <code>form_with</code> helper from Rails detects that this object hasn’t yet been saved to the database, and therefore assumes we want to display a form for <em>creating</em> a new article. If you look at the HTML source from <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>, you’ll see the form is configured like this:</p>

<pre><code class="language-html">&lt;form action="/articles" accept-charset="UTF-8" method="post"&gt;
</code></pre>

<p>When the form is submitted, it will make a <code>POST /articles</code> request. This will go to the <code>create</code> action in <code>ArticlesController</code>, because that’s how our routes are configured:</p>

<pre><code class="language-ruby">post "/articles", to: "articles#create"
</code></pre>

<p>Over in the <code>edit</code> action, we instead set <code>@article</code> like this:</p>

<pre><code class="language-ruby">def edit
  @article = Article.find(params[:id])
end
</code></pre>

<p>This <code>@article</code> represents an article that has already been saved to the database, and so <code>form_with</code> behaves different. Let’s look at the HTML source from <a href="http://localhost:3000/articles/1/edit">http://localhost:3000/articles/1/edit</a> and see:</p>

<pre><code class="language-html">&lt;form action="/articles/1" accept-charset="UTF-8" method="post"&gt;&lt;input type="hidden" name="_method" value="patch" /&gt;
</code></pre>

<p>This is the same <code>form_with</code> method call that is running, but it is acting differently. This time, the form is generated with an <code>action</code> of <code>/articles/1</code>. The hidden field called <code>_method</code> will make Rails do a <code>PATCH /articles/1</code> request. If we look in our routes file, we’ll see that such a request goes to the <code>update</code> action:</p>

<pre><code class="language-ruby">patch "/articles/:id", to: "articles#update"
</code></pre>

<p>This is no coincidence. We have chosen these routes very specifically so that we can follow Rails conventions. The <code>form_with</code> helper acts differently depending on if the <code>@article</code> has been saved or not, and so we can use this one partial to represent a form in either <code>new.html.erb</code> or <code>edit.html.erb</code>.</p>

<p>Partials are a very handy feature of Rails that we can use to remove duplication between separate views. And combining them with <code>form_with</code> allows us to merge together two forms into one, without sacrificing any of our sanity.</p>

<h3 id="deleting-articles">Deleting Articles</h3>

<p>We’re now able to see, create, and update articles within our application. The final part that we’ll cover for articles in this guide is how to delete them.</p>

<p>In order to edit articles, we provided a link right next to the article’s title in <code>app/views/articles/index.html.erb</code>. To delete articles, let’s do the same thing:</p>

<pre><code class="language-erb">&lt;h1&gt;Articles&lt;/h1&gt;

&lt;%= link_to "New Article", new_article_path %&gt;

&lt;ul&gt;
  &lt;% @articles.each do |article| %&gt;
    &lt;li&gt;
      &lt;%= link_to article.title, article_path(article) %&gt;
      &lt;%= link_to "Edit", edit_article_path(article) %&gt;
      &lt;%= link_to "Delete", article_path(article) %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</code></pre>

<p>This <code>link_to</code> won’t delete the article. It will instead take us to the <code>show</code> action in <code>ArticlesController</code> and show us the article itself. We need to add one extra thing to this link, which is a <code>method</code> option:</p>

<pre><code class="language-erb">&lt;%= link_to "Delete", article_path(article), method: :delete
%&gt;
</code></pre>

<p>This will make the link make a <code>DELETE /articles/:id</code> request. The <code>DELETE</code> HTTP method is one that we use when we want to delete things.</p>

<p>We can now refresh this page and click one of these “Delete” links. This request currently won’t work, because we don’t have a <code>DELETE /articles/:id</code> route set up:</p>

<p><img src="/images/getting_started/no_delete_route.png" alt="No delete route" /></p>

<p>Let’s add this route to <code>config/routes.rb</code>:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"
  get "/articles", to: "articles#index"
  get "/articles/new", to: "articles#new", as: :new_article
  get "/articles/:id", to: "articles#show", as: :article
  post "/articles", to: "articles#create"
  get "/articles/:id/edit", to: "articles#edit", as: :edit_article
  patch "/articles/:id", to: "articles#update"
  delete "/articles/:id", to: "articles#destroy"
end
</code></pre>

<p>This route will now match <code>DELETE /articles/:id</code> requests and send them to the <code>destroy</code> action in <code>ArticlesController</code>. Let’s add this action now in the <code>ArticlesController</code>:</p>

<pre><code class="language-ruby">def destroy
  article = Article.find(params[:id])
  article.destroy

  redirect_to articles_path
end
</code></pre>

<p>The complete <code>ArticlesController</code> in the
<code>app/controllers/articles_controller.rb</code> file should now look like this:</p>

<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def new
    @article = Article.new
  end

  def create
    @article = Article.new(article_params)

    if @article.save
      redirect_to @article
    else
      render 'new'
    end
  end

  def edit
    @article = Article.find(params[:id])
  end

  def update
    @article = Article.find(params[:id])

    if @article.update(article_params)
      redirect_to @article
    else
      render 'edit'
    end
  end

  def destroy
    article = Article.find(params[:id])
    article.destroy

    redirect_to '/'
  end

  private
    def article_params
      params.require(:article).permit(:title, :body)
    end
end
</code></pre>

<p>You can call <code>destroy</code> on model instances when you want to delete them from the database. Note that we don’t need to add a view for this action since we’re redirecting back to ‘/’ – the root of our application.</p>

<p>If we click “Delete” again on our list of articles, we’ll each article disappear in turn.</p>

<p>We might want to be a little mindful here and ask users if they’re <em>really</em> sure that they want to delete an article. Having a link so close to “Edit” like this is a recipe for disaster!</p>

<p>To prompt the user, we’re going to change the “Delete” link in <code>app/views/articles/index.html.erb</code> to this:</p>

<pre><code class="language-erb">&lt;%= link_to "Delete",
  article_path(article),
  method: :delete,
  data: {
    confirm: "Are you sure you want to delete this article?"
  }
%&gt;
</code></pre>

<p>This <code>data</code> option uses a feature of Rails called <em>Unobtrusive JavaScript</em>. By default, Rails applications come with a little bit of JavaScript for features like this.</p>

<p>TIP: Learn more about Unobtrusive JavaScript on
<a href="working_with_javascript_in_rails.html">Working With JavaScript in Rails</a> guide.</p>

<p>When we refresh this page and click “Delete” once again, we’ll see a new dialog box appear:</p>

<p><img src="/images/getting_started/confirm_dialog.png" alt="Confirm Dialog" /></p>

<p>If you press “Cancel” on this box, nothing will happen. The article will <em>not</em> be deleted. But if you press “OK”, then the article will be deleted. Rails provides this option on links just for links like this “Delete” link. We want people to be <em>really sure</em> that they mean to delete articles before they actually do it!</p>

<p>That is the last of our actions in the <code>ArticlesController</code>. We now have ways to create, read, update and delete articles. This pattern is so common in Rails applications that it even has its own acronym: CRUD: Create, Read, Update and Delete. What we have built here is a CRUD interface for articles.</p>

<h3 id="routing-for-resources">Routing for resources</h3>

<p>So far, we have not had to write much code to make our application functional. But there’s one extra thing that will massively reduce the lines of code you will write in the future, and that thing is called <em>resource routing</em>.</p>

<p>Rails has a convention that it follows when it comes to routing. When we list a collection of a resource, such as articles, that list is going to appear under the <code>index</code> action. When we want to see a single resource, such as a single article, that appears at the <code>show</code> action, and so on.</p>

<p>So far, we have been following this convention in Rails without drawing attention too much attention to it. In this section, we’re going to draw a lot of attention to it. By following this routing convention, we can simplify the code within <code>config/routes.rb</code> drastically. That file currently contains this code:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"
  get "/articles", to: "articles#index"
  get "/articles/new", to: "articles#new", as: :new_article
  get "/articles/:id", to: "articles#show", as: :article
  post "/articles", to: "articles#create"
  get "/articles/:id/edit", to: "articles#edit", as: :edit_article
  patch "/articles/:id", to: "articles#update"
  delete "/articles/:id", to: "articles#destroy"
end
</code></pre>

<p>We’ve been able to define our routes using the <code>root</code>, <code>get</code>, <code>post</code>, <code>patch</code> and <code>delete</code> helpers. But Rails comes with one helper that we haven’t seen yet, and that helper is called <code>resources</code>.</p>

<p>We can delete most of the code in this routes file and replace it with this method call:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"

  resources :articles
end
</code></pre>

<p>This one line replaces all 7 of the routes that we had defined previously. This is one of the parts of Rails that people claim as the most “magical”, and hopefully by defining all 7 routes manually first you will gain an appreciation for the elegance of <code>resources</code> here.</p>

<p>To see what this has done, we can run this command in the terminal:</p>

<pre><code class="language-bash">rails routes --controller articles
</code></pre>

<p>Or:</p>

<pre><code class="language-bash">rails routes -c articles
</code></pre>

<p>This command will show us all the routes for the <code>ArticlesController</code>:</p>

<pre><code class="language-plaintext">      Prefix Verb   URI Pattern                  Controller#Action
        root GET    /                            articles#index
    articles GET    /articles(.:format)          articles#index
 new_article GET    /articles/new(.:format)      articles#new
     article GET    /articles/:id(.:format)      articles#show
             POST   /articles(.:format)          articles#create
edit_article GET    /articles/:id/edit(.:format) articles#edit
             PATCH  /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
</code></pre>

<p>This command shows us four things:</p>

<ul>
  <li>Prefix: The routing helper <em>prefix</em> that can be used to generate this route. For example “article” means <code>article_path</code> can be used.</li>
  <li>Verb: The HTTP Verb / method that is used to make this request.</li>
  <li>URI pattern: the <em>path</em> of the route that is used to make this request.</li>
  <li>Controller &amp; Action: The controller &amp; action that will serve this request.</li>
</ul>

<p>From this output, we’ll be able to tell that a <code>GET</code> request to <code>/articles/new</code> will go to the <code>ArticlesController</code>’s <code>new</code> action.</p>

<p>These are all the same routes that we had previously, it’s just that we’re using one line to generate them now instead of 7.</p>

<p>TIP: In general, Rails encourages using resources objects instead of declaring routes manually. For more information about routing, see <a href="routing.html">Rails Routing from the Outside In</a>.</p>

<p>We have now completely finished building the first part of our application. If you’ve gotten this far, give yourself a pat on the back! And maybe a little break before you continue on this guide.</p>

<p>We’re about two-thirds of the way through, and have just a few more features of Rails to show off.</p>

<h2 id="adding-comments">Adding Comments</h2>

<p>Let’s expand this application a little further by adding the ability for users to leave comments on articles.</p>

<h3 id="generating-a-model">Generating a Model</h3>

<p>To start with, we’re going to generate a model for comments.</p>

<p>We’re going to see the same generator that we used before when creating the <code>Article</code> model. This time we’ll create a <code>Comment</code> model to hold a reference to an article. Run this command in your terminal:</p>

<pre><code class="language-bash">$ bin/rails g model Comment commenter:string body:text article:references
</code></pre>

<p>This command will generate four files:</p>

<pre><code>invoke  active_record
create    db/migrate/[timestamp]_create_comments.rb
create    app/models/comment.rb
invoke    test_unit
create      test/models/comment_test.rb
create      test/fixtures/comments.yml
</code></pre>

<p>First, let’s take a look at <code>app/models/comment.rb</code>:</p>

<pre><code class="language-ruby">class Comment &lt; ApplicationRecord
  belongs_to :article
end
</code></pre>

<p>This is very similar to the <code>Article</code> model that you saw earlier. The difference is the line <code>belongs_to :article</code>, which sets up an Active Record <em>association</em>. You’ll learn a little about associations in the next section of this guide. This <code>belongs_to</code> was added to our model because we specific <code>article:references</code> when we generated this model.</p>

<p>The <code>references</code> type is a special type that define an association between the model that we’re generating and another model. In this case, we’re saying that every comment <em>belongs to</em> an article.</p>

<p>Let’s look at the migration next:</p>

<pre><code class="language-ruby">class CreateComments &lt; ActiveRecord::Migration[6.0]
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :article, null: false, foreign_key: true

      t.timestamps
    end
  end
end
</code></pre>

<p>The <code>t.references</code> line creates does a few things:</p>

<ol>
  <li>It adds a field called <code>article_id</code> to the comments table</li>
  <li>A <a href="https://www.essentialsql.com/what-is-a-database-index/">database index</a> is added for that column. This will speed up retrieving comments for particular articles.</li>
  <li>The <code>null: false</code> option says that in no circumstance can this column be set to a <code>NULL</code> value.</li>
  <li>The <code>foreign_key: true</code> option says that this column is linked to the <code>articles</code> table, and that the column’s values must be represented in the <code>articles</code> table, in the <code>id</code> column. There can be no comments without a related article to match.</li>
</ol>

<p>Go ahead and run the migration:</p>

<pre><code class="language-bash">$ bin/rails db:migrate
</code></pre>

<p>Rails is smart enough to only execute the migrations that have not already been
run against the current database, so in this case you will just see:</p>

<pre><code class="language-bash">==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; 0.0115s
==  CreateComments: migrated (0.0119s) ========================================
</code></pre>

<p>This migration will create our comments table. It will look like this in our database:</p>

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>commenter</th>
      <th>body</th>
      <th>article_id</th>
      <th>created_at</th>
      <th>updated_at</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="associating-models">Associating Models</h3>

<p>Active Record associations let you easily declare the relationship between two
models. In the case of comments and articles, you could write out the
relationships this way:</p>

<ul>
  <li>Each comment belongs to one article.</li>
  <li>One article can have many comments.</li>
</ul>

<p>In fact, this is very close to the syntax that Rails uses to declare this
association. You’ve already seen the line of code inside the <code>Comment</code> model
(app/models/comment.rb) that makes each comment belong to an Article:</p>

<pre><code class="language-ruby">class Comment &lt; ApplicationRecord
  belongs_to :article
end
</code></pre>

<p>You’ll need to edit <code>app/models/article.rb</code> to add the other side of the
association:</p>

<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  has_many :comments
  validates :title, presence: true,
                    length: { minimum: 5 }
end
</code></pre>

<p>These two declarations enable a good bit of automatic behavior. Let’s explore some of this behaviour by starting up a new console:</p>

<pre><code>rails c
</code></pre>

<p>First, let’s find an article:</p>

<pre><code>irb(main):001:0&gt; article = Article.first

Article Load (0.1ms)  SELECT "articles".* FROM "articles" ORDER BY "articles"."id" ASC LIMIT ?  [["LIMIT", 1]]

=&gt; #&lt;Article id: 1, title: "Hello Rails", body: "I'm on Rails", created_at: "2020-01-20 05:22:45", updated_at: "2020-01-20 05:22:45"&gt;
</code></pre>

<p>Next up, let’s create a new comment for this article by using the <code>comments</code> association method:</p>

<pre><code>irb(main):002:0&gt; article.comments.create(commenter: "DHH", body: "Welcome to Rails!")

Comment Create (0.4ms)  INSERT INTO "comments" ("commenter", "body", "article_id", "created_at", "updated_at") VALUES (?, ?, ?, ?, ?)  [["commenter", "DHH"], ["body", "Welcome to Rails!"], ["article_id", 9], ["created_at", "2020-01-20 06:19:33.572961"], ["updated_at", "2020-01-20 06:19:33.572961"]]

=&gt; #&lt;Comment id: 1, commenter: "DHH", body: "Welcome to Rails!", article_id: 1, created_at: "2020-01-20 06:19:33", updated_at: "2020-01-20 06:19:33"&gt;
</code></pre>

<p>If you look at the list of attributes here, you’ll see that both <code>commenter</code> and <code>body</code> are set the values that we passed in. We have come to expect this behaviour from Active Record: we give it attributes, it sets them on the object.</p>

<p>What we haven’t seen before is what has happened to <code>article_id</code> here. That attribute has been automatically set to the ID of the <code>article</code> object. This is what links that <code>Comment</code> object back to the article.</p>

<p>To find an article’s comments, we can do this:</p>

<pre><code>irb(main):003:0&gt; article.comments

Comment Load (0.9ms)  SELECT "comments".* FROM "comments" WHERE "comments"."article_id" = ? LIMIT ?  [["article_id", 9], ["LIMIT", 11]]

=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Comment id: 1, commenter: "DHH", body: "Welcome to Rails!", article_id: 9, created_at: "2020-01-20 06:19:33", updated_at: "2020-01-20 06:19:33"&gt;]&gt;
</code></pre>

<p>This <code>comments</code> method on <code>Article</code> objects allows us to work with the comments for any given article.</p>

<p>Similarly, there is an <code>article</code> method on comments. Let’s see that in action too:</p>

<pre><code>irb(main):004:0&gt; comment = Comment.first

Comment Load (0.2ms)  SELECT "comments".* FROM "comments" ORDER BY "comments"."id" ASC LIMIT ?  [["LIMIT", 1]]

=&gt; #&lt;Comment id: 1, commenter: "DHH", body: "Welcome to Rails!", article_id: 9, created_at: "2020-01-20 06:19:33", updated_at: "2020-01-20 06:19:33"&gt;


irb(main):005:0&gt; comment.article

Article Load (0.2ms)  SELECT "articles".* FROM "articles" WHERE "articles"."id" = ? LIMIT ?  [["id", 9], ["LIMIT", 1]]

=&gt; #&lt;Article id: 9, title: "dsfsadfasdf", body: "asdfasdfasdf", created_at: "2020-01-20 05:22:45", updated_at: "2020-01-20 05:22:45"&gt;
</code></pre>

<p>This <code>article</code> method is granted to us by the <code>belongs_to</code> method call in the <code>Comment</code> model.</p>

<p>TIP: For more information on Active Record associations, see the <a href="association_basics.html">Active Record Associations</a> guide.</p>

<h3 id="displaying-comments-on-articles">Displaying comments on articles</h3>

<p>Now that we can create comments on articles, it would be really useful to display them somewhere. The most appropriate place to do that would be within the <code>app/views/articles/show.html.erb</code> view. Let’s change this view now to display all of the comments:</p>

<pre><code class="language-erb">&lt;h1&gt;&lt;%= @article.title %&gt;&lt;/h1&gt;

&lt;%= @article.body %&gt;

&lt;h2&gt;Comments&lt;/h2&gt;

&lt;% @article.comments.each do |comment| %&gt;
  &lt;p&gt;
    &lt;strong&gt;Commenter:&lt;/strong&gt;
    &lt;%= comment.commenter %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;strong&gt;Comment:&lt;/strong&gt;
    &lt;%= comment.body %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

&lt;div&gt;
  &lt;%= link_to "Back", "/" %&gt;
&lt;/div&gt;
</code></pre>

<p>The new code that we’ve just added to this view will go through all of the article’s comments and display the commenter and the comment that was made. When we go to <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a> now, we should see this comment appear:</p>

<p><img src="/images/getting_started/article_with_comments.png" alt="Article with comments" /></p>

<p>Well, that was pretty straight forward! Rails has given us an easy way to list all of the article comments, by way of the <code>has_many</code> method in the <code>Article</code> model.</p>

<h3 id="adding-a-comment">Adding a comment</h3>

<p>Now that we have a way to see all of the current comments, let’s add a form that lets us create additional comments. To start with, we’re going to put this form in <code>app/views/articles/show.html.erb</code>, just below the comments we just added:</p>

<pre><code class="language-erb">
&lt;% @article.comments.each do |comment| %&gt;
  ...
&lt;% end %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= form_with model: [@article, @article.comments.build], local: true do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :commenter %&gt;&lt;br&gt;
    &lt;%= form.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>

<p>This form looks almost like the one in <code>app/views/articles/_form.html.erb</code>, but it has one key difference: the <code>model</code> key has been passed an array, instead of a single model instance. What will happen here is that the form will build what’s called a <em>nested route</em> for the comment.</p>

<p>The second element in that array is <code>@article.comments.build</code>. This is a helper method that comes from <code>has_many</code>, that is essentially equivalent to this code:</p>

<pre><code>Comment.new(article_id: @article.id)
</code></pre>

<p>We’re going to be building a new comment for the purposes of saving it to the database, eventually.</p>

<p>If we refresh <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a>, we’ll see an error message which hints a little bit at this nested route:</p>

<p><img src="/images/getting_started/no_method_error_article_comments_path.png" alt="NoMethodError: article_comments_path" /></p>

<p>The <code>form_with</code> helper here is attempting to use a routing helper called <code>article_comments_path</code> to generate the route for the form. This routing helper doesn’t exist yet, and we’ll create it in a moment. But first, let’s talk about how Rails came to be wanting <code>article_comments_path</code> in the first place.</p>

<p>When we use <code>form_with</code>’s <code>:model</code> option, it combines the <em>class names</em> of the resources we pass it into a routing helper. Back when we were doing <code>form_with model: @article</code>, it would see that the class name of <code>@article</code> was <code>Article</code>. Then, <code>form_with</code> would see if this object had been saved to the database before or not. If the object had not been saved, the form would use <code>articles_path</code> – the <em>plural</em> version of the routing helper. If the object had been saved, it would use <code>article_path</code> – the <em>singular</em> version of routing helper.</p>

<p>The same rule applies here. <code>form_with</code>’s underlying code checks to see what <code>@article</code> is first. It’s an <code>Article</code> that has been saved to the database, so the first part of the routing helper is <code>article</code>. Then it checks what <code>@article.comments.build</code> is. This object is a <code>Comment</code> that has <em>not</em> been saved to the database, so the helper’s next component is <code>comments</code>. Then we’re out of array elements, so <code>form_with</code> puts <code>_path</code> on the end. This is how we arrive at <code>article_comments_path</code>.</p>

<p>This is another one of those excellent Rails conventions you’ve heard about throughout this guide. And it’s one of the more “magical” (or “confusing”) aspects of Rails. So don’t worry too much if you don’t get it first pass.</p>

<p>In order to solve the issue here, we need to add the route that has that routing helper. This time, however, instead of writing seven routes one-at-a-time for comments, just like we did for articles, we’re going to use <code>resources</code> again.</p>

<p>Open up the <code>config/routes.rb</code> file again, and edit it as follows:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root "articles#index"

  resources :articles do
    resources :comments
  end
end
</code></pre>

<p>This creates <code>comments</code> as a <em>nested resource</em> within <code>articles</code>. This is another part of capturing the hierarchical relationship that exists between articles and comments. By nesting comments inside of articles like this, this will give us the <code>article_comments_path</code> helper that our form is expecting.</p>

<p>We can verify this by going into a terminal and running:</p>

<pre><code>rails routes -c comments
</code></pre>

<p>And we’ll see these routes:</p>

<pre><code>              Prefix Verb   URI Pattern                                       Controller#Action
    article_comments GET    /articles/:article_id/comments(.:format)          comments#index
                     POST   /articles/:article_id/comments(.:format)          comments#create
 new_article_comment GET    /articles/:article_id/comments/new(.:format)      comments#new
edit_article_comment GET    /articles/:article_id/comments/:id/edit(.:format) comments#edit
     article_comment GET    /articles/:article_id/comments/:id(.:format)      comments#show
                     PATCH  /articles/:article_id/comments/:id(.:format)      comments#update
                     PUT    /articles/:article_id/comments/:id(.:format)      comments#update
                     DELETE /articles/:article_id/comments/:id(.:format)      comments#destroy
</code></pre>

<p>The <code>article_comments</code> routing helper is the first line. We can see from this routing helper that it will generate the following path:</p>

<pre><code>/articles/:article_id/comments
</code></pre>

<p>We can see this in action if we go back to <a href="http://localhost:3000/articles/1">http://localhost:3000/articles/1</a> and inspect the page’s HTML source again. We’ll see the form has that route as its <code>action</code> attribute:</p>

<pre><code class="language-html">&lt;form action="/articles/9/comments" accept-charset="UTF-8" method="post"&gt;
</code></pre>

<p>TIP: For more information on routing, see the <a href="routing.html">Rails Routing</a>
guide.</p>

<p>When we fill out the comment form and click “Create Comment”, we’ll now see that the <code>CommentsController</code> is missing:</p>

<p><img src="/images/getting_started/comments_controller_missing.png" alt="Comments Controller missing" /></p>

<h3 id="generating-a-controller">Generating a Controller</h3>

<p>To fix this issue, we will need to generate the <code>CommentsController</code>. Let’s do that now:</p>

<pre><code class="language-bash">$ bin/rails g controller comments
</code></pre>

<p>This creates four files and one empty directory:</p>

<table>
  <thead>
    <tr>
      <th>File/Directory</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>app/controllers/comments_controller.rb</td>
      <td>The Comments controller</td>
    </tr>
    <tr>
      <td>app/views/comments/</td>
      <td>Views of the controller are stored here</td>
    </tr>
    <tr>
      <td>test/controllers/comments_controller_test.rb</td>
      <td>The test for the controller</td>
    </tr>
    <tr>
      <td>app/helpers/comments_helper.rb</td>
      <td>A view helper file</td>
    </tr>
    <tr>
      <td>app/assets/stylesheets/comments.scss</td>
      <td>Cascading style sheet for the controller</td>
    </tr>
  </tbody>
</table>

<p>If we attempt to submit the form again, we’ll see that the <code>create</code> action is missing in this new controller:</p>

<p><img src="/images/getting_started/create_action_comments_controller.png" alt="Create action missing in CommentsController" /></p>

<p>Let’s wire up the <code>create</code> in <code>app/controllers/comments_controller.rb</code>:</p>

<pre><code class="language-ruby">class CommentsController &lt; ApplicationController
  def create
    @article = Article.find(params[:article_id])
    @comment = @article.comments.create(comment_params)
    redirect_to article_path(@article)
  end

  private
    def comment_params
      params.require(:comment).permit(:commenter, :body)
    end
end
</code></pre>

<p>You’ll see a bit more complexity here than you did in the controller for articles. That’s a side-effect of the nesting that you’ve set up. Each request for a comment has to keep track of the article to which the comment is attached, thus the initial call to the <code>find</code> method of the <code>Article</code> model to get the article in question.</p>

<p>But where did we get the idea for <code>article_id</code> from? Well, if we look at our route again with:</p>

<pre><code>rails routes -c comments
</code></pre>

<p>Then we’ll see:</p>

<pre><code>              Prefix Verb   URI Pattern                                       Controller#Action
    article_comments GET    /articles/:article_id/comments
</code></pre>

<p>The colon before <code>:article_id</code> indicates that this part of the URL will be available as <code>params[:article_id]</code> in our controller. This is why we’re using <code>:article_id</code> here, and not <code>:id</code>.</p>

<p>In addition, the code takes advantage of some of the methods available for an association. We use the <code>create</code> method on <code>@article.comments</code> to create and save the comment. This will automatically link the comment so that it belongs to
that particular article, just as we saw earlier when we created a comment in the Rails console.</p>

<p>Once we have made the new comment, we send the user back to the original article using the <code>article_path(@article)</code> helper. As we have already seen, this calls the <code>show</code> action of the <code>ArticlesController</code> which in turn renders the <code>show.html.erb</code> template.</p>

<p>If we fill out the comment form again, we will see our comment appear.</p>

<p>Now you can add articles and comments to your blog and have them show up in the right places.</p>

<p><img src="/images/getting_started/article_with_two_comments.png" alt="Article with Two Comments" /></p>

<h2 id="refactoring">Refactoring</h2>

<p>Now that we have articles and comments working, take a look at the <code>app/views/articles/show.html.erb</code> template. It is getting long and awkward. We can use partials to clean this view up.</p>

<h3 id="rendering-partial-collections">Rendering Partial Collections</h3>

<p>First, we will make a comment partial to extract showing all the comments for the article. Create the file <code>app/views/comments/_comment.html.erb</code> and put the following into it:</p>

<pre><code class="language-erb">&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;
</code></pre>

<p>Then you can change <code>app/views/articles/show.html.erb</code> to look like the
following:</p>

<pre><code class="language-erb">&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;%= render @article.comments %&gt;

...
</code></pre>

<p>This is the third style of <code>render</code> that we’ve seen throughout this guide.</p>

<p>The first was <code>render</code> in an action. That one will render a view by using code like <code>render "new"</code>.</p>

<p>The second was <code>render</code> in a view, we saw it in <code>app/views/articles/new.html.erb</code> and <code>app/views/articles/edit.html.erb</code>. It was written as <code>&lt;%= render "form", article: @article %&gt;</code>, and that meant to render the partial at <code>app/views/articles/_form.html.erb</code>.</p>

<p>This third one is <code>render</code> with a collection of objects. Rails will inspect these objects and see what class they are, and then it will render a partial that matches the name of the class: <code>comments/_comment.html.erb</code> for this one. If we were to do the same sort of thing for articles, it would render <code>articles/_article.html.erb</code>.</p>

<p>Inside the <code>comments/_comment.html.erb</code> partial, we’re able to refer to the local variable <code>comment</code> to refer to each comment, just like we did earlier with the <code>each</code> version of this code.</p>

<h3 id="rendering-a-partial-form">Rendering a Partial Form</h3>

<p>Let’s keep tidying up this <code>app/views/articles/show.html.erb</code> view. We can definitely move that comment form out too.</p>

<p>Let us also move that new comment section out to its own partial. To do this, we create a file <code>app/views/comments/_form.html.erb</code> containing:</p>

<pre><code class="language-erb">&lt;%= form_with model: [article, article.comments.build], local: true do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :commenter %&gt;&lt;br&gt;
    &lt;%= form.text_field :commenter %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.label :body %&gt;&lt;br&gt;
    &lt;%= form.text_area :body %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>

<p>Then you make the <code>app/views/articles/show.html.erb</code> look like the following:</p>

<pre><code class="language-erb">...

&lt;h2&gt;Comments&lt;/h2&gt;
&lt;%= render @article.comments %&gt;

&lt;h2&gt;Add a comment:&lt;/h2&gt;
&lt;%= render "comments/form", article: @article %&gt;

...
</code></pre>

<p>This is the second version of the <code>render</code> method: it will render that partial at <code>app/views/comments/_form.html.erb</code> and pass through the instance variable of <code>@article</code> as a local variable called <code>article</code> to that partial.</p>

<h2 id="deleting-comments">Deleting Comments</h2>

<p>Another important feature of a blog is being able to delete spam comments. To do this, we need to implement a link of some sort in the view and a <code>destroy</code>
action in the <code>CommentsController</code>.</p>

<p>So first, let’s add the delete link in the
<code>app/views/comments/_comment.html.erb</code> partial:</p>

<pre><code class="language-erb">&lt;p&gt;
  &lt;strong&gt;Commenter:&lt;/strong&gt;
  &lt;%= comment.commenter %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Comment:&lt;/strong&gt;
  &lt;%= comment.body %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;%= link_to 'Destroy Comment', [comment.article, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' } %&gt;
&lt;/p&gt;
</code></pre>

<p>The second argument to <code>link_to</code> is new to us. Well, sort of. We’ve seen it just before in the form for comments, but that was with <code>form_with</code>, and this is with <code>link_to</code>. This syntax for <code>link_to</code> works exactly the same as it did back in <code>form_with</code>; it works to build a routing helper. The <code>link_to</code> helper checks to see what kind of object <code>comment.article</code> is. It’s an <code>Article</code> object and that object exists in the database, so the first part of that helper is <code>article</code>. Then the second object is a <code>Comment</code> object, and so the second part is <code>comment</code>. This means that the routing helper used will be <code>article_comment_path</code>.</p>

<p>We could write this code out in a longer fashion if we wished:</p>

<pre><code class="language-erb">&lt;p&gt;
  &lt;%= link_to 'Destroy Comment', article_comment_path(comment.article, comment),
               method: :delete,
               data: { confirm: 'Are you sure?' } %&gt;
&lt;/p&gt;
</code></pre>

<p>But Rails’ routing conventions save us some time and keystrokes by allowing us to write <code>[comment.article, comment]</code> instead.</p>

<p>Clicking this new “Destroy Comment” link will fire off a <code>DELETE /articles/:article_id/comments/:id</code> to our <code>CommentsController</code>, which can then use this to find the comment we want to delete. Right now, the <code>destroy</code> action that matches that route is missing, and so we will see this if we attempt to delete a comment:</p>

<p><img src="/images/getting_started/comments_destroy_not_found.png" alt="Destroy not found" /></p>

<p>So let’s add a <code>destroy</code> action
to our controller (<code>app/controllers/comments_controller.rb</code>):</p>

<pre><code class="language-ruby">class CommentsController &lt; ApplicationController
  def create
    @article = Article.find(params[:article_id])
    @comment = @article.comments.create(comment_params)
    redirect_to article_path(@article)
  end

  def destroy
    @article = Article.find(params[:article_id])
    @comment = @article.comments.find(params[:id])
    @comment.destroy
    redirect_to article_path(@article)
  end

  private
    def comment_params
      params.require(:comment).permit(:commenter, :body)
    end
end
</code></pre>

<p>The <code>destroy</code> action will find the article we are looking at, locate the comment within the <code>@article.comments</code> collection, and then remove it from the database and send us back to the show action for the article.</p>

<p>If we attempt to delete a comment again, this time it will disppaear.</p>

<h3 id="deleting-associated-objects">Deleting Associated Objects</h3>

<p>If you delete an article, its associated comments will also need to be deleted, otherwise we would see an <code>ActiveRecord::InvalidForeignKey</code> error happen:</p>

<p><img src="/images/getting_started/foreign_key_constraint.png" alt="Foreign key constraint" /></p>

<p>This error happens because the database will not allow <code>comments</code> to be without an associated article, due to this line in the <code>db/migrate/[timestamp]_create_comments.rb</code> migration:</p>

<pre><code>t.references :article, null: false, foreign_key: true
</code></pre>

<p>The <code>foreign_key</code> option on this line, when set to <code>true</code>, says  that the <code>article_id</code> column within the <code>comments</code> table must have a matching <code>id</code> value in the <code>articles</code> table. If a situation arises where this <em>might</em> happen, the database raises a <em>foreign key constraint</em> error, which is what we’re seeing here.</p>

<p>To avoid this issue, we need to give our <code>Article</code>’s <code>comments</code> association one extra option, called <code>dependent</code>. Let’s change <code>app/models/article.rb</code> to this:</p>

<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  has_many :comments, dependent: :destroy
  validates :title, presence: true,
                    length: { minimum: 5 }
end
</code></pre>

<p>Now when an article is deleted, all of its comments will be deleted too, and we will avoid having a foreign key constraint error happen.</p>

<h2 id="security">Security</h2>

<h3 id="basic-authentication">Basic Authentication</h3>

<p>If you were to publish your blog online, anyone would be able to add, edit and delete articles or delete comments.</p>

<p>Rails provides a very simple HTTP authentication system that will work nicely in this situation.</p>

<p>In the <code>ArticlesController</code> we need to have a way to block access to the various actions if the person is not authenticated. Here we can use the Rails <code>http_basic_authenticate_with</code> method, which allows access to the requested action if that method allows it.</p>

<p>To use the authentication system, we specify it at the top of our <code>ArticlesController</code> in <code>app/controllers/articles_controller.rb</code>. In our case, we want the user to be authenticated on every action except <code>index</code> and <code>show</code>,
so we write that:</p>

<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]

  def index
    @articles = Article.all
  end

  # snippet for brevity
</code></pre>

<p>We also want to allow only authenticated users to delete comments, so in the <code>CommentsController</code> (<code>app/controllers/comments_controller.rb</code>) we write:</p>

<pre><code class="language-ruby">class CommentsController &lt; ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy

  def create
    @article = Article.find(params[:article_id])
    # ...
  end

  # snippet for brevity
</code></pre>

<p>Now if you try to create a new article, you will be greeted with a basic HTTP Authentication challenge:</p>

<p><img src="images/getting_started/challenge.png" alt="Basic HTTP Authentication Challenge" /></p>

<p>Other authentication methods are available for Rails applications. Two popular
authentication add-ons for Rails are the
<a href="https://github.com/plataformatec/devise">Devise</a> rails engine and
the <a href="https://github.com/binarylogic/authlogic">Authlogic</a> gem,
along with a number of others.</p>

<h3 id="other-security-considerations">Other Security Considerations</h3>

<p>Security, especially in web applications, is a broad and detailed area. Security
in your Rails application is covered in more depth in
the <a href="security.html">Ruby on Rails Security Guide</a>.</p>

<h2 id="whats-next">What’s Next?</h2>

<p>Now that you’ve seen your first Rails application, you should feel free to
update it and experiment on your own.</p>

<p>Remember, you don’t have to do everything without help. As you need assistance
getting up and running with Rails, feel free to consult these support
resources:</p>

<ul>
  <li>The <a href="index.html">Ruby on Rails Guides</a></li>
  <li>The <a href="https://groups.google.com/group/rubyonrails-talk">Ruby on Rails mailing list</a></li>
  <li>The <a href="irc://irc.freenode.net/#rubyonrails">#rubyonrails</a> channel on irc.freenode.net</li>
</ul>

<h2 id="configuration-gotchas">Configuration Gotchas</h2>

<p>The easiest way to work with Rails is to store all external data as UTF-8. If
you don’t, Ruby libraries and Rails will often be able to convert your native
data into UTF-8, but this doesn’t always wowrk reliably, so you’re better off
ensuring that all external data is UTF-8.</p>

<p>If you have made a mistake in this area, the most common symptom is a black
diamond with a question mark inside appearing in the browser. Another common
symptom is characters like “Ã¼” appearing instead of “ü”. Rails takes a number
of internal steps to mitigate common causes of these problems that can be
automatically detected and corrected. However, if you have external data that is
not stored as UTF-8, it can occasionally result in these kinds of issues that
cannot be automatically detected by Rails and corrected.</p>

<p>Two very common sources of data that are not UTF-8:</p>

<ul>
  <li>Your text editor: Most text editors (such as TextMate), default to saving
files as UTF-8. If your text editor does not, this can result in special
characters that you enter in your templates (such as é) to appear as a diamond
with a question mark inside in the browser. This also applies to your i18n
translation files. Most editors that do not already default to UTF-8 (such as
some versions of Dreamweaver) offer a way to change the default to UTF-8. Do
so.</li>
  <li>Your database: Rails defaults to converting data from your database into UTF-8
at the boundary. However, if your database is not using UTF-8 internally, it
may not be able to store all characters that your users enter. For instance,
if your database is using Latin-1 internally, and your user enters a Russian,
Hebrew, or Japanese character, the data will be lost forever once it enters
the database. If possible, use UTF-8 as the internal storage of your database.</li>
</ul>
]]></content>
 </entry>
 
 <entry>
   <title>They fixed the keyboard</title>
   <link href="http://ryanbigg.com/2019/11/they-fixed-the-keyboard"/>
   <updated>2019-11-28T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2019/11/they-fixed-the-keyboard</id>
   <content type="html"><![CDATA[<p>Consider this post a sequel to my <a href="https://ryanbigg.com/2019/08/can-apple-please-design-a-laptop-that-has-a-functional-keyboard-for-the-love-of-all-that-is-precious">
The 2018 MacBook Pro Keyboard Drives Me Crazy
(Aug ‘19)</a> post from earlier in the year.</p>

<p>In that post, I listed the following complaints about the 2018 MacBook Pro keyboard:</p>

<blockquote>
  <ul>
    <li>duplicated “o’s” that I’ve had to go back and fix, or missing ones – guess how fun it is to write <a href="https://leanpub.com/elixir-toyrobot">a book about a Toy Robot</a> with this particular problem</li>
    <li>double spaces – or no spaces</li>
    <li>a Command key that registers 9 out of every 10 times</li>
    <li>words like “times” that inexplicably get spelled like “timies”, or “about” that gets spelled like “abouot”</li>
  </ul>
</blockquote>

<p>I’ve now been using a brand-new 2019 MacBook Pro for about 5 hours and I’ve been using the keyboard <em>extensively</em> during the setup of this machine.</p>

<p>Those complaints that I had above? They don’t exist on this keyboard. There has been no duplicated letters, spaces, dodgy Command keys, or mispelled words that were not my clumsiness.</p>

<p>I’ve <em>felt</em> more productive on this keyboard since I got it. I’m guessing because I didn’t have to go back and fix up so many mistakes.</p>

<p>But I wanted to get quantifiable data on this, and given that I <em>type for a living</em> what better way to do this than to run a few tests.</p>

<p>So I went over to <a href="https://typeracer.com">TypeRacer</a> on my <em>old</em> MacBook Pro and scored in the 95-105WPM range over 5 tests.</p>

<p>Then I went to TypeRacer on my <em>new</em> MacBook Pro and did 5 more tests.</p>

<p>My range there was 105-120WPM. So I’m typing at 15-20WPM faster on this keyboard than I was on the old one.</p>

<p>This keyboard <em>is</em> better for me than the old one was. It seems that Apple has fixed the keyboard issues.</p>

<p>Bravo.</p>
]]></content>
 </entry>
 
 <entry>
   <title>Rough Edges</title>
   <link href="http://ryanbigg.com/2019/11/rough-edges"/>
   <updated>2019-11-18T00:00:00+11:00</updated>
   <id>http://ryanbigg.com/2019/11/rough-edges</id>
   <content type="html"><![CDATA[<p>Our job as software developers is to make functional software.</p>

<p>A user should be able to use our software to accomplish tasks that might otherwise take a long time if they were doing it without computers. This has a wide-and-varied range, of course. But the main thing is that we need to make software <em>that works</em>.</p>

<p>If we didn’t do that, we would find ourselves out of a job very quickly.</p>

<p>However, functional software shouldn’t just be the only thing we strive for.</p>

<p>We should also strive to eliminiate rough edges in our software. We can do this through a process of quality assurance testing, introspection and by plain old taking feedback from our users <em>and acting on it</em>.</p>

<p>We need to listen to real user feedback, discover what the rough edges are in our software and work to eliminate the roughness.</p>

<p>For users of our software this can look like:</p>

<ul>
  <li>A page that takes 10 seconds to load <em>is a rough edge</em>. Could we make it load in 5 seconds, or under a second? Why are our users waiting so long?</li>
  <li>A process that takes a user several clicks through tricky menus <em>is a rough edge</em>. Can we make a shortcut for common user flows instead?</li>
  <li>A part of our application that works on browsers, but not on mobile <em>is a rough edge</em>. Can we make that page responsive and useable on devices smaller than a 30” desktop or 13” laptop?</li>
  <li>A feature that works in one part of our application, but not in another <em>is a rough edge</em>. A feature should work in predictable ways, everywhere. For instance: <code>/collapse</code> works in the main Slack window, but not in threads. Why not?</li>
</ul>

<p>Rough edges in software are human-software interaction problems. They should be treated at the same level as a bug or as an exception. A rough edge <em>is an exceptional thing</em>.</p>

<p>We must work to make functional, smooth software that is pleasing to use. Software that is as free as rough edges as we can make it.</p>
]]></content>
 </entry>
 
 
</feed>