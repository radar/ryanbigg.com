I have seen the future.

Five years from now, someone will get on a stage like this one (or perhaps
even this one) and _blow your freaking minds_. This person will _astound_ you
with a radical talk on a subject we, in the present, can only guess at. That
person is not going to be Avdi, Sandi or any of the other speakers here. It's
not even going to be me -- as much as I (and my ego) would like that.

In fact, the person who will _blow your minds_ knows a model today as someone
who would walk down a catwalk in some ostentatious outfit. They think that a
view is what you get from that lookout up in the mountains. They think that
"Ruby on Rails" is a cause for concern, as enough Rubies of significant sizes on
enough Rails might derail a train. And what a waste of good jewels!

Today, this person has just started on Chris Pine's Learn to Program. They have
invoked the `puts` method for the very first time.

Tomorrow, they will attempt the Ruby Koans. Next week, they will dabble a bit
in HTML and CSS. A few months from now, they might learn that Ruby On Rails
puts the HTML and the CSS and the Rubies together and it gives them those nice
shivers of excitement when it all Just Works™.

And five years from now they will _blow your freaking minds_ with a talk of
astonishing brilliance, eloquently delivered with perfectly timed (and
tasteful) jokes.

And five years from now, we will know very clearly who this person is. This
is because they will be on stage, speaking. And they will have a name badge
and the badge will tell us who they are.

But right now, we couldn't pick this person out from a crowd, or even a small
gathering for that matter. In our minds, this person simultaneously does and
does not exist. We can picture who they might be, but I guarantee you: the
picture doesn't match the eventual reality.

I'm not one to give out spoilers freely, so I won't tell you who they are.
You'll just have to wait and see.

But then how did I come to know this oddly-specific thing about the future?
Well, I _could_ tell you but that would ruin the surprise. So I'm not going to
tell you that either.

What I can tell you is that one of you will hire this person as a junior
developer and that will be their very first job. You will kick-start the career
of someone astonishingly brilliant and it's going to be all because of what
I'm about to tell you, so pay close attention.

If there was one take away from this talk that I want to stick in your minds it
would be this: hire a junior. Because that junior you hire today could turn out
to be the person blowing your minds in 5 years time.

## Hiring seniors

"But Ryan, we only hire mids and seniors!" -- ahh the classic ActiveMantra in
the Rails community: "Hiring senior Ruby developers."

Yeah but how's that working out for you at the moment? Probably not so great.
It's well known that there are only three hard problems in computer science:
cache invalidation, naming things and hiring more senior Ruby developers. There
are probably bookmakers out there that have shorter odds on scientists finding
life on another planet than we do as a community finding a senior Rails
developer looking for a job.

We have drained the talent pool dry. And yet our obsession continues. We only
hire mids and seniors. But why do we have this obsession? Well, let's take a
look at the main reason.

The main reason why we want to hire mids and seniors is because our workload
has gotten to the point where it's exceeding our capacity. Tons of companies are
hiring at the moment for this very reason. The _demand_ for work is outstripping
the _supply_ of developers.

To address this problem, we hire a new developer or rather... we try to hire a
new developer. We want a mid-to-senior developer because they have the skills
to instantly dive straight into our application with little-to-no guidance and
they can start shipping code. That old expression: "they can hit the ground
running". This is because our code is so brilliantly well-structured and
organized according to the Rails best practices. Nobody will have to upskill
on any single part of the codebase at all because we follow the Laws of
Sandi and Commandments of Avdi to the letter. There is no legacy code with their
legacy decisions, written in a hurry because we needed to ship that thing
_fast_. HA.

However: as I said before, it seems as though we would have more luck finding
life on a different planet than being capable of finding an available senior
Ruby developer.

Companies spend thousands of dollars on recruiters and lots of time posting to
job boards, for often very little good return. Companies spend this money to
hunt the elusive 10x Developer Rockstar Unicorns (note: term used ironically),
but the Unicorns are no longer out grazing in the sunny meadows, readily
available for capture.  They're already working somewhere else and the
conditions of where they work are extremely competitive. To keep with the
analogy: the meadows are filled with the greenest of grasses and the brightest
of rainbows. You will have a hard time luring these unicorns away.

We're out of freely available Rockstar Unicorns because they're already employed
elsewhere. Attempting to hire them is an exercise in futility. And so it's time
that we started to grow our own. It's time that we started to hire and train our
own 10x Developer Rockstar Unicorns.

But where do we find these developers? Well, to start with need to lower our
bar for engineering talent and not be so caught up on hiring the
best-of-the-best _now_, but instead we should be investing more in people's
future potential.

Your next Rockstar Unicorn isn't within today's current top 5-10% of all
developers: they're hanging with the rest of their peers in the other part of
this totally scientific graph that I didn't make up.

There isn't an endless supply of brilliant people. This talent pool of amazingly
talented and gifted developers, as we're painfully finding out, is not
limitless. We must lower the bar for our hiring, and hire juniors. We must then
train these juniors up to be our next generation of brilliant minds.

It is very, very difficult to hire a senior developer today in Rubyland. And so
we must grow our own senior developers. This is a process that will take time.
There's no packet mix where you "just add water" and blammo you've got a senior
developer. I'm talking about _years_ of hard work. But these are _vital_ years
of hard work to ensure that our companies and this community continues to thrive
and grow. This is necessary work  to ensure that we have well-trained developers
working at our companies. We will know they're well-trained because we did the
training ourselves.

After all, senior devs don't grow on trees. We must give juniors a chance.
Don't take just my word for this either. Here's a tweet from 4 years ago too
from someone else _saying exactly the same thing_.

https://mobile.twitter.com/buritica/status/492807632659689472

## Juniors make teams better

We should not lower our hiring bar and hire juniors just because we can't find
seniors though. We should do it to ensure the long-term survivability of our
companies and our community.

"But Ryan, we have to ship things fast!!"

Ah yes, that old sacred cow of software development: shipping things _fast_. We
have to ship things _fast_ and hiring and mentoring juniors means that we take
time away from actually shipping things. Anything that hurts "shipping things
fast" is taboo.

### Gotta go fast!!

It's pretty strange that we, the people who get the computers to do the hard
thinking, can't find time to mentor a junior. We're too busy shipping things.
We'll hire a junior when we're not as busy. Oh the lies we tell ourselves.

Why are we too busy? What's the rush? If we don't deliver these five features
and fix these three bugs by Friday, is our company going to go down in flames?
Not usually. There are plenty of companies here who have been here for the
long-term now, and who will probably be here for just as long again. The busy-
ness will not change. We all know that work is neither a liquid or a solid. It
is a gas: it fills any and all available time.

The work is always present, but the people who do the work are not going to be.
People leave: they change jobs, professions, countries and lifestyles. Or
sometimes they just plain ol' die. Turnover: it's a thing.

People leaving affects our rate of shipping. We have to hire new talent to
replace them. We have to train that new talent up anyway. So why not hire a
junior and train them up to do the job?

Other professions, like lawyers, mechanics, teachers and plenty of others
recognise that the people who are doing the work today aren't going to be doing
the work forever. Their work too is always ongoing and they have to do whatever
their equivalent of "shipping things fast" is.

The major difference is that these professions have active apprenticeship
efforts, where these apprentices then usually go on to become the next
generation of lawyers, mechanics, teachers or whatever else.

But why aren't many companies in our industry doing this? Why are we too
busy, but lawyers aren't? Have you _seen_ what kind of hours lawyers put in?

I think that other professions are not junior-adverse because those professions
have had turnover in their companies enough to learn the lesson about training
for the future. They have reached the point that we're at now where there just
isn't enough "senior" lawyers, mechanics or teachers to go around, work amasses
and growing the company gets _harder_ and so they reach the inevitable
conclusion to start hiring _and training_ brand-new talent because it's the
(yet).

The principal running the school your kid goes to realises that the teachers
they have aren't going to be around forever. This is because teachers are not
yet solar-powered automatons. They hire these young upstarts from universities,
like my wife, to be the teachers of the future.

The grizzled mechanic that fixes your car for the last decade (or more) has
saved his pennies and is retiring off the coast of Australia on his catamaran.
Davy, the best young mechanic he has, is the one who will run the shop once ol'
grizzle-face is gone. Grizzle-face reckons she'll do, and I quote: "a bang up
job. She'll be right mate."

This Ruby community is still a young community where most people have been
doing this Ruby thing for less than 15 years. That's less than a generation.
If Rails was a person, that person would not even be old enough to have
graduated high-school, let alone make adult decisions. This is reflected
somewhat in the design choices of the framework, but that's a conversation for
another day.

We must make our succession plans to ensure the long-term viability of this
community. The people who are doing the work now will not be doing the work
forever. Other professions have succession plans because they've lived long
enough to realise that having them is the sensible thing to do. I strongly feel
like we are at that point now, or at least the cusp of it.

This emphasis on shipping things faster and "delivering value" is short-term
enough to be frustrating. The companies we're building and the code we're
writing will last longer than a month or two... usually. For instance, Culture
Amp -- the company I work for -- has existed for 6 years. Who's to say it won't
exist for another 6?  So we need to think more long-term than shipping fast. We
must account for this turnover in our day-to-day thinking.

What we really need to think about is: who will look after the code that powers
our companies a year, or five years from now?  How do we ensure the long-term
survivability of our companies, and our community as a whole? What is our
succession plan?

I think that our succession plan should be to hire and mentor the talent of
tomorrow, starting today.

So there's now two reasons why you should hire a junior:

* It's really hard to hire a senior developer at the moment
* It helps bolster your company and the community in the long-term, ensuring
  the stability of both

I have a third reason for why you should hire a junior developer too: because
they make your team better.

## Juniors make teams better

Juniors making teams better is a big claim, but I have some evidence to back it
up. You might think that hiring a junior makes your productivity tank. While
that's true for the _short term_ it actually leads to _long term_ benefits for
the team the junior is in.

We know from a lot of experience that gender-diverse teams perform better than
either a team of all-men or a team of all-women. The same is true for teams that
are skill-diverse as well; teams that have a mix of people with differing
skill-levels out-perform their all-senior counterparts.

Hiring a junior means that things will need to be explained in simpler terms
than they were before. This makes things easier to understand for all members of
the team. Concepts are no longer talked about at a high-level all the time;
instead: people understand things in an easier way.

Teams that have a junior tend to document things more. For instance, a team I
was a part of recently documented the flow of an event through our main monolith
and some microservices. This documentation was done for the junior developer's
benefit and it consisted of a flowchart made up in Omnigraffle. The best part
about this piece of documentation was that we had something we could
_physically_ point to when talking about things we would only normally keep in
our head.

The funniest thing about that piece of documentation was that the _senior_
developers ended up referring to it more than the junior! We stuck it on a wall
and then talked about the structure of the system while pointing at the
different pieces in the diagram. It really helped cement the structure into our
heads.

If it wasn't for our junior developer, we wouldn't have written this
documentation in the first place.

This links into my next point:

Communication, especially when it comes to knowledge-sharing, becomes _explicit_
out of necessity, rather than the _implicit_ style of communication usually
found in all-senior developer teams. More questions get asked by the junior than
the senior because the junior wants to learn. The answers to these questions not
only help cement the junior's knowledge, but they give the senior developer
practice in explaining concepts that they might not have otherwise.

Sometimes a question from a junior can even spark a thought about how to
structure something better in the code, or how to document a part of the system
in further detail so that everyone on the team can better understand it.

One more thing: all of the juniors at Culture Amp have mentored our senior
developers on the most important programmer skill: patience. This is the thing
that juniors provide to your team that no senior can do. The seniors must
explain things to a junior, and that takes time. They might even have to
explain things more than once. Patiently explaining something to someone helps
seniors understand their own systems better and, in my extremely scientific
opinion, makes the seniors much better developers than if they only had to
explain things to other seniors. They need to slow down and methodically
explain things, which helps solidify the senior's knowledge.

Patience is a virtue that more developers should learn. The ironic thing about
me saying this is that I'm a naturally impatient person (just ask anyone who's
known me for more than 5 minutes)... who's getting more patient because of the
mentoring I'm doing. Huh, maybe it works.

This is why we should hire junior developers: it makes our teams better. Things
are better understood. Documentation exists more on teams with juniors.  Clearer
communication channels open up out of necessity. The team is better for it.

Better teams ship better software and better software means happier users.

So that's my third point: you should hire a junior developer because it makes
your team better.

## You must give juniors a chance

You may think that you need to hire only these best-of-the-best badasses because
your application is a large unmaintable behemoth monolith and only the badasses
can understand it. That you need seniors to navigate the spaghetti that is your
legacy code. Maybe you use technologies that only _true_ geniuses can
understand, like Node or Go.

That may indeed be the case. After all, if our code was simple, elegant and only
written in Ruby, would as many of us still be employed? But in every monolith,
there is a small bit of functionality that a junior developer can work on
improving along with their skills, when that junior is paired with a senior
developer. The juniors can practice their skills by fixing bugs and working with
the seniors to develop features.

This is the way we grow these juniors into the next generation of great
developers. This is the way that we get more mids and seniors in our companies:
we make them ourselves. "Bespoke", hand-crafted senior developers. Over time,
these developers _will_ become great developers if we invest in them.

So to recap, the three reasons I have for hiring a junior are:

* It's hard to hire a senior developer, and training a new one up is easier
  (although it does take longer)
* Hiring a junior boosts the long-term sustainability of your company and the
  community as a whole
* Hiring a junior makes your teams _better_ by improving communication within
  that team

### The Talent Code

If all of that wasn't convincing enough, then I would encourage you to read a
book called "The Talent Code". As the subtitle says "Greatness isn't born. It's
grown." It's about 300 pages long.

The book covers how skills of all varieties are grown in sports, music and
plenty of other areas. All the industries that are covered in the book have
active mentorship and apprenticeship programs. Yet, this is not deeply cared
about in the programming community for reasons mentioned earlier: we're still
quite a young community; we aren't mature enough to think long- and-hard about
mentorship and the sustainability of talent in this community within our
companies. We have events like the Rails InstallFests, and Rails Girls, but we
need more mentoring and junior opportunities within our companies. These
opportunities will bridge the gap between these events and doing Rails-
as-a-job. We need to focus more on growing talent within our companies and
community.

I'll let you in on the secret that's in the Talent Code: for anyone to get
better at anything, they need to practice the hell out of it, have a passion
for it _and_ they need to have a good mentor who is encouraging and can
provide sound advice. Okay, now you don't have to read 300 pages to learn
that. Scratch that book off your list.

How do we expect to have more seniors to hire if we're not hiring those non-
senior people and letting them improve their skills by practicing on real
world applications? They do not simply pop into existence. This isn't the
Matrix: we can't just plug in, and a few seconds later we just _know_ Rails.
They have to be taught. We have to grow talent if we want talent.

There are already companies out there who are hiring juniors, which is great to
see. For instance, we have Zendesk, Envato and Hooroo all running active
mentorship programs here in Melbourne. But the best one is Culture Amp's, of
course.

So many people are already talking about how good it would be to hire and mentor
juniors. Let's start doing it. Let's start having more of these conversations
to the management in our companies.

## Hiring juniors at Culture Amp

I know for a fact that with even a few months worth of training, these
developers can be productive. I know that juniors can be productive, because
we're making it happen at Culture Amp. We just hired seven new junior developers
last year, and that makes ten juniors total at Culture Amp. Each of these
juniors comes from a diverse background: They're not all 20-35, white, male,
senior developers and yet our company is still in business. Amazing, I know.

At the end of last year, we started up a structured training program for these
juniors called the Culture Amp Junior Engineering Program.

During the program, we provide structured training to these 10 juniors over the
course of 6 months. For the first half of the program, the juniors are working
two days a week (Monday and Tuesday) doing "Program work" and the other
three days they're with their teams. In the 2nd half (starting next week), we'll
be switching to a more intensive 1-week JEP work, 2-weeks team-work cycle. This
will give them more time to focus on larger chunks of JEP and team work, without
context switching so much.

When the 6 months are up, they'll be fully-fledged developers, capable of
shipping things on their own. They'll then be working on their teams full-time.

During the JEP days we:

* Work on little toy projects
* Practice debugging real bugs in our real codebases
* Learn about database fundamentals like the differences between relational and
  document databases (we use both at Culture Amp)
* Learn about best practice software development with Ruby
* Go off and research new programming concepts

Then on the team days -- that's Wednesday, Thursday and Friday -- the juniors
apply this knowledge from the JEP days to solve problems, fix bugs and ship
features. They might not be shipping them _fast_ now, but they're shipping them.
The fast comes with practice. They do this by practicing their craft by pairing
up with senior developers. This is one way that Culture Amp is ensuring that our
company and this community keeps growing.

All ten of our juniors have only two things in common: they work at Culture
Amp and they have a great tenacity for learning, which I think is the best
quality to have as a developer. They may come across something that they don't
know, and each of them will go and try to learn about it, each in distinct ways.
It's so great to see.

My point here is that we've hired people who aren't all white, male, 25-34,
utterly amazing senior Rails developers and yet... everything is still OK. In
fact, it's better than OK: it's awesome. We've hired a mixed bunch of skill
levels and we get them to work together on our applications and there's not a
single fire or brimstone as far as the eye can see.

We're growing the next batch of brilliant engineers today.

There are other companies out there running similar programs. Some Australian
ones that I can think of are Hooroo, Zendesk, Envato and REA. 

## You should hire a junior

I think more companies should try to hire juniors and to mentor them. I'm not
suggesting that you should hire a batch of them like Culture Amp did. I think
you should just start at hiring a single junior. Interview a couple and pick one
from that batch. If your company is at least 5 developers and at least one of
them wants to mentor, you can hire and support a junior. I believe in you.

Your next question might be: "what do _we_ (as a company) get out of hiring a
junior?" I think that's backwards. The thinking should be "we have earned so
much from the community, and now it's time to give back". "Ask what you can do
for your [community]" and all that. We have benefited from this community and
culture for over a decade now. To ensure the long-term viability of this great
Ruby community we have for at least another decade, we need to train up the
next generation. If you invest in the long term health of the community, it
will pay even greater dividends than what we have reaped already. In the long
run, you will have people who you have trained up specifically to work on your
application and who have the knowledge and skills to teach other people. In
the short term, you'll be bolstering your team's productivity with fresh
talent, ensuring the sustainability of your company over the long term.

Now that I've convinced you to hire a junior, you might be thinking: where do
you find these juniors? What do I do with them once I have them? It's time for
the "take home advice" section of this talk.

## Finding Juniors

Regarding finding the juniors: let's start with Code Academies and universities.

Code academies and universities produce great talent, but that talent often has
a hard time finding a job afterwards. The bar for hiring at a lot of companies
is too high.  It feels to me like there's a big chasm between someone just
joining the community and getting a job at a Ruby development shop.

In fact, I even drew you a picture.

The code academies and universities are producing brand new talent at a faster
rate than we're hiring. These people are left to struggle for months at a time
in developing their skills before they can even get a look in at a company. Our
collective bar is too high for these juniors to get a look in.  I've spoken to
many juniors in that position. Companies want to hire people with experience,
but they don't want to give them the experience in the first place. With the
talent pool run dry, it's time we started hiring these juniors and training them
up.

Remember: senior devs don't grow on trees. We must give juniors a chance.
If you want to hire a junior, looking at the people coming out of code academies
and universities is a great place to start.

The senior developers of the future are coming from the code academies and
universities of today. More companies need to make mentorship / apprenticeship a
part of what they do. It's vital for the sustainability of the company. The
students that graduate from code academies and universities are eager to learn
and are, in my experience, very highly motivated. We've hired 3 people at
Culture Amp from places like this: Jaime, Rebecca and Jasmine. Jaime comes from
Coder Academy in Melbourne, and Rebecca and Jasmine both went to the same
university.

There are definitely juniors who have that same kind of eagerness-to-learn and
motivation who have never been to a code academy or a university. These people
have learned by themselves and by being mentored by people in the community. Out
of the Culture Amp juniors I mentioned before, two fit this bill: Namibia and
Julie.  While they haven't gone through intensive coding schools or
universities, they still bring to Culture Amp a great set of skills that they've
built up themselves. Their ability to learn on their own far exceeds those who
have been classically taught, because they haven't had that support net.

We interviewed a bunch of other people who fit this bill and while we didn't
place them at Culture Amp this round, they would make great juniors to hire in
the future, or for other Ruby companies.

The people who come from coding academies, universities and who are self-
taught are the future brilliant developers of this community and we should
hire and start training them _today_. They are the brilliant developers of
tomorrow.

### Interviewing Juniors

I won't speak much about the Culture Amp interview process, because that's a
talk itself.

The short version is that we had over 100 applicants and ended up hiring only
five people. Oh and I sat in a podcast-booth-sized room interviewing people for
two and a half weeks. It was a wild ride. Ask me about it later.

One thing I want to mention about that process though is our coding test that
was a part of that interview process. We used this coding test to gauge the
technical skills of the juniors who were applying at Culture Amp.

Specifically, I want to talk about the feedback that we gave to the juniors
after we reviewed what they submitted for this test.

We built this junior-friendly coding test from scratch and sent it out to all the
applicants who passed the initial interview stage. We then reviewed that coding
test, giving _on average_ seven pages of feedback per candidate. It ended up
being over 400 pages of feedback.

Culture Amp is a feedback company, and so we have a reputation to uphold. But
that wasn't the only reason. The more important reason was this: we wanted to
give juniors this extremely detailed level of feedback because we felt that
getting back a flat "no" on a coding test that you spent tens of hours on would
be really demotivating for juniors. We wanted to give them some feedback, and
our rules for feedback was that it had to meet three criteria. The feedback had
to be:

* Actionable
* Specific
* Kind

It had to be these things because we wanted to motivate the juniors towards
self-improvement, even if they didn't "pass" the coding test. A flat "no" would
be incredibly de-motivating to receive as a junior. We didn't want that. We
wanted to encourage them even if we rejected them.

And so when we sent out this feedback it was detailed, personalized and designed
to give helpful advice to each junior. It took us quite a few hours to compile
this feedback, but we think it was worth it.

The juniors who got this feedback thought so too. Here's some of the feedback
that we got back from them:

* The feedback provided was valuable information which will help me improve for
  future interviews.
* I wanted to say thank you for the detailed feedback that was supplied for the
  coding challenge.
* Thank you for your feedback, I feel like I've already learned a lot from it.

We're going to do this again the next time we hire a junior, and I would suggest
if you're hiring a junior you should keep this in mind too. Juniors _thrive_
given this sort of feedback. It's vital for their future growth. Putting in a
little bit of extra effort for juniors will help them grow. Proivde them some
Actionable, Specific and Kind feedback after you interview them.

## Mentorship

OK, so we've talked about where to potentially find juniors, but what do you do
once you have them?

Well, for starters: they're going to need a lot of love and attention. you can't
just put them in the corner and expect them to thrive. Think more of them like a
puppy than a cactus: the puppy needs love and attention and some training, but
the cactus needs only sunshine and some water.  The cactus is indifferent to
your love, your attention or the intensity of the training you provide.

Junior developers don't grow into senior developers with just sunshine and
water. And they don't do it just by practicing, either. They need mentorship and
thrive on direction!

I used to help run the Melbourne Ruby Hack Night and it's a judgement-free
environment where anyone and everyone can bring along a Ruby project and work
on it. Some people are even there for the first time learning about Ruby
itself, which is so great to see. These Hack Nights work because these new
developers feel safe and welcome and that no question is too "dumb" to ask.

You could start these events in your cities. They're great for introducing new
developers to Ruby. Just like the Rails InstallFests and Rails Girls events,
they provide an avenue for new developers to enter this community.

You can also start mentoring at your company by fostering that Hack Night- esque
environment. It should be OK for anyone to put their hand up and ask a question
about _anything_. If the questioner is getting eyerolls, sighs, or other passive
aggressive signals from someone else, then that's not the kind of environment
where a junior is going to learn and thrive. That doesn't happen much in the
Ruby community because we're so good at building fostering environments, and
that whole MINASWAN ethos helps us do it. But very clearly outlining to juniors
that it's OK to ask _any_ question about _anything_ is a great place to start.
And repeat that as much as possible, too.

A great way to build that kind of hack-night-esque fostering environment is to
encourage pair programming. Pairing with juniors on small tasks initially is a
great way to build up their confidence. When I've been mentoring juniors, the
number one thing that I find that they're lacking isn't the skill, but the
confidence. They know the answer, but they aren't sure if it's the _right_
answer. They question if they're using the right syntax or even if they should
be writing the code that particular way. When a senior pairs with a junior,
they can encourage them to try out things and learn from the things that they
try. If the junior gets it wrong, the senior can ensure them that it's OK to
get things wrong and to guide them back on track. Pairing is the quickest way
to upskill a junior and I can highly, highly recommend it.

Remember: puppy, not cactus.

Pairing also helps reinforce your own knowledge. If you can't explain
something to someone clearly, then you do not understand it well enough
yourself. Pairing is helpful to the junior because they get knowledge out of
it, but it's also helpful to the senior: they learn how to share what's in
their brain with other people in a clearer fashion. As I said before, it also
teaches the most valuable skill of all: patience.

What should you pair with your junior on? Well, Lydia Guarino has some good
tweets about that.

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">5) For junior devs, a good guideline for scope is something that can be completed in 2-3 days. You want to keep your feedback loop short.</p>&mdash; Lydia Guarino (@lydiaguarino) <a href="https://twitter.com/lydiaguarino/status/720090654575996928">April 13, 2016</a></blockquote>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">5) Tasks with scope of more than 3 days are tasks that are not defined well enough. Break them down further.</p>&mdash; Lydia Guarino (@lydiaguarino) <a href="https://twitter.com/lydiaguarino/status/720090891231166464">April 13, 2016</a></blockquote>

I agree with both of these. Juniors thrive best when they're given quick wins.
You want that nice tight feedback loop to keep their confidence growing. Every
time they "win" at code, their confidence gets that little bit more boosted.
At Culture Amp, we started our juniors out on fixing bugs or working on little
features and then moved them up to trickier bugs and harder features from
there. Most bugs didn't take more than a day for the juniors to fix.

Once they've built up a bit of confidence, you can let them go solo on a task.
There isn't a set timeframe for when this happens; it's all about how
confident the junior is with their own abilities. Let them loose on something
small and make it clear that they can ask any questions about what they're
doing and that there is no wrong way of doing it.

Once they're done, get them to submit their work in a pull request and then --
this part's important -- sit together and review it.

Sitting together is important here because "why are you doing this?" written
in text has no emotion, compared to it spoken with body language. Juniors may
interpret a "why are you doing this?" comment as aggressive like "UGH! Why are
you doing this?".

Focussing on in-person communication helps establish a rapport between the
developers much better than text-based communication ever will.

If a junior has made a mistake in the pull request then you can discuss it
with them and correct the mistake. This way, that mistake will never make it
to a live production environment. Pull request reviews are good for that.

Code review also allows the senior to assess how well the junior has been
doing on the tasks they've been given. If they're doing well on a 2-day task,
then it's probably going to be OK to give them a 4-day task too. If not, then
some more mentoring may be required. And that's perfectly OK. Give them that
mentorship and direction, and try again.

### Feeling welcome

Ultimately, your mentorship should be about making the junior feel welcome and
safe within your team. In fact, this should be what's happening with
_everyone_ in your team. Remember Google's Project Aristotle that I mentioned
before wherein [they attempted to find how to build effective
teams](https://rework.withgoogle.com/blog/five-keys-to-a-successful-google-
team/). They interviewed hundreds of their own employees and they came up with
5 things:

![Google's 5 key dynamics for effective teams](https://lh3.googleusercontent.com/eQ_WsRq5-q-m_41eEI6GLEObqpxBYJd1pm96gIa-eRSn-QXlPjwO5K6O-DHU8sxny3ChnIQE0mjpnXaaW7QAhQ=s0)

The #1 item on this list is "Psychological safety": "Team members feel safe to
take risks and be vulnerable in front of each other." You probably recognise
that some of these things sound a lot like [Maslow's hierarchy of
needs](https://en.wikipedia.org/wiki/Maslow%27s_hierarchy_of_needs), so that
Maslow guy was probably onto something.

The remainder of this list is not to be discounted. Dependability, Structure &
Clarity, Meaning and Impact are all vital to junior developers progressions.
When you hire a junior developer, keep these things in mind and ask yourself
regularly if you're following along with them. These things should underpin
everything you do with the junior.


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


But how did Culture Amp come to have _ten_ juniors? Well, we didn't exactly hire
them all overnight. In 2016, we only hired two junior engineers: Seb Pearce and Lauren.

In 2017, the year started out slow with Culture Amp only hiring one junior
engineer: Ramya Ravindranath. But when the Junior Engineering Program started
up in November, we hired 5 more juniors:

* Namibia Lebron Torres
* Jasmine Ellis
* Rebecca Vo
* Julie Huang
* Jaime Terreu

* 1 junior for every 5 seniors
* Seb was hired April 2016
* Lauren was hired October 2016
* Ramya was hired May 2017
* We hired 5 juniors in November 2017
* Angel transitioned to a junior role
* Tiya - CSE -- keen interest in learning more about Ruby / Rails

Alongside these five extra, we've also had two other people transfer from other
roles into the program too: Angel Peña Ruiz and Tiya Belayneh. So that makes ten.


### Risks

When I talk to people about hiring juniors, there's two main risks that they raise:

* What if we train them up and they leave?
* Won't this lead to a productivity hit?

So what if you do train them up and then they leave? That's a risk you take with
any hire of any skill level. If people are leaving your company, you should be
reflecting on why they're leaving in the first place. Was it really them, or was
it your company? Does your company have a culture that someone would want to
leave? Is your company focussed on building a culture that people want to stay
in? Is your company actively developing its software _and_ its people? Or are
they only interested in shipping code? What are you doing to encourage them to
stay?

To the second point of the productivity hit, that is an unavoidable truth.  Your
team will be _less_ productive once a junior joins it. There is an initial
productivity hit -- that's true -- but that plateaus out within 6 months if you
do it right. We've found that to be true for Seb, Lauren and Ramya at least, who have
now been at the company for 24, 18 months and 10 months respectively. Our other
juniors are reaching that level too through the structured Junior Engineering
Program.

At the end of training a junior for 6 months, rather than having one
developer, you have two developers.  Even if the junior is _half_ as
productive as the senior, then it's still a 1.5x growth in the productivity of
your team. If I told you today that you could ship things 1.5x faster in 6
months time with this one weird trick... you'd listen to me. Hiring a junior
is that one weird trick.
